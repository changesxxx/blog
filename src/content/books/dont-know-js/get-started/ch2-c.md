---
title: 'dont js'
description: 'dont js.'
name: 'get-started-ch2'
---

# 你还不了解 JS：入门指南 - 第二版

# 第 2 章：测量 JS

学习 JS 的最好方法是开始编写 JS。

要做到这一点，你需要了解该语言的工作原理，这就是我们在这里要关注的重点。即使你以前用其他语言编程过，也要花点时间熟悉 JS，并确保练习每一个部分。

本章并非详尽介绍 JS 语言的所有语法。它也不是完整的“JS 入门”入门书。

相反，我们只是要概述该语言的一些主要主题领域。我们的目标是更好地了解*它*，以便我们能够更加自信地编写自己的程序。在您阅读本书的其余部分以及本系列的其余部分时，我们将逐步更详细地重新讨论其中的许多主题。

请不要指望这一章能很快读完。它很长，而且有很多细节需要咀嚼。慢慢来。

| 提示：                                                                                                                                                                                                                                                        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 如果你还在熟悉 JS，我建议你预留足够的额外时间来学习本章。学习每一节并花一些时间思考和探索主题。浏览现有的 JS 程序，并将你在其中看到的内容与此处提供的代码和解释（以及意见！）进行比较。有了扎实的 JS 本质基础，你将从本书和本系列的其余部分中获得更多*收获*。 |

## 每个文件都是一个程序

您使用的几乎每个网站（Web 应用程序）都由许多不同的 JS 文件（通常带有 .js 文件扩展名）组成。人们很容易将整个网站（应用程序）视为一个程序。但 JS 却不这么认为。

**在 JS 中，每个独立文件都是其自己单独的程序。**

这很重要的原因主要在于错误处理。由于 JS 将文件视为程序，因此一个文件可能会失败（在解析/编译或执行期间），但这不一定会影响下一个文件的处理。显然，如果您的应用程序依赖于五个 .js 文件，而其中一个文件失败，那么整个应用程序最多只能部分运行。重要的是确保每个文件都能正常工作，并且尽可能优雅地处理其他文件中的故障。

您可能会惊讶地将单独的 .js 文件视为单独的 JS 程序。从您对应用程序的使用角度来看，它确实看起来像一个大程序。这是因为应用程序的执行允许这些单独的*程序*协作并作为一个程序运行。

| 笔记：                                                                                                                            |
| --------------------------------------------------------------------------------------------------------------------------------- |
| 许多项目使用构建流程工具，最终将项目中的独立文件合并为一个文件，然后交付到网页。发生这种情况时，JS 会将这个合并文件视为整个程序。 |

多个独立 .js 文件充当单个程序的唯一方法是通过“全局作用域”共享其状态（以及对其公共功能的访问）。它们在这个全局作用域命名空间中混合在一起，因此在运行时它们作为一个整体运行。

从 ES6 开始，除了典型的独立 JS 程序格式外，JS 还支持模块格式。模块也是基于文件的。如果文件通过语句`import`或`<script type=module>`标签等模块加载机制加载，则其所有代码将被视为单个模块。

虽然您通常不会将模块（状态和公开暴露的用于操作该状态的方法的集合）视为独立程序，但 JS 实际上仍然将每个模块分开处理。类似于“全局作用域”允许独立文件在运行时混合在一起，将一个模块导入另一个模块允许它们之间在运行时进行互操作。

无论文件（独立文件或模块）采用哪种代码组织模式（和加载机制），您仍应将每个文件视为其自己的（小）程序，然后可以与其他（小）程序协作来执行整个应用程序的功能。

## 价值观

程序中最基本的信息单位是值。值是数据。它们是程序维护状态的方式。JS 中的值有两种形式：**原始**和**对象**。

*值使用文字*嵌入到程序中：

```
greeting("My name is Kyle.");
```

在这个程序中，值`"My name is Kyle."`是一个原始的字符串文字；字符串是有序的字符集合，通常用于表示单词和句子。

我使用双引号`"`字符来*界定*（包围、分隔、定义）字符串值。但我也可以使用单引号字符`'`。选择哪个引号字符完全取决于风格。为了代码的可读性和可维护性，重要的是选择一个并在整个程序中一致地使用它。

分隔字符串文字的另一种选择是使用反引号```字符。但是，这种选择不仅仅是风格上的；还有行为上的差异。考虑一下：

```
console.log("My name is ${ firstName }.");
// My name is ${ firstName }.

console.log('My name is ${ firstName }.');
// My name is ${ firstName }.

console.log(`My name is ${ firstName }.`);
// My name is Kyle.
```

假设此程序已经定义了一个变量，`firstName`其字符串值为`"Kyle"`，**`** -delimited 字符串会将变量表达式（用 表示`${ .. }`）解析为其当前值。 这称为**插值**。(这里有问题!! todo)

\```可以使用反引号分隔的字符串而不包括插值表达式，但这违背了替代字符串文字语法的整个目的：

```
console.log(
    `Am I confusing you by omitting interpolation?`
);
// Am I confusing you by omitting interpolation?
```

更好的方法是对字符串使用`"`或`'`（再次选择一个并坚持使用它！），*除非您需要*插值；```仅为包含插值表达式的字符串保留。

除了字符串之外，JS 程序通常还包含其他原始文字值，例如布尔值和数字：

```
while (false) {
    console.log(3.141592);
}
```

`while`*表示一种循环类型，即在*条件为真时重复操作的方式。

在这种情况下，循环将永远不会运行（并且不会打印任何内容），因为我们使用`false`布尔值作为循环条件。`true`会导致循环永远持续下去，所以要小心！

`3.141592`您可能知道，该数字是数学 PI 的前六位数字的近似值。但是，您通常不会嵌入这样的值，而是使用预定义`Math.PI`值来实现此目的。数字的另一种变体是`bigint`（大整数）原始类型，用于存储任意大的数字。

数字最常用于程序中计算步骤，例如循环迭代，以及访问数字位置（即数组索引）中的信息。我们将稍微介绍数组/对象，但作为示例，如果有一个名为的数组`names`，我们可以像这样访问其第二个位置的元素：

```
console.log(`My name is ${ names[1] }.`);
// My name is Kyle.
```

我们使用`1`第二个位置的元素，而不是`2`，因为与大多数编程语言一样，JS 数组索引是从 0 开始的（`0`是第一个位置）。

除了字符串、数字和布尔值之外，JS 程序中还有两个*原始*`null`值是和`undefined`。虽然它们之间存在差异（一些是历史差异，一些是当代差异），但大多数情况下，这两个值都用于表示值的*空值*（或缺失）。

许多开发人员更喜欢以这种方式一致地处理它们，也就是说，假设这些值是无法区分的。如果小心谨慎，这通常是可能的。然而，最安全、最好的方法是只用作`undefined`单个空值，尽管它`null`看起来很有吸引力，因为它的输入更短！

```
while (value != undefined) {
    console.log("Still got something!");
}
```

最后一个需要注意的原始值是符号，它是一种特殊用途的值，表现为隐藏的不可猜测的值。符号几乎专门用作对象上的特殊键：

```
hitchhikersGuide[ Symbol("meaning of life") ];
// 42
```

在典型的 JS 程序中，你不会经常遇到直接使用符号的情况。它们主要用于库和框架等低级代码中。

### 数组和对象

除了原始值之外，JS 中的另一种值类型是对象值。

如前所述，数组是一种特殊类型的对象，由有序且按数字索引的数据列表组成：

```
var names = [ "Frank", "Kyle", "Peter", "Susan" ];

names.length;
// 4

names[0];
// Frank

names[1];
// Kyle
```

JS 数组可以保存任何值类型，无论是原始类型还是对象类型（包括其他数组）。正如我们将在第 3 章末尾看到的那样，即使是函数也是可以保存在数组或对象中的值。

| 笔记：                                                                         |
| ------------------------------------------------------------------------------ |
| 函数与数组一样，是一种特殊的对象（也称为子类型）。稍后我们将更详细地介绍函数。 |

对象更为通用：无序的、键控的任意值集合。换句话说，您可以通过字符串位置名称（也称为“键”或“属性”）访问元素，而不是通过其数字位置（与数组一样）。例如：

```
var me = {
    first: "Kyle",
    last: "Simpson",
    age: 39,
    specialties: [ "JS", "Table Tennis" ]
};

console.log(`My name is ${ me.first }.`);
```

这里，`me`代表一个对象，`first`代表该对象中信息位置的名称（值集合）。另一种通过属性/键访问对象中信息的语法选项使用方括号`[ ]`，例如 `me["first"]`。

### 值类型确定

为了区分值，`typeof`运算符会告诉您它的内置类型（如果是原始类型），否则`"object"`：

```
typeof 42;                  // "number"
typeof "abc";               // "string"
typeof true;                // "boolean"
typeof undefined;           // "undefined"
typeof null;                // "object" -- oops, bug!
typeof { "a": 1 };          // "object"
typeof [1,2,3];             // "object"
typeof function hello(){};  // "function"
```

| 警告：                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `typeof null`不幸的是，返回的是`"object"`而不是预期的`"null"`。此外，`typeof function`返回函数的具体值`"function"`。而数组的预期值不是`"array"`。 |

从一种值类型转换为另一种值类型（例如从字符串转换为数字）在 JS 中称为“强制”。我们将在本章后面更详细地介绍这一点。

原始值和对象值在分配或传递时的行为有所不同。我们将在[附录 A“值与引用”]()中介绍这些详细信息。

## 声明和使用变量

明确说明上一节中可能不太明显的一点：在 JS 程序中，值既可以作为文字值出现（如前面的许多例子所示），也可以保存在变量中；可以将变量视为值的容器。

变量必须声明（创建）才能使用。声明变量（又称“标识符”）的语法形式多种多样，每种形式都有不同的隐含行为。

例如，考虑以下`var`语句：

```
var myName = "Kyle";
var age;
```

该`var`关键字声明在程序的该部分中使用的变量，并且可选择允许初始分配一个值。

另一个类似的关键字是`let`：

```
let myName = "Kyle";
let age;
```

**关键字`let`与 有一些不同`var`，最明显的是`let`允许对变量进行比 更有限的访问`var`。这称为“块作用域”，与常规或函数作用域相反。**

考虑：

```
var adult = true;

if (adult) {
    var myName = "Kyle";
    let age = 39;
    console.log("Shhh, this is a secret!");
}

console.log(myName);
// Kyle

console.log(age);
// Error!
```

尝试访问语句`age`之外的`if`内容会导致错误，因为`age`的块范围是`if`，而`myName`的不是。

**块作用域对于限制程序中变量声明的广泛程度非常有用，这有助于防止其名称意外重叠。**

但`var`它仍然很有用，因为它传达了“这个变量将被更广泛的范围（整个函数）看到”。这两种声明形式都适用于程序的任何给定部分，具体取决于具体情况。

| 笔记：                                                                                                                                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `var`建议避免使用 而使用很常见的`let`（或`const`），这通常是因为`var`自 JS 诞生以来，人们对 的作用域行为的工作方式感到困惑。我认为这是过于严格的建议，最终毫无帮助。它假设您无法学习和正确使用某个功能与其他功能结合使用。我相信您*可以*并且*应该*学习任何可用的功能，并在适当的地方使用它们！ |

第三种声明形式是`const`。**它类似于`let`，但有一个额外的限制，即必须在声明时赋予一个值，并且以后不能重新分配不同的值。**

考虑：

```
const myBirthday = true;
let age = 39;

if (myBirthday) {
    age = age + 1;    // OK!
    myBirthday = false;  // Error!
}
```

该`myBirthday`常量不允许被重新分配。

**`const`声明的变量并非“不可改变”，只是不能重新赋值。不建议将其`const`与对象值一起使用，因为即使变量不能重新赋值，这些值仍然可以更改。这会导致潜在的混乱**，所以我认为最好避免以下情况：

```
const actors = [
    "Morgan Freeman", "Jennifer Aniston"
];

actors[2] = "Tom Cruise";   // OK :(
actors = [];                // Error!
```

最好的语义用法`const`是当你有一个简单的原始值并想给它起一个有用的名称时，例如使用`myBirthday`而不是`true`。这会使程序更易于阅读。

| 提示：                                                                                                                     |
| -------------------------------------------------------------------------------------------------------------------------- |
| 如果你坚持`const`只使用原始值，那么你就可以避免重新分配（不允许）与变异（允许）的混淆！这是最安全、最好的使用方式`const`。 |

除了`var`,`let`,`const`之外，还有其他语法形式可以在各种范围内声明标识符（变量）。例如：

```
function hello(myName) {
    console.log(`Hello, ${ myName }.`);
}

hello("Kyle");
// Hello, Kyle.
```

标识符`hello`是在外部作用域中创建的，并且它也会自动关联，以便引用该函数。但命名参数`myName`仅在函数内部创建，因此只能在该函数的作用域内访问。`hello`并且`myName`通常表现为`var`-declared。

\***\*`var-declared`\*\***:变量是通过 `var` 关键字声明的。

声明变量的另一种语法是`catch`子句：

```
try {
    someError();
}
catch (err) {
    console.log(err);
}
```

该`err`是块范围变量，仅存在于`catch`子句内部，就像已用 声明一样`let`。

## 功能

“函数”一词在编程中有多种含义。例如，在函数式编程的世界中，“函数”具有精确的数学定义，并暗示了一套必须遵守的严格规则。

在 JS 中，我们应该认为“函数”具有另一个相关术语“过程”的更广泛含义。过程是一组语句的集合，可以调用一次或多次，可以提供一些输入，并可以返回一个或多个输出。

从 JS 的早期开始，函数定义如下所示：

```
function awesomeFunction(coolThings) {
    // ..
    return amazingStuff;
}
```

这被称为函数声明，因为它本身就是一个语句，而不是另一个语句中的表达式。标识符`awesomeFunction`和函数值之间的关联发生在代码的编译阶段，即执行该代码之前。

与函数声明语句相反，函数表达式可以像这样定义和赋值：

```
// let awesomeFunction = ..
// const awesomeFunction = ..
var awesomeFunction = function(coolThings) {
    // ..
    return amazingStuff;
};
```

该函数是一个赋值给变量的表达式`awesomeFunction`。与函数声明形式不同，函数表达式在运行时直到该语句才与其标识符相关联。

需要特别注意的是，在 JS 中，函数是可以赋值（如本代码片段所示）和传递的值。事实上，**JS 函数是对象值类型的一种特殊类型**。并非所有语言都将函数视为值，但对于语言来说，支持函数式编程模式是必不可少的，就像 JS 一样。

JS 函数可以接收参数输入：

```
function greeting(myName) {
    console.log(`Hello, ${ myName }!`);
}

greeting("Kyle");   // Hello, Kyle!
```

在此代码片段中，`myName`称为参数，它在函数内部充当局部变量。您可以根据需要将函数定义为接收任意数量的参数（从无到有）。每个参数都被分配了您在调用的该位置（此处为“Kyle”）传递的参数值。

函数还可以使用关键字返回值`return`：

```
function greeting(myName) {
    return `Hello, ${ myName }!`;
}

var msg = greeting("Kyle");

console.log(msg);   // Hello, Kyle!
```

您只能`return`返回一个值，但如果您要返回多个值，则可以将它们包装成一个对象/数组。

由于函数是值，因此可以将它们分配为对象的属性：

```
var whatToSay = {
    greeting() {
        console.log("Hello!");
    },
    question() {
        console.log("What's your name?");
    },
    answer() {
        console.log("My name is Kyle.");
    }
};

whatToSay.greeting();
// Hello!
```

在这段代码中，whatToSay 所持有的对象中包含了对三个函数（greeting（）、question（）和 answer（））的引用。通过访问属性来检索函数引用值，可以调用每个函数。将这种在对象上定义函数的简单风格与本章稍后讨论的更复杂的类语法进行比较。
函数在 JS 中有许多不同的形式。我们在[附录 A“如此多的函数形式”]()中深入研究了这些变化。

## 比较

在程序中做出决策需要比较值以确定它们的身份和相互关系。JS 有几种机制可以实现值比较，让我们仔细看看它们。

### 差不多

JS 程序中最常见的比较会问这样一个问题：“这个 X 值和那个 Y 值相同吗？”不过，“相同”对 JS 来说到底意味着什么？
由于人体工程学和历史原因，其含义比明显的精确身份匹配更为复杂。有时相等比较意味着精确匹配，但其他时候所需的比较范围更广，允许非常相似或可互换的匹配。换句话说，我们必须意识到平等比较和等价比较之间的细微差别。
如果你花了任何时间研究和阅读 JS，你肯定见过所谓的“三重相等”`===`运算符，也被称为“严格相等”运算符。这似乎很简单，对吧？当然，“严格”意味着严格，如狭义和精确

不完全是。

是的，参与===等式比较的大多数值都符合完全相同的直觉。考虑一些例子：

```
3 === 3.0;              // true
"yes" === "yes";        // true
null === null;          // true
false === false;        // true

42 === "42";            // false
"hello" === "Hello";    // false
true === 1;             // false
0 === null;             // false
"" === null;            // false
null === undefined;     // false
```

| 笔记：                                                                                                                                                                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ===的等式比较的另一种方式通常被描述为“检查值和类型”。在我们迄今为止看到的几个例子中，比如`42===“42”`，这两个值的类型（数字、字符串等）似乎确实是区分因素。不过，事情远不止如此。JS 中的所有值比较都考虑被比较值的类型，而不仅仅是`===`运算符。具体来说，`===`在比较中不允许任何类型的转换（又名“强制转换”），而其他 JS 比较确实允许强制转换。 |

备注:==比较会进行类型转换。算符在比较两个值时，如果它们的类型不同，会先尝试进行类型转换（强制转换），然后再进行比较。这种转换可能会导致意外的结果。

例:

```js
console.log(42 == '42') // 输出 true，因为 "42" 被转换为数字 42
console.log(0 == false) // 输出 true，因为 false 被转换为数字 0
```

转换规则:

1. **字符串到数字**：如果一个值是字符串，而另一个值是数字，JavaScript 会尝试将字符串转换为数字。
2. **布尔值到数字**：`true` 会被转换为 `1`，`false` 会被转换为 `0`。
3. **对象到原始值**：当对象与原始值（如字符串、数字）进行比较时，JavaScript 会调用对象的 `toString` 或 `valueOf` 方法来获取原始值。

但该`===`运算符确实有一些细微差别，许多 JS 开发人员都忽略了这一点，这对他们不利。`===`运算符设计*用于*两种特殊值的情况：`NaN`和`-0`。考虑一下：

```
NaN === NaN;            // false
0 === -0;               // true
```

对于 `NaN`的情况，`===`运算符*会撒谎*，出现`NaN`不等于另一个`NaN`。对于`-0` 的情况（是的，这是一个真实的、独特的值，您可以在程序中有意使用！）`===`运算符*会撒谎*，说它等于常规`0`值。

由于这种比较的*谎言*会让人感到麻烦，因此最好避免使用`===`它们。**对于`NaN`比较，请使用`Number.isNaN(..)`不会*撒谎*的实用程序。对于`-0`比较，请使用`Object.is(..)`同样不会*撒谎*的实用程序。如果您愿意`Object.is(..)`，也可以将其用于非*撒谎* `NaN`检查。有趣的是，您可以将它视为`Object.is(..)`“四重相等” `====`，即真正严格的比较！**

*这些谎言*有着更深层次的历史和技术原因，但这并不能改变这样一个事实：从*最严格的*`===`意义上讲，这实际上并不是*完全相等的*比较。

当我们考虑对象值（非原始值）的比较时，情况变得更加复杂。考虑一下：

```
[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false
{ a: 42 } === { a: 42 }         // false
(x => x * 2) === (x => x * 2)   // false
```

这里发生了什么事？

假设相等性检查考虑值的*性质*或*内容*似乎是合理的；毕竟，`42 === 42`考虑实际`42`值并进行比较。但是当涉及到对象时，内容感知比较通常被称为“结构相等性”。

JS 并不定义`===`对象值的*结构相等性*`===`。相反，它使用对象值的*身份相等性。*

**在 JS 中，所有对象值都通过引用保存[（参见附录 A 中的“值与引用”）]()，通过引用复制分配和传递**，**并且**根据我们当前的讨论，通过引用（身份）相等性进行比较。考虑：

```
var x = [ 1, 2, 3 ];

// assignment is by reference-copy, so
// y references the *same* array as x,
// not another copy of it.
var y = x;

y === x;              // true
y === [ 1, 2, 3 ];    // false
x === [ 1, 2, 3 ];    // false
```

在这段代码中，y===x 为真，因为这两个变量都引用了同一个初始数组。但是`===[1,2,3]`的比较都失败了，因为 y 和 x 分别与新的不同数组[1,2,4]进行了比较。在这种比较中，数组结构和内容并不重要，重要的是**引用标识**

JS 不提供对象值结构相等性比较机制，只提供引用身份比较。若要进行结构相等性比较，您需要自行实现检查。

但请注意，它比你想象的要复杂得多。例如，你如何确定两个函数引用是否“结构等效”？即使通过字符串化来比较它们的源代码文本也不会考虑诸如闭包之类的事情。**JS 不提供结构相等性比较，因为处理所有极端情况几乎是难以解决的！**

### 强制比较

强制转换是指将一种类型的值转换为另一种类型的相应表示（尽可能地）。正如我们将在[第 4 章中讨论]()的那样，强制转换是 JS 语言的核心支柱，而不是可以合理避免的某些可选功能。

但不幸的是，当强制类型遇到比较运算符（如相等式）时，混乱和沮丧往往会频繁出现。

在更广泛的 JS 社区中，很少有 JS 特性比`==`运算符（通常称为“松散相等”运算符）更能引起人们的愤怒。大多数关于 JS 的文章和公开讨论都谴责该运算符设计不当，在 JS 程序中使用时危险/错误百出。甚至连该语言的创建者 Brendan Eich 本人也哀叹它的设计是一个大错误。

据我所知，这种挫败感大部分来自于一小串令人困惑的极端情况，但更深层次的问题是人们普遍存在的误解，认为它在进行比较时不考虑所比较值的类型。

`==`运算符执行相等比较的方式与执行的方式类似。**实际上，这`===`两个运算符都会考虑被比较值的类型。如果比较的是同一值类型，则这两个运算`==`符执行`===` 的操作完全相同，没有任何区别。**

如果要比较的值类型不同，则==与===的不同之处在于它允许在比较之前进行强制转换。换句话说，它们都想比较相似类型的值，但==首先允许类型转换，一旦类型在两侧都转换为相同的类型，那么==就会做与===相同的事情。==运算符应该被描述为“强制相等”，而不是“松散相等”。

考虑：

```
42 == "42";             // true
1 == true;              // true
```

在两次比较中，值类型不同，因此==会在进行比较之前将非数字值（“42”和 true）转换为数字（分别为 42 和 1）。
只要意识到==的这种性质——它更喜欢原始的数字比较——就可以帮助你避免大多数麻烦的极端情况，比如远离像“==0”或 0==false 这样的陷阱
你可能会想，“哦，好吧，我总是会避免任何强制性的平等比较（使用===代替），以避免那些极端情况”！呃，对不起，这不太可能像你希望的那样。
你很有可能会使用像<、>（甚至<=和>=）这样的关系比较运算符。
就像==一样，如果正在进行关系比较的类型已经匹配，这些运算符将表现得像是“严格”的，但如果类型不同，它们将首先允许强制（通常是数字）。

考虑：

```
var arr = [ "1", "10", "100", "1000" ];
for (let i = 0; i < arr.length && arr[i] < 500; i++) {
    // will run 3 times
}
```

该 i<arr.length 比较是“安全的”，因为 i 和 arr.lengths 总是数字。然而，arr[i]<500 调用强制，因为 arr[i]值都是字符串。因此，这些比较变为`1<500`、`10<500`、`100<500`和`1000<500`。由于第四次迭代为假，循环在第三次迭代后停止。
这些关系运算符通常使用数字比较，除非被比较的两个值都是字符串；在这种情况下，它们使用按字母顺序（类似字典）比较字符串：

```
var x = "10";
var y = "9";

x < y;      // true, watch out!
```

除了在比较中永远不使用不匹配的类型之外，没有其他方法可以让这些关系运算符避免强制转换。这个目标可能值得称赞，但您仍然很可能会遇到类型*可能*不同的情况。

更明智的做法不是避免强制性的比较，而是接受并学习它们的来龙去脉。

强制比较在 JS 的其他地方出现，例如条件（`if`，等等），我们将在[附录 A“强制条件比较”]()中重新讨论。

## JS 中的组织方式

JS 生态系统中广泛使用两种主要的代码组织模式（数据和行为）：类和模块。这些模式并不相互排斥；许多程序可以而且确实使用这两者。其他程序将只坚持一种模式，甚至两种模式都不坚持！

在某些方面，这些模式非常不同。但有趣的是，在其他方面，它们只是同一枚硬币的不同侧面。精通 JS 需要了解这两种模式以及它们在哪里是合适的（和不适用的场景）。

### Classes

“面向对象”，“面向类”和“类”这些术语都充满了细节和细微差别；它们的定义并不通用。

我们将在这里使用一个常见且有些传统的定义，这个定义对于那些具有 C++ 和 Java 等“面向对象”语言背景的人来说最熟悉。

程序中的类是自定义数据结构“类型”的定义，其中包括数据和对数据进行操作的行为。类定义了此类数据结构的工作方式，但类本身并不是具体的值。要获取可以在程序中使用的具体值，必须使用关键字*实例化类*`new`一次或多次。

考虑：

```
class Page {
    constructor(text) {
        this.text = text;
    }

    print() {
        console.log(this.text);
    }
}

class Notebook {
    constructor() {
        this.pages = [];
    }

    addPage(text) {
        var page = new Page(text);
        this.pages.push(page);
    }

    print() {
        for (let page of this.pages) {
            page.print();
        }
    }
}

var mathNotes = new Notebook();
mathNotes.addPage("Arithmetic: + - * / ...");
mathNotes.addPage("Trigonometry: sin cos tan ...");

mathNotes.print();
// ..
```

在 Page 类中，数据是存储在 this.text 成员属性中的文本字符串。行为是`print（）`，一个将文本转储到控制台的方法。

对于 Notebook 类，数据是 Page 实例的数组。行为是`addPage（..`），一个实例化新 Page 页面并将其添加到列表的方法，以及`print（）`（打印出笔记本中的所有页面）。

语句`mathNotes=new Notebook（`）创建 Notebook 类的实例，`page=new page（text）`是创建 page 类实例的地方。
行为（方法）只能在实例（而不是类本身）上调用，例如`mathNotes.addPage（..）`和`page.print（）`
该 类机制允许将打包数据（文本和页面）与其行为（例如`addPage（..）和print（）`）组织在一起。同样的程序可以在没有任何类定义的情况下构建，但它的组织性可能要低得多，更难阅读和推理，更容易出现错误和维护不足。

#### 类继承

传统“面向类”设计固有的另一个方面是“继承”（和“多态性”），尽管在 JS 中不太常用。考虑一下：

```
class Publication {
    constructor(title,author,pubDate) {
        this.title = title;
        this.author = author;
        this.pubDate = pubDate;
    }

    print() {
        console.log(`
            Title: ${ this.title }
            By: ${ this.author }
            ${ this.pubDate }
        `);
    }
}
```

此类`Publication`定义了任何出版物可能需要的一组常见行为。

现在让我们考虑更具体的出版物类型，`Book`例如`BlogPost`：

```
class Book extends Publication {
    constructor(bookDetails) {
        super(
            bookDetails.title,
            bookDetails.author,
            bookDetails.publishedOn
        );
        this.publisher = bookDetails.publisher;
        this.ISBN = bookDetails.ISBN;
    }

    print() {
        super.print();
        console.log(`
            Publisher: ${ this.publisher }
            ISBN: ${ this.ISBN }
        `);
    }
}

class BlogPost extends Publication {
    constructor(title,author,pubDate,URL) {
        super(title,author,pubDate);
        this.URL = URL;
    }

    print() {
        super.print();
        console.log(this.URL);
    }
}
```

两者`Book`都`BlogPost`使用`extends`子句来*扩展*的一般定义`Publication`以包含其他行为。`super(..)`每个构造函数中的调用委托给父类`Publication`的构造函数进行初始化工作，然后它们根据各自的发布类型（也称为“子类”或“子类”）执行更具体的事情。

现在考虑使用这些子类：

```
var YDKJS = new Book({
    title: "You Don't Know JS",
    author: "Kyle Simpson",
    publishedOn: "June 2014",
    publisher: "O'Reilly",
    ISBN: "123456-789"
});

YDKJS.print();
// Title: You Don't Know JS
// By: Kyle Simpson
// June 2014
// Publisher: O'Reilly
// ISBN: 123456-789

var forAgainstLet = new BlogPost(
    "For and against let",
    "Kyle Simpson",
    "October 27, 2014",
    "https://davidwalsh.name/for-and-against-let"
);

forAgainstLet.print();
// Title: For and against let
// By: Kyle Simpson
// October 27, 2014
// https://davidwalsh.name/for-and-against-let
```

请注意，两个子类实例都有一个`print（）`方法，该方法是从父 Publication 类继承的`print（`）法的重写。每个被重写的子类`print（`）方法都调用`super.print（）`来调用`print（）`的继承版本。

**继承的方法和重写的方法可以具有相同的名称且共存，这种现象称为*多态性*。**

继承是一种强大的工具，用于在单独的逻辑单元（类）中组织数据/行为，但允许子类通过访问/使用其行为和数据与父类合作。

### 模块

模块模式与类模式的目标基本相同，即将数据和行为组合成逻辑单元。与类一样，模块也可以“包含”或“访问”其他模块的数据和行为，以便进行协作。

但是模块与类有一些重要的区别。最明显的是，语法完全不同。

#### 经典模块

ES6 在原生 JS 语法中添加了模块语法形式，我们稍后会介绍。但从 JS 的早期开始，模块就是一种重要且常见的模式，即使没有专门的语法，无数 JS 程序都会利用这种模式。

*经典模块*的主要特征是外部函数（至少运行一次），它返回模块的“实例”，其中公开一个或多个可对模块实例的内部（隐藏）数据进行操作的函数。

因为这种形式的模块只是*一个函数*，并且调用它会生成模块的一个“实例”，所以这些函数的另一种描述是“模块工厂”。

`Publication`考虑早期的，`Book`，和类的经典模块形式`BlogPost`：

```
function Publication(title,author,pubDate) {
    var publicAPI = {
        print() {
            console.log(`
                Title: ${ title }
                By: ${ author }
                ${ pubDate }
            `);
        }
    };

    return publicAPI;
}

function Book(bookDetails) {
    var pub = Publication(
        bookDetails.title,
        bookDetails.author,
        bookDetails.publishedOn
    );

    var publicAPI = {
        print() {
            pub.print();
            console.log(`
                Publisher: ${ bookDetails.publisher }
                ISBN: ${ bookDetails.ISBN }
            `);
        }
    };

    return publicAPI;
}

function BlogPost(title,author,pubDate,URL) {
    var pub = Publication(title,author,pubDate);

    var publicAPI = {
        print() {
            pub.print();
            console.log(URL);
        }
    };

    return publicAPI;
}
```

这些形式与`class`形式相比，相似之处多于不同之处。

**该`class`form 将方法和数据存储在对象实例上，必须使用前缀来访问`this.`。使用模块时，方法和数据作为范围内的标识符变量进行访问，无需任何`this.`前缀。**

使用`class`，实例的“API”隐含在类定义中 — 此外，所有数据和方法都是公开的。使用模块工厂函数，您可以显式创建并返回一个具有任何公开方法的对象，并且任何数据或其他未引用的方法在工厂函数内保持私有。

这种工厂函数形式还有其他变体，即使在 2020 年，它们在 JS 中也很常见；您可能会在不同的 JS 程序中遇到这些形式：AMD（异步模块定义）、UMD（通用模块定义）和 CommonJS（经典 Node.js 样式模块）。这些变化很小（不太兼容）。但是，所有这些形式都依赖于相同的基本原理。

还请考虑这些模块工厂函数的用法（又名“实例化”）：

```
var YDKJS = Book({
    title: "You Don't Know JS",
    author: "Kyle Simpson",
    publishedOn: "June 2014",
    publisher: "O'Reilly",
    ISBN: "123456-789"
});

YDKJS.print();
// Title: You Don't Know JS
// By: Kyle Simpson
// June 2014
// Publisher: O'Reilly
// ISBN: 123456-789

var forAgainstLet = BlogPost(
    "For and against let",
    "Kyle Simpson",
    "October 27, 2014",
    "https://davidwalsh.name/for-and-against-let"
);

forAgainstLet.print();
// Title: For and against let
// By: Kyle Simpson
// October 27, 2014
// https://davidwalsh.name/for-and-against-let
```

这里唯一可观察到的区别是缺少使用`new`，将模块工厂作为正常函数调用。

#### ES 模块

ES6 中引入到 JS 语言中的 ES 模块（ESM），旨在服务于与刚刚描述的现有*经典模块*相同的精神和目的，特别是考虑到 AMD、UMD 和 CommonJS 的重要变化和用例。

但实施方法却有很大不同。

首先，没有包装函数来*定义*模块。包装上下文是一个文件。**ESM 始终是基于文件的；一个文件，一个模块。**

其次，您无需显式地与模块的“API”交互，而是使用关键字`export`将变量或方法添加到其公共 API 定义中。如果某个内容在模块中定义但未添加，则它将保持隐藏状态（与*传统模块*`export`一样）。

第三，也许与之前讨论的模式最明显的区别在于，您不需要“实例化”ES 模块，只需`import`使用它的单个实例即可。ESM 实际上是“单例”，因为`import`在程序中最初只创建一个实例，而所有其他`import`实例都只接收对同一单个实例的引用。如果您的模块需要支持多个实例，则必须在 ESM 定义上为此目的提供一个*经典的模块样式工厂函数。*

在我们的运行示例中，我们确实假设了多重实例，因此以下代码片段将混合 ESM 和*经典模块*。

考虑该文件`publication.js`：

```
function printDetails(title,author,pubDate) {
    console.log(`
        Title: ${ title }
        By: ${ author }
        ${ pubDate }
    `);
}

export function create(title,author,pubDate) {
    var publicAPI = {
        print() {
            printDetails(title,author,pubDate);
        }
    };

    return publicAPI;
}
```

要导入并使用此模块，可以从另一个 ES 模块导入，例如`blogpost.js`：

```
import { create as createPub } from "publication.js";

function printDetails(pub,URL) {
    pub.print();
    console.log(URL);
}

export function create(title,author,pubDate,URL) {
    var pub = createPub(title,author,pubDate);

    var publicAPI = {
        print() {
            printDetails(pub,URL);
        }
    };

    return publicAPI;
}
```

最后，要使用这个模块，我们需要导入到另一个 ES 模块中，例如`main.js`：

```
import { create as newBlogPost } from "blogpost.js";

var forAgainstLet = newBlogPost(
    "For and against let",
    "Kyle Simpson",
    "October 27, 2014",
    "https://davidwalsh.name/for-and-against-let"
);

forAgainstLet.print();
// Title: For and against let
// By: Kyle Simpson
// October 27, 2014
// https://davidwalsh.name/for-and-against-let
```

| 笔记：                                                                                                                                                                                                           |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `as newBlogPost`语句中的 子句是`import`可选的；如果省略，则会导入刚刚命名的顶级函数`create(..)`。在本例中，我为了可读性而重命名它；它的更通用的工厂名称`create(..)`变得更能从语义上描述其用途`newBlogPost(..)`。 |

如图所示，如果 ES 模块需要支持多个实例化，则可以在内部使用经典模块。或者，我们可以从模块中公开一个类，而不是`create（..）`工厂函数，结果通常是相同的。但是，由于此时您已经在使用 ESM，我建议您继续使用经典模块而不是类。

如果您的模块只需要一个实例，您可以`export`直接跳过额外的复杂层：它的公共方法。

## 兔子洞越来越深

正如本章开头所承诺的，我们只是粗略地了解了 JS 语言的主要部分。您可能仍然感到头晕目眩，但在了解了这么多信息之后，这完全正常！

即使只是对 JS 的这个“简要”概述，我们也涵盖或暗示了大量您应该仔细考虑并确保自己感到满意的细节。我认真地建议：重读这一章，也许要读几遍。

在下一章中，我们将深入探讨 JS 核心工作原理的一些重要方面。但在你深入研究这个兔子洞之前，请确保你已经花了足够的时间来充分消化我们刚刚介绍的内容。
