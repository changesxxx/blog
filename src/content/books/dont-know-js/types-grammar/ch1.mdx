---
title: "变体"
description: "在《对象与类》系列的第一章中，我们面对了一个常见的误解：“JavaScript 中的一切都是对象”。现在我们再次回到这个话题，并再次澄清这个神话。在这里，我们将探讨 JavaScript 的核心值类型，特别是被称为原始值的非对象类型。"

name: "types-grammar-ch1"
---

### 值类型

JavaScript 不将类型应用于变量或属性 —— 我称之为 “容器类型” —— 而是值本身具有类型 —— 我称之为“值类型”。

该语言提供了七种内置的原始（非对象）[值类型](https://tc39.es/ecma262/#sec-primitive-value)：

- undefined
- null
- boolean
- number
- bigint
- symbol
- string

这些值类型定义了一组一个或多个具体值，每种类型都有一组共享的行为。

**类型检查**

任何值的值类型都可以通过 typeof 操作符进行检查，该操作符总是返回一个字符串值，表示底层的 JavaScript 值类型：
```js 
typeof true;            // "boolean"

typeof 42;              // "number"

typeof 42n;             // "bigint"

typeof Symbol("42");    // "symbol"
```
&zwj;<mark>当 typeof 操作符用于变量而不是值时，它报出的是变量中值的值类型</mark>：

```js 
greeting = "Hello";
typeof greeting;        // "string"
```

&zwj;<mark>JavaScript 变量本身没有类型。它们可以持有任何任意值，而该值本身具有值类型。</mark>

**非对象？**

使这七种原始值类型与对象值类型（及其子类型）不同的具体原因是什么？为什么我们不应该将它们视为本质上都是对象？

考虑以下情况：

```js
myName = "Kyle";

myName.nickname = "getify";

console.log(myName.nickname);           // undefined
```

这个代码片段似乎静默地未能在原始字符串上添加一个昵称属性。乍一看，这可能暗示原始值实际上在内部就是对象，因为多年来许多人（错误地）断言过这一点。

{/* todo */}
<Callout icon="⚠️" type="warning">
有人可能会将这种静默失败解释为自动装箱的示例（见第 3 章的“自动对象”），在尝试分配属性时，原始值被隐式转换为一个 String 实例包装对象，然后在语句完成后该内部对象被丢弃。实际上，我在本书的第一版中也曾这样说。但我错了，抱歉！
</Callout>


实际上，深层次的机制在起作用，如下版本的前一个代码片段所示：

```js 
"use strict";

myName = "Kyle";

myName.nickname = "getify";
// TypeError：无法创建属性 'nickname'
// 在字符串 'Kyle' 上
```

有趣的是！在严格模式下，JavaScript 强制施加了一项限制，禁止在原始值上设置新属性，仿佛将其隐式提升为一个新对象。

相比之下，在非严格模式下，JavaScript 允许这种违规行为而不予以提及。那么，为什么会这样？因为严格模式是在 ES5.1（2011 年）中添加到语言中的，而这时已经过去了 15 年，如果不定义为对新严格模式声明敏感，这样的变化会破坏现有程序。

那么我们可以得出什么结论关于原始值和对象之间的区别？<mark>原始值是不允许拥有属性的值；只有对象才被允许拥有属性。</mark>

{/* todo */}
<Callout icon="💡" type="info">
这个特定的区别似乎被诸如 "hello".length 的表达式所矛盾；即使在严格模式下，它也返回期望的值 5。因此，它似乎确实有一个 length 属性！但是，如前所述，正确的解释是自动装箱；我们将在第 3 章中讨论这个主题。
</Callout>

---

### 空值

null 和 undefined 类型通常都表示一种空或缺失的值。

不幸的是，null 值类型有一个意外的 typeof 结果。我们看到的不是“null”，而是：

```js 
typeof null;            // "object"
```

这并不意味着 null 在某种程度上是一种特殊类型的对象。这只是 JavaScript 早期阶段的遗留问题，无法更改，因为这么多现有代码会因此而中断。

undefined 类型在显式的 undefined 值和任何看似缺失的值出现的地方都被报告：

```js 
typeof undefined;               // "undefined"

var whatever;

typeof whatever;                // "undefined"
typeof nonExistent;             // "undefined"

whatever = {};
typeof whatever.missingProp;    // "undefined"

whatever = [];
typeof whatever[10];            // "undefined"
```

<Callout icon="💡" type="info">
typeof nonExistent 表达式是指一个未声明的变量 nonExistent。通常，访问一个未声明的变量引用会导致异常，但 typeof 操作符被赋予了特殊能力，可以安全地访问甚至不存在的标识符，并平静地返回“undefined”而不是抛出异常。
</Callout>

然而，每个相应的“空”类型只有一个值，名称相同。因此，<mark>null 是 null 值类型中唯一的值，而 undefined 是 undefined 值类型中唯一的值。</mark>

**空**

从语义上讲，null 和 undefined 类型都表示一般的空值或缺失的有意义值。

<Callout icon="💡" type="info">
 JavaScript 操作在遇到 null 或 undefined 时表现相同，称为“空值相关”或“空值性质”。我想“未定义相关的(undefined值)”听起来可能太奇怪了！
</Callout>


在很多 JavaScript 代码，尤其是开发者编写的代码中，这两种空值是可以互换的；在特定场景下有意使用/分配 null 或 undefined 的决定取决于情况，留给开发者。

JavaScript 提供了许多功能，帮助将这两个空值视为不可区分的。

例如，== （强制相等比较）操作符特意将 null 和 undefined 视为强制相等，但对语言中的其他值则不然。因此，如果您想检查一个值是否是 null 或 undefined，执行 .. == null 的检查是安全的：

```js 
if (greeting == null) {
    // 问候语为空值/空
}
```


另一个（最近的）JavaScript 新特性是 ??（空值合并运算符）：

```js 
who = myName ?? "User";

// 等同于:
who = (myName != null) ? myName : "User";
```

正如三元运算符所示，?? 检查 myName 是否为非空值，如果是，则返回其值。否则，它返回另一个操作数（这里是 "User"）。

除了 ??，JavaScript 还添加了 ?.（空值条件链式调用）运算符：

```js 
record = {
    shippingAddress: {
        street: "123 JS Lane",
        city: "Browserville",
        state: "XY"
    }
};

console.log( record?.shippingAddress?.street );
// 123 JS Lane

console.log( record?.billingAddress?.street );
// undefined
```

?. 运算符检查紧接其左侧的值，如果它是空值，运算符将停止并返回一个 undefined 值。否则，它对该值执行 . 属性访问，并继续执行表达式。

明确一点：record?. 表示“在进行 . 属性访问之前检查 record 是否为空”。此外，billingAddress?. 表示“在进行 . 属性访问之前检查 billingAddress 是否为空”。


<Callout icon="⚠️" type="warning">
一些 JavaScript 开发者认为，较新的 ?. 运算符优于 .，因此几乎应始终使用 ?. 而不是 .。我认为这是一个不明智的观点。首先，它增加了额外的视觉杂乱，只有在获得好处时才应该这样做。其次，您应该意识到并计划某些值的空缺，以证明使用 ?.. 是合理的。如果您总是期望某个表达式中存在非空值，则使用 ?. 来访问其属性不仅是不必要/浪费的，还可能隐藏未来的错误，即您对值存在性的假设失败，但 ?. 掩盖了这个问题。与 JavaScript 中的大多数特性一样，使用 . 在最适合的地方，使用 ?. 在最适合的地方。不要在更合适的情况下替代一个。
</Callout>




还有一种稍微奇怪的 ?.[ 运算符形式，而不是 ?[，用于当您需要使用 [ .. ] 样式访问而不是 . 访问时：

```js 
record?.["shipping" + "Address"]?.state;    // XY
```

另一种变体，称为“可选调用”，是 ?.(，用于在值非空时有条件地调用函数：

```js 
// instead of:
//   if (someFunc) someFunc(42);
//
// or:
//   someFunc && someFunc(42);

someFunc?.(42)
```

?.( 运算符似乎在检查 someFunc(..) 是否是一个有效的可以调用的函数。但其实不是！它只是检查确保该值是非空的，然后再尝试调用它。如果它是某种其他非空但也不是函数的值类型，执行尝试仍将因 TypeError 异常而失败。

<Callout icon="⚠️" type="warning">
由于这个陷阱，我非常不喜欢这种运算符形式，并警告任何人不要使用它。我认为这是一个设计不佳的特性，对 JavaScript 本身和程序造成的损害超过了好处。我很少会说“永远不要使用”某个 JavaScript 特性，但这是我认为的真正糟糕的语言部分之一。
</Callout>



**不同的类型**

需要注意的是，null 和 undefined 实际上是不同的类型，因此 null 可以与 undefined 明显不同。您可以小心翼翼地构建程序，使它们在大多数情况下被视为不可区分。但这需要开发者的谨慎和纪律。从 JavaScript 的角度来看，它们往往是不同的。

在语言的某些情况下，null 和 undefined 会触发不同的行为，这一点非常重要。我们在这里不会详尽地覆盖所有情况，但给您一个例子：

```js 
function greet(msg = "Hello") {
    console.log(msg);
}

greet();            // Hello
greet(undefined);   // Hello
greet("Hi");        // Hi

greet(null);        // null
```

参数上的 = .. 子句被称为“参数默认值”。只有在该位置的参数缺失或其值恰好为 undefined 时，它才会生效并将默认值赋给参数。如果您传递 null，则该子句不会触发，null 因此被赋值给参数。

在程序中使用 null 或 undefined 没有对错之分。因此，结论是：在选择一个值或另一个值时要小心。如果您将它们互换使用，则要格外小心。

---

### 布尔值

布尔类型包含两个值：false 和 true。

在“旧时代”，编程语言通常使用 0 表示 false，使用 1 表示 true。因此，您可以将布尔类型以及关键字 false 和 true 视为在 0 和 1 值之上的语义便利糖：

```js 
// isLoggedIn = 1;
isLoggedIn = true;

isComplete = 0;
// isComplete = false;
```

布尔值是所有 JavaScript 程序中决策的基础：

```js 
if (isLoggedIn) {
    // do something
}

while (!isComplete) {
    // keep going
}
```

! 运算符将布尔值取反/翻转为另一个值：false 变为 true，true 变为 false。

---

### 字符串值

字符串类型包含任何一个或多个字符的集合，由引号字符在两侧限定：

```js 
myName = "Kyle";
```

JavaScript 不像某些语言那样区分单个字符；"a" 和 "abc" 是同一种字符串。

字符串可以用双引号（"）、单引号（'）或反引号（`）来限定。结束定界符必须始终与起始定界符匹配。

字符串具有内在的长度，对应于它们包含的代码点数量——实际上是代码单元，稍后会详细介绍。

```js 
myName = "Kyle";

myName.length;      // 4
```

这不一定与在开始和结束定界符之间的可见字符数量（即字符串字面量）对应。有时，弄清楚字符串字面量与底层字符串值之间的区别可能会有点困惑，因此请注意。

<Callout icon="💡" type="info">
我们将在第二章详细讨论字符串长度的计算。
</Callout>

&zwj;<mark>个人建议:以下内容建议跳过,跳转至本章节最后一项:模板字面量。</mark>

**JavaScript 字符编码**

JavaScript 使用什么类型的字符编码来表示字符串字符？

您可能听说过“Unicode”，甚至可能听说过“UTF-8”（8 位）或“UTF-16”（16 位）。如果您像我一样（在进行写这段文本所需的研究之前），您可能只是随便提及一下，认为这就是您需要知道的所有字符编码信息。

但是……这远远不够。

事实证明，您需要理解 Unicode 的各种方面，甚至需要考虑来自 UCS-2（2 字节通用字符集）的概念，这与 UTF-16 类似，但并不完全相同。

Unicode 定义了我们可以在计算机程序中普遍表示的所有“字符”，通过为每个字符分配一个特定的数字，称为代码点。这些数字范围从 0 到最大值 1114111（十六进制 10FFFF）。

Unicode 字符的标准表示法是 U+ 后跟 4-6 个十六进制字符。例如，❤（心形符号）的代码点是 10084（十六进制 2764），因此记作 U+2764。

Unicode 中的前 65,535 个代码点被称为 BMP（基本多语言平面）。这些可以用 16 位（2 字节）表示。当表示来自 BMP 的 Unicode 字符时，相对简单，因为它们可以整齐地适配为单个 UTF-16 JavaScript 字符。

其余代码点被分为 16 个所谓的“补充平面”或“星体平面”。这些代码点需要超过 16 位来表示——确切地说是 21 位——因此在表示 BMP 以上的扩展/补充字符时，JavaScript 实际上将这些代码点存储为两个相邻的 16 位代码单元的配对，称为替代半部（或替代对）。

例如，Unicode 代码点 127878（十六进制 1F386）是 🎆（烟花符号）。JavaScript 将其存储为两个替代半部代码单元：U+D83C 和 U+DF86。请记住，这两个部分的整体字符不能单独存在；它们只有在紧靠彼此的情况下才有效/有意义。

这对字符串的长度有影响，因为像 🎆 这样的单个可见字符在 JavaScript 字符串中被计为 2 个字符，计算字符串长度时会如此！

我们稍后会重新审视 Unicode 字符，然后在第二章中讨论计算字符串长度的挑战。

**转义序列**

如果 " 或 ' 用于限定字符串字面量，则内容仅解析字符转义序列：\ 后跟一个或多个 JavaScript 识别并解析具有特殊含义的字符。字符串中的任何其他字符，如果无法解析为转义序列（单字符或多字符），则按原样插入到字符串值中。

对于单字符转义序列，以下字符在 \ 后被识别：b，f，n，r，t，v，0，'，" 和 \。例如，\n 意味着换行，\t 意味着制表符，等等。

如果 \ 后跟任何其他字符（除非是 x 和 u——稍后将解释），比如 \k，该序列被解释为 \ 是不必要的转义，因此被删除，只留下字面字符本身（k）。

要在双引号限定的字符串字面量中包含 "，请使用 " 转义序列。类似地，如果您要在单引号限定的字符串字面量中包含 ' 字符，请使用 ' 转义序列。相反，' 在双引号限定字符串中不需要转义，反之亦然。

```js 
myTitle = "Kyle Simpson (aka, \"getify\"), former O'Reilly author";

console.log(myTitle);
// Kyle Simpson (aka, "getify"), former O'Reilly author
```

在文本中，正斜杠 `/` 是最常见的。但有时，您需要一个反斜杠 `\`。要在字符串中包含一个字面量的 `\` 反斜杠字符，而不让它作为字符转义序列的起始符号，请使用 `\\`（双反斜杠）。

那么，字符串中的 `\\\`（三个反斜杠）将如何解析呢？前两个 `\` 会形成一个 `\\` 转义序列，从而在字符串值中插入一个单独的 `\` 字符，剩下的 `\` 将转义后面紧跟的字符。

反斜杠常见的一个地方是 Windows 文件路径，它们使用 `\` 分隔符，而不是在 Linux/Unix 风格路径中使用的 `/` 分隔符：

```js 
windowsFontsPath =
    "C:\\Windows\\Fonts\\";

console.log(windowsFontsPath);
// C:\Windows\Fonts\"
```


<Callout icon="💡" type="info">
字符串字面量中的四个反斜杠 `\\\\` 呢？这只是两个 `\\`转义序列相邻，因此在底层字符串值中结果为两个相邻的反斜杠（`\\`）。您可能会发现这里存在奇偶规则的模式。因此，您应该能够解析字符串字面量中任意奇数（`\\\\\`, `\\\\\\\\\`, 等）或偶数（`\\\\\\`，`\\\\\\\\\\`，等）个反斜杠。
</Callout>

**行续**

`\` 字符后面跟着一个实际的新行字符（而不仅仅是字面量的 n）是一个特殊情况，它创建了所谓的行续：

```js 
greeting = "Hello \
Friends!";

console.log(greeting);
// Hello Friends!
```

正如您所见，问候 = 行末尾的换行符前面紧接着一个 `\`，这允许这个字符串字面量继续到下一行。如果没有其前面的转义 `\`，在一个 " 或 ' 限定的字符串字面量中出现的新行——实际的新行，而不是 `\n` 字符转义序列——将会导致 JavaScript 语法解析错误。

由于行末的 `\` 将新行字符变为行续，因此新行字符被省略在字符串中，如 `console.log(..)` 输出所示。

<Callout icon="💡" type="info">
这种行续特性通常被称为“多行字符串”，但我认为这是一个令人困惑的标签。正如您所见，字符串值本身并没有多行，它只是通过行续在多行中定义。实际上，多行字符串应当在底层值中具有多行。我们将在本章稍后讨论模板字面量时重新审视这一主题。
</Callout>

**多字符转义**

多字符转义序列可以是十六进制或 Unicode 序列。

十六进制转义序列用于编码任何基本 ASCII 字符（代码 0-255），其形式为 `\x` 后面跟着正好两个十六进制字符（0-9 和 a-f / A-F——不区分大小写）。例如，A9 或 a9 是十进制值 169，对应于：

```js 
copyright = "\xA9";  // or "\xa9"

console.log(copyright);     // ©
```

对于任何可以在键盘上输入的普通字符，例如 "a"，通常最可读的方式是直接指定字面字符，而不是更模糊的十六进制表示：

```js 
"a" === "\x61";             // true
```

字符串中的 Unicode
Unicode 转义序列可以单独编码 Unicode BMP 中的任何字符。它们的形式为 `\u` 后面跟着正好四个十六进制字符。

例如，转义序列 `\u00A9`（或 `\u00a9`）对应于相同的 © 符号，而 `\u263A`（或 `\u263a`）对应于代码点 9786 的 Unicode 字符：☺（笑脸符号）。

当识别到任何字符转义序列（无论长度）时，所表示的单个字符会被插入到字符串中，而不是原来的分离字符。因此，在字符串 "\u263A" 中，只有一个（笑脸）字符，而不是六个单独的字符。

但如前所述，许多 Unicode 代码点远高于 65535。例如，`1F4A9`（或 `1f4a9`）是十进制代码点 128169，对应于有趣的 💩（屎）的符号。

但是，`\u1F4A9` 并不能在字符串中包含这个字符，因为它会被解析为 Unicode 转义序列 \u1F4A，后面跟一个字面量的 9 字符。为了解决这个限制，引入了一种变体的 Unicode 转义序列，允许在 \u 后面跟任意数量的十六进制字符，方法是用 `{ .. }` 大括号将它们括起来：

```js 
myReaction = "\u{1F4A9}";

console.log(myReaction);
// 💩
```

回顾一下之前讨论的扩展（非 BMP）Unicode 字符和替代半部？同样的 💩 也可以用两个显式代码单元定义，形成一个替代对：

```js 
myReaction = "\uD83D\uDCA9";

console.log(myReaction);
// 💩
```

这三种表示法在内部由 JavaScript 相同地存储，无法区分：

```js 
"💩" === "\u{1F4A9}";                // true
"\u{1F4A9}" === "\uD83D\uDCA9";     // true
```

尽管 JavaScript 不在乎您在程序中以何种方式表示这种字符，但在编写代码时，请仔细考虑可读性差异。

<Callout icon="💡" type="info">
尽管 💩 看起来是一个单一字符，但它的内部表示会影响字符串中包含该字符时的长度计算。我们将在第二章中讨论字符串长度的计算。
</Callout>

**Unicode 归一化**

Unicode 字符串处理中的另一个细节是，即使某些单一的 BMP 字符也可以以不同方式表示。

例如，字符 "é" 可以表示为自身（代码点 233，即 `\xe9`或 `\u00e9` 或 `\u{e9}`），也可以表示为两个代码点的组合：“e” 字符（代码点 101，即 `\x65`，`\u0065`，`\u{65}`）和组合的波浪符（代码点 769，即 `\u0301`，`\u{301}`）。

考虑：

```js 
eTilde1 = "é";
eTilde2 = "\u00e9";
eTilde3 = "\u0065\u0301";

console.log(eTilde1);       // é
console.log(eTilde2);       // é
console.log(eTilde3);       // é
```

在这个代码片段中，赋值给 eTilde3 的字符串字面量将重音符号作为一个单独的组合符号存储。像替代对一样，组合符号只有在与其相邻的符号（通常是在后面）结合时才有意义。

Unicode 符号的渲染应该是相同的，但 "é" 字符的内部存储方式会影响包含字符串的长度计算，以及相等性和关系比较（关于这些内容将在第二章中详细讨论）：

```js 
eTilde1.length;             // 2
eTilde2.length;             // 1
eTilde3.length;             // 2

eTilde1 === eTilde2;        // false
eTilde1 === eTilde3;        // true
```

一个特别的挑战是，您可能会复制粘贴一个包含 "é" 字符的字符串，而您复制的字符可能是以组合形式或分解形式存在的。但没有视觉方式可以判断这一点，然而字面量中的底层字符串值将是不同的：

```js 
"é" === "é";           // false!!
```

这种内部表示差异如果没有仔细规划可能会非常棘手。幸运的是，JavaScript 提供了一个 normalize(..) 工具方法来帮助处理：

```js 
eTilde1 = "é";
eTilde2 = "\u{e9}";
eTilde3 = "\u{65}\u{301}";

eTilde1.normalize("NFC") === eTilde2;
eTilde2.normalize("NFD") === eTilde3;
```

"NFC" 归一化模式将相邻的代码点组合成组合代码点（如果可能），而 "NFD" 归一化模式则将单个代码点拆分成其分解的代码点（如果可能）。

实际上，组成单个组合代码点的分解代码点可以超过两个——例如，单个字符可以应用多个变音符号。

在处理将被比较、排序或长度分析的 Unicode 字符串时，务必牢记 Unicode 归一化，并在必要时使用它。

**Unicode 字形簇**

Unicode 字符串处理的最后一个复杂性是支持将多个相邻代码点聚集到一个单独的视觉符号中，称为字形（或字形簇）。

例如，家庭表情符号 "👩‍👩‍👦‍👦" 实际上由 7 个代码点组成，这些代码点都聚集在一起形成一个单一的视觉符号。

考虑：

```js 
familyEmoji = "\u{1f469}\u{200d}\u{1f469}\u{200d}\u{1f466}\u{200d}\u{1f466}";

familyEmoji;            // 👩‍👩‍👦‍👦
```

这个表情符号不是一个单一的注册 Unicode 代码点，因此无法对这 7 个独立的代码点进行归一化以组合成一个实体。对于这种复合符号的视觉渲染逻辑相当复杂，远远超出大多数 JavaScript 开发者希望在程序中嵌入的内容。确实存在一些库来处理部分逻辑，但它们通常很庞大，并且不一定涵盖所有细微差别/变体。

与替代对和组合符号不同，字形簇中的符号实际上可以作为独立字符，但在彼此相邻时具有特殊的组合行为。

这种复杂性显著影响长度计算、比较、排序及许多其他常见的字符串操作。

**模板字面量** 

我之前提到，字符串可以用 .. 反引号来限定：

```js
myName = `Kyle`;
```

所有字符编码、字符转义序列和长度的相同规则适用于这些类型的字符串。

然而，这些模板（字符串）字面量的内容还会解析一个特殊的定界符序列 `${ .. }`，该序列标记一个表达式，以便在该位置评估并插入到字符串值中：

```js 
myName = `Kyle`;

greeting = `Hello, ${myName}!`;

console.log(greeting);      // Hello, Kyle!
```

在这样的模板字面量中，`{ .. }` 之间的所有内容都是任意的 JavaScript 表达式。它可以是简单的变量，如 myName，也可以是复杂的 JavaScript 程序，或介于两者之间的任何内容（甚至是另一个模板字面量表达式！）。


<Callout icon="💡" type="info">
这个特性通常被称为“模板字面量”或“模板字符串”，但我认为这很令人困惑。“模板”在编程上下文中通常意味着一组可重用的文本，可以用不同的数据重新评估。例如，页面的模板、新闻邮件活动的电子邮件模板等。这个 JavaScript 特性并不可重用。它是一个字面量，并生成一个单一的、即时的值（通常是字符串）。您可以将这样的值放入一个函数中，并多次调用该函数。但在这种情况下，函数作为模板，而不是字面量本身。我更喜欢将这个特性称为插值字面量，或者用一个有趣的简写：interpoliterals。我认为这个名称更准确地描述了它。
</Callout>

模板字面量在处理换行方面与经典的 " 或 ' 限定字符串有趣的不同。回想一下，对于那些字符串，行续需要在每行的末尾放置一个 \，紧接着一个换行符。而在模板字面量中则不是这样！

```js 
myPoem = `
Roses are red
Violets are blue
C3PO's a funny robot
and so R2.`;

console.log(myPoem);
//
// Roses are red
// Violets are blue
// C3PO's a funny robot
// and so R2.
```

模板字面量中的行续不需要转义。然而，这意味着换行符是字符串的一部分，甚至是上面第一个换行符。换句话说，上面的 myPoem 保存了一个真正的多行字符串，如所示。然而，如果您在模板字面量中的任何行末尾使用 \ 进行转义，换行符将被省略，就像在非模板字面量字符串中一样。

模板字面量通常会返回一个字符串值，但并非总是如此。一种看起来有些奇怪的模板字面量形式称为标记模板字面量：

```js 
price = formatCurrency`The cost is: ${totalCost}`;
```

这里，formatCurrency 是应用于模板字面量值的标签，它实际上调用 formatCurrency(..) 作为函数，传递从值中解析的字符串字面量和插值表达式。这个函数可以以任何方式组合这些内容——例如，将数字值格式化为当前区域的货币——并返回它想要的任何值，无论是字符串还是其他类型。

因此，标记模板字面量并不总是字符串；它们可以是任何值。但未标记的模板字面量将始终是字符串。

一些 JavaScript 开发者认为未标记的模板字面量字符串是所有字符串的最佳选择，即使不使用插值或多行。我不同意。我认为它们只应在进行插值（或多行）时使用。

<Callout icon="💡" type="info">
我在做出此类决定时始终遵循的原则是：为任何任务使用最接近且功能最少的特性/工具。
</Callout>


此外，有一些地方不允许使用 .. 风格的字符串。例如，“use strict” 语句不能使用反引号，否则该语句将被静默忽略（因此程序意外地在非严格模式下运行）。此外，这种字符串类型不能用于对象字面量的引号属性名称、解构模式或 ES 模块的 import .. from .. 模块说明子句。

我的看法是：在允许的地方使用 .. 限定的字符串，但仅在需要插值/多行时使用；对于其他所有内容继续使用 ".." 或 '..' 限定的字符串。

---

### 数值

数字类型包含任何数值（整数或小数），例如 -42 或 3.1415926。这些值由 JS 引擎以[ 64 位 IEEE-754 双精度二进制浮点值](https://en.wikipedia.org/wiki/IEEE_754)的形式表示。

JavaScript 中的数字始终是小数；整数（即“整型”）并不是以不同/特殊的方式存储。存储为数字值的“整数”仅仅是其小数部分没有非零值；因此，42 在 JS 中与 42.0 和 42.000000 是不可区分的。

我们可以使用 Number.isInteger(..) 来确定一个数字值是否有任何非零的小数部分：

```js 
Number.isInteger(42);           // true
Number.isInteger(42.0);         // true
Number.isInteger(42.000000);    // true

Number.isInteger(42.0000001);   // false

```

**解析与强制转换**

如果一个字符串值包含看起来像数字的内容，您可能需要将该字符串值转换为数字，以进行数学操作。

然而，区分解析转换和强制转换非常重要。

我们可以使用 JS 内置的 parseInt(..) 或 parseFloat(..) 工具进行解析转换：

```js 
someNumericText = "123.456";

parseInt(someNumericText,10);               // 123
parseFloat(someNumericText);                // 123.456

parseInt("42",10) === parseFloat("42");     // true

parseInt("512px");                          // 512
```

<Callout icon="💡" type="info">
解析仅与字符串值相关，因为它是逐字符（从左到右）操作。解析布尔值的内容没有意义，也无法解析数字或 null 的内容；因为没有内容可供解析。如果您将任何非字符串值传递给 parseInt(..) / parseFloat(..)，这些工具首先会将该值转换为字符串，然后尝试解析它。这几乎肯定会导致问题（导致错误）或浪费——parseInt(42) 是愚蠢的，parseInt(42.3) 是滥用 parseInt(..) 来完成 Math.floor(..) 的工作。
</Callout>


解析会从字符串值中提取出看起来像数字的字符，并将它们放入数字值中，一旦遇到非数字字符（例如，非 -、. 或 0-9 的字符）就会停止。如果在第一个字符处解析失败，这两个工具都会返回特殊的 NaN 值（见“无效数字”部分），表示操作无效并失败。

当 parseInt(..) 遇到 "123.456" 中的 . 时，它会停止，仅使用 123 来生成结果数字值。相反，parseFloat(..) 会接受这个 . 字符，并继续解析后面的任何小数位。

parseInt(..) 工具特别地接受一个可选的——但实际上相当必要的——第二个参数，基数：用于解释字符串字符的数字基数（范围 2 - 36）。10 是用于标准的十进制数字，2 是二进制，8 是八进制，16 是十六进制。任何其他不寻常的基数，如 23，假定数字顺序为 0 - 9，后跟 a - z（不区分大小写）字符顺序。如果指定的基数超出 2 - 36 范围，parseInt(..) 会因无效而失败并返回 NaN 值。

如果基数被省略，parseInt(..) 的行为相当微妙且令人困惑，因为它会根据第一个字符的内容尝试进行最佳猜测。这在历史上导致了许多微妙的错误，因此不要依赖默认的自动猜测；始终明确指定基数（如上面的 10）。

parseFloat(..) 始终以基数 10 进行解析，因此不接受第二个参数。


<Callout icon="⚠️" type="warning">
parseInt(..) 和 parseFloat(..) 之间有一个惊人的区别，即 parseInt(..) 不会完全解析科学记数法（例如 "1.23e+5"），而是在 . 处停止，因为它对整数无效；实际上，"1e+5" 在 "e" 处也会停止。相反，parseFloat(..) 会按照预期完全解析科学记数法。
</Callout>

与解析转换相对，强制转换是一种全或无的操作。字符串的全部内容要么被识别为数字（整数或浮点数），要么整个转换失败（结果为 NaN——再次见“无效数字”部分）。

强制转换可以通过 Number(..) 函数（不带 new 关键字）或在值前加一元 + 运算符显式完成。

```js 
someNumericText = "123.456";

Number(someNumericText);        // 123.456
+someNumericText;               // 123.456

Number("512px");                // NaN
+"512px";                       // NaN
```

**其他数字表示法**

除了使用传统的十进制数字（0-9）定义数字外，JavaScript 还支持在三种其他基数中定义仅为整数的数字字面量：二进制（基数-2）、八进制（基数-8）和十六进制（基数-16）。

```js 
// binary
myAge = 0b101010;
myAge;              // 42

// octal
myAge = 0o52;
myAge;              // 42

// hexadecimal
myAge = 0x2a;
myAge;              // 42
```

如您所见，前缀 0b（表示二进制）、0o（表示八进制）和 0x（表示十六进制）标识了不同基数的数字定义，但这些数字字面量中不允许使用小数。

<Callout icon="💡" type="info">
JavaScript 语法也允许 0B、0O 和 0X 前缀。但请勿使用这些大写前缀形式。我认为任何理智的人都会同意：0O 在一眼看去时更容易与 0o 混淆（后者在一眼看去时本身也有点视觉模糊）。始终坚持使用小写前缀形式！
</Callout>

重要的是要意识到，您并不是在定义一个不同的数字，而只是使用不同的形式来产生相同的底层数值。

默认情况下，JavaScript 以标准的十进制形式在输出/字符串中表示底层数值。然而，数字值有一个内置的 toString(..) 方法，可以以任何指定的基数/基数产生字符串表示（与 parseInt(..) 一样，范围为 2 - 36）：

```js 
myAge = 42;

myAge.toString(2);          // "101010"
myAge.toString(8);          // "52"
myAge.toString(16);         // "2a"
myAge.toString(23);         // "1j"
myAge.toString(36);         // "16"
```

您可以使用 parseInt(..) 将任何任意基数的字符串表示转换回数字，使用适当的基数：

```js 
myAge = 42;

parseInt(myAge.toString("23"),23);      // 42
```


另一种允许的数字字面量形式是使用科学记数法：

```js 
myAge = 4.2E1;      // or 4.2e1 or 4.2e+1

myAge;              // 42
```


4.2E1（或 4.2e1）表示 4.2 * (10 ** 1)（10 的 1 次方）。指数可以选择性地带有符号 + 或 -。如果省略符号，则假定为 +。负指数使数字变小（小数点向左移动），而不是变大（小数点向右移动）：

这种科学记数法形式在指定更大幂的 10 时特别有用：

```js 
someBigPowerOf10 = 1000000000;

// vs:

someBigPowerOf10 = 1e9;
```

默认情况下，JavaScript 将表示（例如，作为字符串值等）非常大或非常小的数字——具体来说，如果值需要超过 21 位的精度——使用这种相同的科学记数法：

```js 
ratherBigNumber = 123 ** 11;
ratherBigNumber.toString();     // "9.748913698143826e+22"

prettySmallNumber = 123 ** -11;
prettySmallNumber.toString();   // "1.0257553107587752e-23"
```

绝对值小于这些阈值的数字（接近 0）仍然可以强制转换为科学记数法形式（作为字符串）：

```js 
plainBoringNumber = 42;

plainBoringNumber.toExponential();      // "4.2e+1"
plainBoringNumber.toExponential(0);     // "4e+1"
plainBoringNumber.toExponential(4);     // "4.2000e+1"
```

toExponential(..) 的可选参数指定字符串表示中要包含的小数位数。

在代码中指定数字字面量的另一个可读性便利是能够在任何方便/有意义的地方插入 _ 作为数字分隔符。例如：

```js 
someBigPowerOf10 = 1_000_000_000;

totalCostInPennies = 123_45;  // vs 12_345
```

决定使用 12345（无分隔符）、12_345（类似于 "12,345"）或 123_45（类似于 "123.45"）完全取决于代码的作者；JavaScript 会忽略这些分隔符。但根据上下文，123_45 在语义上可能比更传统的从右侧开始每三位数字用逗号分隔的样式（如 12_345）更具可读性。

**IEEE-754位域二进制表示法**

[IEEE-754](https://en.wikipedia.org/wiki/IEEE_754) 是一种用于十进制数字的二进制表示的技术标准。它被大多数计算机编程语言广泛使用，包括 JS、Python、Ruby 等。

我不会详尽地介绍它，但我认为对像 JS 这样的语言中数字如何工作的简要介绍是非常必要的，因为很少有程序员对此有任何了解。

在 64 位 IEEE-754 中——所谓的“双精度”，因为最初 IEEE-754 是 32 位，现在是其两倍！——这 64 位被分为三个部分：52 位用于数字的基值（也称为“分数”、“尾数”或“有效数字”），11 位用于提升 2 的指数，然后进行乘法，1 位用于最终值的符号。

<Callout icon="💡" type="info">
由于 64 位中只有 52 位实际上用于表示基值，因此数字实际上并没有 2^64 的值。根据数字类型的规范，值的数量准确为 2^64 - 2^53 + 3，约为 18 夸脱，与正数和负数大致均匀分布。
</Callout>


这些位从左到右排列，如下所示（S = 符号位，E = 指数位，M = 尾数位）：

```js 
SEEEEEEEEEEEMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
```

因此，数字 42（或 42.000000）将由这些位表示：

```js 
// 42:
01000000010001010000000000000000
00000000000000000000000000000000

```

符号位为 0，表示数字为正（1 表示负）。

11 位的指数是二进制 10000000100，转换为十进制是 1028。但在 IEEE-754 中，这个值被解释为存储为无符号的，并带有“指数偏差”1023，这意味着我们将指数范围从 -1022:1023 上移到 1:2046（其中 0 和 2047 被保留用于特殊表示）。因此，将 1028 减去偏差 1023，得到有效指数 5。我们将 2 提升到该值（2^5），得到 32。

<Callout icon="💡" type="info">
如果从指数值中减去 1023 得到负数（例如 -3），这仍然被解释为 2 的指数；将 2 提升到负数只会产生越来越小的值。

</Callout>


剩下的 52 位给我们基值 01010000...，解释为二进制小数 1.0101000...（带有所有后续的零）。将其转换为十进制，我们得到 1.3125000.... 最后，将其乘以已经从指数计算得出的 32。结果是 42。

正如您现在可能能够看出的，这种 IEEE-754 数字表示标准被称为“浮点”，因为小数点“浮动”在位之间，取决于指定的指数值。

数字 42.0000001，仅与 42.000000 相差 0.0000001，将由这些位表示：

```js 
// 42.0000001:
01000000010001010000000000000000
00000000110101101011111110010101
```

注意到先前的位模式与这个模式在尾部位置有许多差异！包含所有额外 1 位的二进制小数分数（1.010100000000...01011111110010101）转换为十进制为 1.31250000312500003652，乘以 32 得到的正是 42.0000001。

我们将在第二章中重新审视浮点（不）精确度的更多细节。但现在您了解了一些关于 IEEE-754 如何工作的知识！

**数字限制**

正如您现在所看到的，IEEE-754 的工作原理，数字基值的 52 位必须共享，表示所需数字值的整数部分（如果有）以及小数部分（如果有）。本质上，所需表示的整数部分越大，可用于小数部分的位数就越少，反之亦然。

可以准确存储在数字类型中的最大值被称为 Number.MAX_VALUE：

```js 
Number.MAX_VALUE;           // 1.7976931348623157e+308
```

您可能希望该值是小数值，考虑到表示。但是仔细检查，1.79E308（约为）是 2^1024 - 1。这似乎更像是一个整数，对吧？我们可以验证：

```js 
Number.isInteger(Number.MAX_VALUE);         // true
```

但是，如果超过最大值会发生什么？

```js 
Number.MAX_VALUE === (Number.MAX_VALUE + 1);
// true -- oops!

Number.MAX_VALUE === (Number.MAX_VALUE + 10000000);
// true
```

那么，Number.MAX_VALUE 实际上是 JS 中可表示的最大值吗？它确实是最大的有限数值。

IEEE-754 定义了一个特殊的无限值，JS 将其表示为 Infinity；在数字线的另一端还有 -Infinity。可以测试值以查看它们是有限的还是无限的：

```js 
Number.isFinite(Number.MAX_VALUE);  // true

Number.isFinite(Infinity);          // false
Number.isFinite(-Infinity);         // false
```

您永远无法从 Number.MAX_VALUE 向上计数（+1）到 Infinity，无论您让程序运行多长时间，因为 +1 操作实际上并没有超出顶部的 Number.MAX_VALUE 值。

然而，JS 的算术操作（+、*，甚至 /）确实可以在顶端溢出数字类型，在这种情况下，结果为 Infinity：

```js 
Number.MAX_VALUE + 1E291;           // 1.7976931348623157e+308
Number.MAX_VALUE + 1E292;           // Infinity

Number.MAX_VALUE * 1.0000000001;    // Infinity

1 / 1E-308;                         // 1e+308
1 / 1E-309;                         // Infinity
```

<Callout icon="💡" type="info">
反之则不成立：对无限值的算术操作永远不会产生有限值。

</Callout>

从非常大到非常小——实际上，更接近于零，这与非常负的情况不同！——您理论上可以存储在数字类型中的最小绝对小数值将是 2^-1022（记住 IEEE-754 的指数范围？），或约 2E-308。然而，JS 引擎根据规范允许在其内部表示中有所不同。无论引擎的有效下限是什么，它将被表示为 Number.MIN_VALUE：

```js 
Number.MIN_VALUE;               // 5e-324 <-- usually!
```

大多数 JS 引擎似乎有一个可表示的最小值在 5E-324（约 2^-1074）左右。根据引擎和/或平台的不同，可能会暴露出不同的值。请小心任何依赖于这些实现相关值的程序逻辑。

**安全整数限制**

由于 Number.MAX_VALUE 是一个整数，您可能会认为它是语言中最大的整数。但这并不完全准确。

您可以准确存储在数字类型中的最大整数是 2^53 - 1，或 9007199254740991，这比 Number.MAX_VALUE（约 2^1024 - 1）要小得多。这个特殊的安全值被称为 Number.MAX_SAFE_INTEGER：

```js 
maxInt = Number.MAX_SAFE_INTEGER;

maxInt;             // 9007199254740991

maxInt + 1;         // 9007199254740992

maxInt + 2;         // 9007199254740992
```

我们已经看到大于 9007199254740991 的整数可以出现。然而，这些更大的整数不是“安全的”，因为在与它们进行操作时精度/准确性开始下降。如上所示，maxInt + 1 和 maxInt + 2 表达式都错误地给出了相同的结果，说明了超过 Number.MAX_SAFE_INTEGER 限制时的危险。

那么，最小的安全整数是多少？

根据您对“最小”的解释，您可以回答 0 或者... Number.MIN_SAFE_INTEGER：

```js 
Number.MIN_SAFE_INTEGER;    // -9007199254740991
```

JS 提供了一个工具来确定一个值是否在这个安全范围内（-2^53 + 1 到 -2^53 - 1）。

```js 
Number.isSafeInteger(2 ** 53);      // false
Number.isSafeInteger(2 ** 53 - 1);  // true
```

**双零**

您可能会惊讶地发现，JS 有两个零：0 和 -0（负零）。但是“负零”究竟是什么？数学家一定会对这种概念感到震惊。

这不仅仅是一个有趣的 JS 特性；它是 IEEE-754 规范所规定的。所有浮点数都是有符号的，包括零。尽管 JS 确实在某种程度上隐藏了 -0 的存在，但完全有可能产生它并检测到它：

```js 

function isNegZero(v) {
    return v == 0 && (1 / v) == -Infinity;
}

regZero = 0 / 1;
negZero = 0 / -1;

regZero === negZero;        // true -- oops!
Object.is(-0,regZero);      // false -- phew!
Object.is(-0,negZero);      // true

isNegZero(regZero);         // false
isNegZero(negZero);         // true

```

您可能会想，为什么我们需要 -0 这样的东西。当使用数字表示某个物体（如游戏角色或动画）的移动幅度（速度）和方向时，这可能是有用的（例如，负数 = 左，正数 = 右）。

如果没有带符号的零值，您就无法判断该物体在静止时所指的方向。


<Callout icon="💡" type="info">
虽然 JS 在数字类型中定义了带符号的零，但在 bigint 数字类型中没有相应的带符号零。因此，-0n 仅被解释为 0n，这两者是不可区分的。
</Callout>

**无效数字**

数学运算有时会产生无效结果。例如：

```js 
42 / "Kyle";            // NaN
```

这可能显而易见，但如果您尝试将一个数字除以一个字符串，那就是一种无效的数学操作。

另一种无效的数字操作是尝试将一个非数字的类数字值强制转换为数字。如前所述，我们可以通过 Number(..) 函数或一元 + 运算符来进行转换：
```js 
myAge = Number("just a number");

myAge;                  // NaN

+undefined;             // NaN
```

所有这些无效操作（无论是数学的还是强制/数字的）都会产生一个特殊的数字值，即 NaN。


“NaN” 的历史根源（来自 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754) 规范）是“Not a Number”的缩写。从技术上讲，在 64 位 IEEE-754 数字空间中，有大约 9 夸脱的值被指定为“NaN”，但 JS 将它们视为单一的 NaN 值。

不幸的是，这种“不是一个数字”的含义会造成混淆，因为 NaN 绝对是一个数字。

提示：

为什么 NaN 是一个数字？想象一下相反的情况：如果数学/数字操作（如 + 或 /）产生一个非数字值（如 null、undefined 等）会怎样？这会不会显得非常奇怪和意外？如果它们抛出异常，您需要在所有数学操作中使用 try..catch，这样的情况就显得不合理。唯一合理的行为是，数字/数学操作应始终产生一个数字，即使该值是无效的，因为它来自于无效的操作。

为了避免这种混淆，我更倾向于将“NaN”定义为以下任意一种：

- “无效数字”
- “不是真正的数字”
- “不可用数字”
- “不适用数字”

NaN 是 JS 中一个特殊的值，因为它是语言中唯一一个缺乏身份属性的值——它永远不等于自身。

```js 
NaN === NaN;            // false
```

因此，不幸的是，=== 操作符无法检查一个值是否为 NaN。但是有一些方法可以做到这一点：

```js 

politicianIQ = "nothing" / Infinity;

Number.isNaN(politicianIQ);         // true

Object.is(NaN,politicianIQ);        // true
[ NaN ].includes(politicianIQ);     // true

```

这是几乎所有 JS 程序的一个事实，无论您是否意识到：NaN 时常出现。认真地说，几乎所有进行数学或数字转换的程序都可能会遇到 NaN。

如果您在进行数学或数字转换的程序中没有正确检查 NaN，我可以相当肯定地说：您的程序中可能存在数字错误，只是还没有影响到您（您尚未察觉到而已）！


<Callout icon="⚠️" type="warning">
JS 最初提供了一个名为 isNaN(..) 的全局函数用于检查 NaN，但不幸的是，这个函数有一个长期存在的强制转换错误。isNaN("Kyle") 返回 true，尽管字符串值 "Kyle" 显然不是 NaN 值。这是因为全局的 isNaN(..) 函数强制任何非数字参数先转换为数字，然后再检查是否为 NaN。将 "Kyle" 强制转换为数字会得到 NaN，因此该函数看到 NaN 后返回 true！这个有缺陷的全局 isNaN(..) 在 JS 中依然存在，但永远不应使用。在检查 NaN 时，始终使用 Number.isNaN(..)、Object.is(..) 等。
</Callout>

---

### 大整数值

由于 JS 数字中的最大安全整数是 9007199254740991（见上文），如此相对较低的限制可能会在需要进行更大整数数学运算或仅仅存储像 64 位整数 ID（例如，Twitter 推文 ID）这样的值时造成问题。

因此，JS 提供了替代的 bigint 类型（大整数），可以存储任意大的（理论上不受限，除了有限的机器内存和/或 JS 实现）整数。

为了区别 bigint 和普通（整数）数字值，后者在外观上是相同的（42），JS 要求 bigint 值带有 n 后缀：

```js 
myAge = 42n;        // this is a bigint, not a number

myKidsAge = 11;     // this is a number, not a bigint
```

让我们说明 bigint 的上限无界性：

```js
Number.MAX_SAFE_INTEGER;        // 9007199254740991

Number.MAX_SAFE_INTEGER + 2;    // 9007199254740992 -- oops!

myBigInt = 9007199254740991n;

myBigInt + 2n;                  // 9007199254740993n -- phew!

myBigInt ** 2n;                 // 81129638414606663681390495662081n
```

正如您所见，bigint 值类型能够在数字值类型的整数限制之上进行精确运算。

警告：
<Callout icon="⚠️" type="warning">

请注意，+ 操作符需要 .. + 2n 而不是仅仅 .. + 2？您不能在同一个表达式中混合数字和 bigint 值类型。这一限制虽然令人烦恼，但它保护您的程序免于无效数学操作带来的非明显意外结果。

</Callout>


bigint 值也可以通过 BigInt(..) 函数创建；例如，将一个普通（整数）数字值转换为 bigint：

```js 
myAge = 42n;

inc = 1;

myAge += BigInt(inc);

myAge;              // 43n
```


<Callout icon="⚠️" type="warning">
尽管对某些读者来说，这可能看起来违反直觉，但 BigInt(..) 总是必须在没有 new 关键字的情况下调用。如果使用了 new，将抛出异常。
</Callout>


这确实是 BigInt(..) 函数最常见的用途之一：将数字转换为 bigint，以便进行数学运算。

但将大整数值表示为字符串并不少见，尤其是当这些值来自其他语言环境或通过某些交换格式时，这些格式本身不支持 bigint 风格的值。

因此，BigInt(..) 对于将这些字符串值强制转换为 bigint 是非常有用的：

```js 
myBigInt = BigInt("12345678901234567890");

myBigInt;                       // 12345678901234567890n
```

与 parseInt(..) 不同，如果字符串中的任何字符是非数字（0-9 的数字或 -），包括 . 或甚至一个尾随的 n 后缀字符，将抛出异常。换句话说，BigInt(..) 是一种全或无的强制转换，而不是解析转换。


<Callout icon="💡" type="info">
我认为 BigInt(..) 不接受尾随的 n 字符在字符串强制转换时（因此有效地忽略它）是荒谬的。我在 TC39 过程中强烈游说这种行为，但最终被拒绝。在我看来，这现在是 JS 上一个小小的缺陷，但无论如何它是一个缺陷。
</Callout>

---

### Symbol值

符号类型包含特殊的透明值，称为“符号”。这些值只能通过 Symbol(..) 函数创建：

```js 
secret = Symbol("my secret");
```

<Callout icon="⚠️" type="warning">
与 BigInt(..) 一样，Symbol(..) 函数必须在没有 new 关键字的情况下调用。
</Callout>


传递给 Symbol(..) 函数调用的“我的秘密”字符串并不是符号值本身，尽管看起来是那样。它只是一个可选的描述性标签，仅用于调试目的，为开发者提供便利。

从 Symbol(..) 返回的底层值是一种特殊类型的值，抵抗程序/开发者检测其底层表示的任何信息。这就是我所说的“透明”的意思。


<Callout icon="💡" type="info">
您可以将符号视为单调递增的整数——确实，这与一些 JS 引擎实现它们的方式类似。但 JS 引擎绝不会以任何您或程序可以看到的方式暴露符号的底层值的表示。
</Callout>



JS 引擎保证符号是唯一的（仅在程序内部），并且是不可猜测的。换句话说，在程序中绝不会创建重复的符号值。

您可能会想，这些符号用来做什么？

一种典型用法是作为开发者区分的“特殊”值，以免与其他可能意外冲突的值相碰撞。例如：
```js 
EMPTY = Symbol("not set yet");
myNickname = EMPTY;

// later:

if (myNickname == EMPTY) {
    // ..
}
```

在这里，我定义了一个特殊的 EMPTY 值，并将 myNickname 初始化为它。稍后，我检查它是否仍然是那个特殊的值，如果是，则执行某些操作。我可能不想为此使用 null 或 undefined，因为其他开发者可能能够传入这些常见的内置值。相比之下，EMPTY 是一个独特的、不可猜测的值，只有我定义并控制和访问它。

或许更常见的是，符号常常用作对象上的特殊（元）属性：

```js 
myInfo = {
    name: "Kyle Simpson",
    nickname: "getify",
    age: 42
};

// later:
PRIVATE_ID = Symbol("private unique ID, don't touch!");

myInfo[PRIVATE_ID] = generateID();
```

重要的是要注意，符号属性在任何对象上仍然是公开可见的；它们实际上并不是私有的。但它们被视为特殊的，并与正常的对象属性集合区分开来。这就像我这样做：

```js 
Object.defineProperty(myInfo,"__private_id_dont_touch",{
    value: generateID(),
    enumerable: false,
});
```

按照约定，大多数开发者知道，如果属性名称以 _（甚至更常见的 __！）为前缀，这意味着它是“伪私有”的，应该不去碰它，除非确实需要访问它。

符号基本上服务于相同的用途，但比前缀的方法更方便。

**知名符号 (WKS)**

JS 预定义了一组符号，称为知名符号（Well-Known Symbols，WKS），它们代表对象上的某些特殊元编程钩子。这些符号作为静态属性存储在 Symbol 函数对象上。例如：

```js 
myInfo = {
    // ..
};

String(myInfo);         // [object Object]

myInfo[Symbol.toStringTag] = "my-info";
String(myInfo);         // [object my-info]
```

Symbol.toStringTag 是一个知名符号，用于访问和覆盖普通对象的默认字符串表示（"[object Object]"），将 "Object" 部分替换为不同的值（例如，"my-info"）。

{/* todo */}
有关知名符号和元编程的更多信息，请参阅本系列的《对象与类》一书。

**全局符号注册表**

通常，您可能希望将符号值保持私有，例如在模块范围内。但有时，您希望将它们公开，以便在 JS 程序的所有文件中全局访问。

JS 提供了一个替代的全局命名空间来注册符号，而不是仅仅将它们作为全局变量（即 globalThis 对象上的属性）附加：

```js 
// retrieve if already registered,
// otherwise register
PRIVATE_ID = Symbol.for("private-id");

// elsewhere:

privateIDKey = Symbol.keyFor(PRIVATE_ID);
privateIDKey;           // "private-id"

// elsewhere:

// retrieve symbol from registry undeer
// specified key
privateIDSymbol = Symbol.for(privateIDKey);
```

传递给 Symbol.for(..) 的值与传递给 Symbol(..) 的值不同。Symbol.for(..) 期望一个唯一的键来注册全局注册表中的符号，而 Symbol(..) 可选地接受一个描述性标签（不一定是唯一的）。

如果注册表中没有指定键下的符号，则会创建一个新的符号（没有描述性标签），并自动注册到那里。否则，Symbol.for(..) 将返回之前在该键下注册的符号。

反过来，如果您有符号值本身，并想要检索它注册的键，Symbol.keyFor(..) 以符号本身作为输入，并返回该键（如果有）。这在传递键字符串值比符号本身更方便的情况下很有用。

**对象还是原始值？**

与其他原始值（如 42）不同，您可以创建相同值的多个副本，符号更像是特定的对象引用，因为它们总是完全唯一的（在值赋值和相等比较的目的下）。规范还将 Symbol() 函数归类于“基础对象”部分，称该函数为“构造函数”，甚至定义了其原型属性。

然而，如前所述，不能与 Symbol(..) 一起使用 new；这类似于 BigInt() “构造函数”。我们明确知道 bigint 值是原始值，因此符号值似乎也属于同一类。

在规范的“术语和定义”中，它将符号列为原始值。此外，这些值在 JS 程序中用作原始值而非对象。例如，符号主要用作对象中的键——我们知道对象不能使用其他对象值作为键！——以及字符串，它们也是原始值。

如前所述，一些 JS 引擎甚至在内部将符号实现为唯一的单调递增整数（原始值！）。

最后，正如本章开头所解释的，我们知道原始值不允许设置属性，但在内部会自动装箱（参见第三章中的“自动对象”）为相应的对象包装类型，以便便于属性/方法访问。符号遵循所有这些确切行为，与其他所有原始值相同。

总的来说，我认为符号更像是原始值而非对象，因此在本书中我将它们呈现为原始值。

---

### 原始值是内置类型

我们现在深入探讨了 JS 自动内置的七种原始（非对象）值类型。

在我们继续讨论 JS 的内置对象值类型之前，我们希望更仔细地看看我们可以期待的 JS 值的行为。我们将在下一章中深入探讨这一点。
