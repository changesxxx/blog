---
title: "强制转换值"
description: "我们已经全面覆盖了 JavaScript 中的所有不同类型的值。在这个过程中，我们多次提到转换的概念——实际上是强制转换——从一种值类型到另一种值类型。在本章中，我们将深入探讨强制转换，并揭示它的所有奥秘。"

name: "types-grammar-ch4"
---

### 强制转换：显式与隐式

一些开发者认为，当你在操作中明确表示类型变化时，这不算作强制转换，而只是类型转换或类型强制。换句话说，声称强制转换仅仅是隐式的。

我不同意这种描述。我用强制转换来标记在动态类型语言中的任何类型转换，无论在代码中是否显而易见。原因如下：显式和隐式之间的界限并不明确和客观，而是相当主观的。如果你认为类型转换是隐式的（因此是强制转换），但我认为它是显式的（因此不是强制转换），那么这种区分就变得无关紧要。

在我们探索各种显式和隐式强制转换形式时，请记住这种主观性。事实上，这里有一个剧透：大多数强制转换可以被认为是两者，因此我们将以一种平衡的视角来看待它们。

**隐式：坏还是...？**

在 JavaScript 开发者中，一个极其普遍的看法是强制转换是坏的，特别是隐式强制转换是坏的；像 TypeScript 这样的类型感知工具的流行，强烈表明了这种情绪。

但这种感觉并不新鲜。14 年前，Douglas Crockford 的书《JavaScript: The Good Parts》也著名地指责隐式强制转换是坏的一部分。甚至 JavaScript 的创建者 Brendan Eich 也经常声称，隐式强制转换是语言早期设计中的一个错误，他现在对此感到遗憾。

如果你在 JavaScript 中待过几个月，你几乎肯定会听到这些观点被强烈表达。如果你在 JavaScript 中待了多年，你可能已经下定了决心。

事实上，我认为你很难找到任何其他知名的 JavaScript 教学来源，强烈支持强制转换（几乎所有形式）；我有这样的观点——而这本书肯定也有！——但我感觉自己大多数时候像是在荒野中徒劳地呐喊。

然而，以下是我多年来观察到的一个现象：公开谴责隐式强制转换的大多数人，实际上在自己的代码中使用隐式强制转换。嗯...

Douglas Crockford 说要避免隐式强制转换的错误，但他的代码中使用了 if (..) 语句，并评估非布尔值。许多人过去对此表示不满，认为转换为布尔值并不算真正的强制转换。嗯...好吧？

Brendan Eich 说他后悔隐式强制转换，但他公开支持像 x + ""（以及其他！）这样的用法来强制将 x 的值转换为字符串（我们稍后会介绍）；这绝对是隐式强制转换。

那么我们该如何看待这种不协调？这仅仅是一个“小的自我矛盾”吗？还是还有更多？

我不会在这里下最终的判断，但我希望你这个读者在继续本章和本书时，深入思考这个问题。

---

### 抽象

现在我已经挑战你去更深入地审视强制转换，接下来让我们首先看看根据 JavaScript 规范强制转换发生的基础。

规范详细说明了一些抽象操作，这些操作决定了从一种值类型到另一种值类型的内部转换。了解这些操作非常重要，因为语言中的强制机制以各种方式混合和匹配它们。

这些操作看起来像是可以调用的真实函数，例如 ToString(..) 或 ToNumber(..)。但我们所说的抽象是指它们仅在概念上存在这些名称；它们不是我们可以直接在程序中调用的函数。相反，我们根据程序中的语句/表达式隐式/间接地激活它们。

**ToBoolean**

决策（条件分支）总是需要一个布尔值 true 或 false。但在基于非布尔值条件进行决策的情况下，这种情况非常常见，例如判断字符串是否为空或其中是否有内容。

当在需要布尔值的上下文中遇到非布尔值时——例如 if 语句或 for 循环的条件子句——会激活 [ToBoolean(..)](https://262.ecma-international.org/13.0/#sec-toboolean) 抽象操作以促进强制转换。

JavaScript 中的所有值都属于两个类别之一：真值（truthy）或假值（falsy）。真值通过 ToBoolean() 操作强制转换为 true，而假值则强制转换为 false：

```js
// ToBoolean() 是抽象的

ToBoolean(undefined); // false
ToBoolean(null); // false
ToBoolean(""); // false
ToBoolean(0); // false
ToBoolean(-0); // false
ToBoolean(0n); // false
ToBoolean(NaN); // false
```

简单规则：任何不在上述列表中的其他值都是真值，并通过 ToBoolean() 强制转换为 true：

```js
ToBoolean("hello"); // true
ToBoolean(42); // true
ToBoolean([1, 2, 3]); // true
ToBoolean({ a: 1 }); // true
```

即使是像 " "（只包含空格的字符串）、[]（空数组）和 {}（空对象）这样的值，虽然看起来直观上更像是“假”的，但它们仍然强制转换为 true。

<Callout icon="⚠️" type="warning">
对于这个真值规则，有一些狭窄而棘手的例外。例如，Web 平台已经弃用了长期存在的 document.all 集合/数组特性，尽管它无法完全移除——那样会破坏太多网站。即使在 document.all 仍然被定义的情况下，它也表现为一个“假对象”——未定义，然后强制转换为 false；这意味着像 if (document.all) `{ .. }` 这样的遗留条件检查不再通过。
</Callout>

ToBoolean() 强制转换操作基本上是一个查找表，而不是将非布尔值转换为布尔值的步骤算法。因此，一些开发者声称这并不算真正的强制转换，和其他抽象强制转换操作不一样。我认为这是无稽之谈。ToBoolean() 从非布尔值类型转换为布尔值，这明显是类型强制转换（即使这只是一个非常简单的查找，而不是一个算法）。

请记住：这些布尔强制转换的规则仅在实际激活 ToBoolean() 时适用。JavaScript 语言中有一些构造/习语，可能看起来涉及布尔强制转换，但实际上并不这样做。稍后会详细介绍这些。

**ToPrimitive**

任何不是已经是原始值的值都可以使用 ToPrimitive()（具体来说是 OrdinaryToPrimitive()）抽象操作减少为原始值。通常，ToPrimitive() 会给出一个提示，以告诉它是更喜欢数字还是字符串。

```js
// ToPrimitive() 是抽象的

ToPrimitive({ a: 1 }, "string"); // "[object Object]"

ToPrimitive({ a: 1 }, "number"); // NaN
```

该 ToPrimitive() 操作会查看提供的对象，寻找 toString() 方法或 valueOf() 方法；它查找这些方法的顺序由提示控制。“string”意味着首先检查 toString() / valueOf()，而“number”（或没有提示）则意味着首先检查 valueOf() / toString()。

如果方法返回的值与提示类型匹配，操作就完成了。但如果方法返回的值不是提示类型，ToPrimitive() 将查找并调用另一个方法（如果找到）。

如果方法调用的尝试未能生成提示类型的值，则最终返回值将通过相应的抽象操作强制转换：ToString() 或 ToNumber()。

**ToString**

几乎任何不是字符串的值都可以通过 ToString() 强制转换为字符串表示。这通常相当直观，特别是对于原始值：

```js
// ToString() 是抽象的

ToString(42.0); // "42"
ToString(-3); // "-3"
ToString(Infinity); // "Infinity"
ToString(NaN); // "NaN"
ToString(42n); // "42"

ToString(true); // "true"
ToString(false); // "false"

ToString(null); // "null"
ToString(undefined); // "undefined"
```

有一些结果可能与常识相悖。如第 2 章所述，非常大或非常小的数字将使用科学记数法表示：

```js
ToString(Number.MAX_VALUE); // "1.7976931348623157e+308"
ToString(Math.EPSILON); // "2.220446049250313e-16"
```

另一个与直觉相悖的结果来自 -0：

```js
ToString(-0); // "0" -- wtf?
```

这不是一个错误，而是 JavaScript 早期时代的一个故意行为，基于开发者通常不希望看到负零输出的假设。

有一个原始值类型不允许被强制转换（至少是隐式地）为字符串，那就是 symbol。

```js
ToString(Symbol("ok")); // TypeError exception thrown
```

<Callout icon="⚠️" type="warning">
  调用 String() 具体函数（没有使用 new 操作符）通常被认为仅仅是调用 ToString()
  抽象操作。虽然这在大多数情况下是正确的，但并不完全如此。String(Symbol("ok"))
  可以正常工作，而抽象的 ToString(Symbol(..)) 本身会抛出异常。本章后面会详细讨论
  String(..)。
</Callout>

**默认的 toString()**

当 ToString() 在对象值类型上被激活时，它会委托给 ToPrimitive() 操作（如前所述），并将 "string" 作为其提示类型：

```js
ToString(new String("abc")); // "abc"
ToString(new Number(42)); // "42"

ToString({ a: 1 }); // "[object Object]"
ToString([1, 2, 3]); // "1,2,3"
```

由于 ToPrimitive(..,"string") 的委托，这些对象都会调用它们的默认 toString() 方法（通过 [[Prototype]] 继承）。

**ToNumber**

看起来像数字的非数字值，例如数字字符串，通常可以使用 ToNumber() 强制转换为数值表示：

```js
// ToNumber() 是抽象

ToNumber("42"); // 42
ToNumber("-3"); // -3
ToNumber("1.2300"); // 1.23
ToNumber("   8.0    "); // 8
```

如果完整的值不完全（除了空白）看起来像有效数字，结果将是 NaN：

```js
ToNumber("123px"); // NaN
ToNumber("hello"); // NaN
```

其他原始值有某些指定的数字等价物：

```js
ToNumber(true); // 1
ToNumber(false); // 0

ToNumber(null); // 0
ToNumber(undefined); // NaN
```

对于 ToNumber() 的一些设计ations相当惊人：

```js
ToNumber(""); // 0
ToNumber("       "); // 0
```

<Callout icon="💡" type="info">
  我称这些为“惊人”，因为我认为它们强制转换为 NaN 会更合理，就像 undefined 一样。
</Callout>

有些原始值不允许被强制转换为数字，并且会导致异常而不是 NaN：

```js
ToNumber(42n); // TypeError exception thrown
ToNumber(Symbol("42")); // TypeError exception thrown
```

<Callout icon="⚠️" type="warning">
  调用 Number() 具体函数（没有使用 new 操作符）通常被认为仅仅是调用 ToNumber()
  抽象操作以将值强制转换为数字。虽然这在大多数情况下是正确的，但并不完全如此。Number(42n)
  可以正常工作，而抽象的 ToNumber(42n) 本身会抛出异常。
</Callout>

**其他抽象数字转换**

除了 ToNumber()，规范还定义了 ToNumeric()，它在值上激活 ToPrimitive()，然后在值不是已经是 bigint 值类型的情况下有条件地委托给 ToNumber()。

还有许多与将值转换为非常特定的通用数字类型子集相关的抽象操作：

- ToIntegerOrInfinity()
- ToInt32()
- ToUint32()
- ToInt16()
- ToUint16()
- ToInt8()
- ToUint8()
- ToUint8Clamp()

与 bigint 相关的其他操作：

- ToBigInt()
- StringToBigInt()
- ToBigInt64()
- ToBigUint64()

你可能可以从这些操作的名称推测出它们的目的，或者参考规范中的算法。对于大多数 JavaScript 操作，更可能激活像 ToNumber() 这样的高级操作，而不是这些特定的操作。

**默认的 valueOf()**

当 ToNumber() 在对象值类型上被激活时，它会委托给 ToPrimitive() 操作（如前所述），并将 "number" 作为其提示类型：

```js
ToNumber(new String("abc")); // NaN
ToNumber(new Number(42)); // 42

ToNumber({ a: 1 }); // NaN
ToNumber([1, 2, 3]); // NaN
ToNumber([]); // 0
```

由于 ToPrimitive(..,"number") 的委托，这些对象都会调用它们的默认 valueOf() 方法（通过 [[Prototype]] 继承）。

**相等比较**

当 JavaScript 需要确定两个值是否相同时，它会激活 SameValue() 操作，该操作委托给各种相关的子操作。

这个操作非常严格，不会执行任何强制转换或其他特殊情况的例外。如果两个值完全相同，结果为 true，否则为 false：

```js
// SameValue() 是抽象的

SameValue("hello", "\x68ello"); // true
SameValue("\u{1F4F1}", "\uD83D\uDCF1"); // true
SameValue(42, 42); // true
SameValue(NaN, NaN); // true

SameValue("\u00e9", "\u0065\u0301"); // false
SameValue(0, -0); // false
SameValue([1, 2, 3], [1, 2, 3]); // false
```

一个变体操作是 SameValueZero() 及其相关子操作。主要的区别是这些操作将 0 和 -0 视为不可区分。

```js
// SameValueZero() 是抽象的

SameValueZero(0, -0); // true
```

如果值是数字（number 或 bigint），SameValue() 和 SameValueZero() 都将委托给具有相同名称的子操作，分别针对每种数字和 bigint 类型。

否则，如果比较的值都是非数字，则委托给 SameValueNonNumeric() 子操作。

```js
// SameValueNonNumeric() 是抽象的

SameValueNonNumeric("hello", "hello"); // true

SameValueNonNumeric([1, 2, 3], [1, 2, 3]); // false
```

**更高抽象的相等比较**

与 SameValue() 及其变体不同，规范还定义了两个重要的更高抽象的抽象相等比较操作：

- IsStrictlyEqual()
- IsLooselyEqual()

IsStrictlyEqual() 操作在比较的值类型不同的情况下立即返回 false。

如果值类型相同，IsStrictlyEqual() 将委托给比较数字或 bigint 值的子操作。你可能逻辑上期望这些被委托的子操作是前面提到的数字专用的 SameValue() / SameValueZero() 操作。然而，IsStrictlyEqual() 实际上是委托给 Number:equal() 或 BigInt:equal()。

Number:SameValue() 和 Number:equal() 之间的区别在于，后者定义了 0 和 -0 比较的边界情况：

```js
// 所有这些都是抽象操作

Number: SameValue(0, -0); // false
Number: SameValueZero(0, -0); // true
Number: equal(0, -0); // true
```

这些操作在 NaN 与 NaN 的比较上也有所不同：

```js
Number: SameValue(NaN, NaN); // true
Number: equal(NaN, NaN); // false
```

<Callout icon="⚠️" type="warning">
  换句话说，尽管名字如此，IsStrictlyEqual() 在涉及 -0 或 NaN 的比较时并不如
  SameValue() 那样“严格”。
</Callout>

IsLooselyEqual() 操作也会检查被比较的值类型；如果相同，它会立即委托给 IsStrictlyEqual()。

但如果被比较的值类型不同，IsLooselyEqual() 会执行一系列强制相等的步骤。重要的是要注意，这个算法始终试图将比较简化到两个值类型相同的情况（并且倾向于优先使用数字 / bigint）。

强制相等部分的算法步骤大致可以总结如下：

1. 如果一个值是 null 而另一个是 undefined，IsLooselyEqual() 返回 true。换句话说，这个算法应用了空值相等，因为 null 和 undefined 彼此强制相等（而且与其他值不相等）。
2. 如果一个值是数字而另一个是字符串，则字符串值通过 ToNumber() 强制转换为数字。
3. 如果一个值是 bigint 而另一个是字符串，则字符串值通过 StringToBigInt() 强制转换为 bigint。
4. 如果一个值是布尔值，它会被强制转换为数字。
5. 如果一个值是非原始值（对象等），它会通过 ToPrimitive() 强制转换为原始值；尽管没有明确提供提示，但默认行为将假设提示为“数字”。

在上述步骤中每次执行强制转换时，算法会使用新值递归重新激活。这一过程将持续直到类型相同，然后将比较委托给 IsStrictlyEqual() 操作。

我们可以从这个算法中得出什么？首先，我们看到在比较中存在对数字（或 bigint）的偏好；它从不将值强制转换为字符串或布尔值类型。

重要的是，我们看到 IsLooselyEqual() 和 IsStrictlyEqual() 都对类型敏感。IsStrictlyEqual() 在类型不匹配时立即退出，而 IsLooselyEqual() 执行额外的工作以将不匹配的值类型强制转换为相同的值类型（再次，理想情况下是数字或 bigint）。

此外，如果/一旦类型相同，这两个操作是相同的——IsLooselyEqual() 委托给 IsStrictlyEqual()。

**关系比较**

当值进行关系比较时——即一个值是否“小于”另一个？——会激活一个特定的抽象操作：IsLessThan()。

```js
// IsLessThan() i是抽象

IsLessThan(1, 2, /*LeftFirst=*/ true); // true
```

没有 IsGreaterThan() 操作；相反，IsLessThan() 的前两个参数可以反转，以实现“大于”比较。为了保持从左到右的评估语义（在存在细微副作用的情况下），IsLessThan() 还接受一个第三个参数（LeftFirst）；如果为 false，则表示比较被反转，第二个参数应在第一个之前进行评估。

```js
IsLessThan(1, 2, /*LeftFirst=*/ true); // true

// equivalent of a fictional "IsGreaterThan()"
IsLessThan(2, 1, /*LeftFirst=*/ false); // false
```

类似于 IsLooselyEqual()，IsLessThan() 操作是强制的，这意味着它首先确保两个值的值类型匹配，并优先进行数字比较。没有用于非强制关系比较的 IsStrictLessThan()。

作为强制关系比较的一个例子，如果一个值的类型是字符串而另一个是 bigint，则字符串通过前面提到的 StringToBigInt() 操作强制转换为 bigint。一旦类型相同，IsLessThan() 将按照以下部分的描述进行处理。

**字符串比较**

当两个值都是字符串类型时，IsLessThan() 会检查左侧值是否是右侧值的前缀（前 n 个字符）；如果是，则返回 true。

如果两个字符串都不是彼此的前缀，则会比较两个字符串之间第一个不同的字符位置（从开始到结束的方向，而不是从左到右），比较它们各自的代码单元（数值）值；然后返回结果。

一般来说，代码单元遵循直观的字典（即，字典）顺序：

```js
IsLessThan("a", "b", /*LeftFirst=*/ true); // true
```

即使是数字也被视为字符（而不是数字）：

```js
IsLessThan("101", "12", /*LeftFirst=*/ true); // true
```

至少现在我们回答了这个古老的问题：先有鸡还是先有蛋？！

```js
IsLessThan("🐔", "🥚", /*LeftFirst=*/ true); // true
```

**数字比较**

对于数字比较，IsLessThan() 分别委托给 Number:lessThan() 或 BigInt:lessThan() 操作。

```js
IsLessThan(41,42, /*LeftFirst=*/ true );         // true

IsLessThan(-0,0, /*LeftFirst=*/ true );          // false

IsLessThan(NaN,1 /*LeftFirst=*/ true );          // false

IsLessThan(41n,42n, /*LeftFirst=*/ true );       // true

```

---

### 具体强制转换

现在我们已经覆盖了 JavaScript 定义的处理各种强制转换的所有抽象操作，接下来是时候关注我们可以在程序中使用的具体语句/表达式，这些语句/表达式会激活这些操作。

**To Boolean**

要将不属于布尔类型的值强制转换为该类型，我们需要前面在本章中描述的抽象 ToBoolean() 操作。

在探索如何激活它之前，让我们讨论一下你为什么想要强制执行 ToBoolean() 转换。

从代码可读性的角度来看，明确类型强制可能是更可取的（尽管不是普遍适用）。但从功能上讲，强制布尔值的最常见原因是在将数据传递给外部源时——例如，将数据作为 JSON 提交给 API 端点——而该位置期望 true / false，而不需要执行强制转换。

有几种方法可以激活 ToBoolean()。也许最明确（显而易见）的是 Boolean(..) 函数：

```js
Boolean("hello"); // true
Boolean(42); // true

Boolean(""); // false
Boolean(0); // false
```

如第 3 章所提到的，请记住 Boolean(..) 是在没有 new 关键字的情况下被调用的，以激活 ToBoolean() 抽象操作。

在 JavaScript 开发者中，看到使用 Boolean(..) 函数进行如此明确的强制转换并不常见。开发者更常使用双重 ! 习语：

```js
!!"hello"; // true
!!42; // true

!!""; // false
!!0; // false
```

<Callout icon="💡" type="info">
  !! 并不是它自己的操作符，尽管看起来是这样。它实际上是两次使用一元 !
  操作符。这个操作符首先将任何非布尔值强制转换，然后取反。为了撤销取反，第二个 !
  将其翻转回来。
</Callout>

那么……在这两者中，Boolean(..) 或 !!，你认为哪个更像是明确的强制转换？

考虑到 ! 所做的翻转，必须用另一个 ! 进行撤销，我会说 Boolean(..) 在将非布尔值强制转换为布尔值的工作上更明确——而不是 !!。但在查看开源 JavaScript 代码时，!! 的使用频率要高得多。

如果我们将明确的定义为“最直接和显而易见地执行一个动作”，那么 Boolean(..) 更占优势。如果我们将明确的定义为“最能被识别地执行一个动作”，那么 !! 可能更占优势。这里有明确的答案吗？

在你思考这个问题的同时，让我们看看另一个在内部激活 ToBoolean() 的 JavaScript 机制：

```js
specialNumber = 42;

if (specialNumber) {
  // ..
}
```

该 if 语句需要一个布尔值作为条件来进行控制流决策。如果你传入一个非布尔值，则会执行 ToBoolean() 强制转换。

与之前的 ToBoolean() 强制转换表达式（如 Boolean(..) 或 !!）不同，这种 if 强制转换是短暂的，因为我们的 JavaScript 程序从未看到强制转换的结果；它只是内部被 if 使用。有些人可能会觉得，如果程序不保留/使用该值，那它就不算真正的强制转换。但我强烈不同意，因为强制转换无疑会影响程序的行为。

许多其他语句类型也会激活 ToBoolean() 强制转换，包括 ?: 三元条件运算符，以及 for / while 循环。我们还有 &&（逻辑与）和 ||（逻辑或）运算符。例如：

```js
isLoggedIn = user.sessionID || req.cookie["Session-ID"];

isAdmin = isLoggedIn && "admin" in user.permissions;
```

对于这两个运算符，左侧表达式首先被评估；如果它不是布尔值，则会激活 ToBoolean() 强制转换以生成条件决策的值。

<Callout icon="💡" type="info">
  简单解释这些运算符：
</Callout>

在前面的代码片段中，尽管命名暗示如此，但 isLoggedIn 实际上不太可能是布尔值；如果它为真值，isAdmin 也不会是布尔值。这样的代码相当常见，但假设的布尔结果类型实际上并不存在，这显然是危险的。我们将在下一章重新审视这个例子以及这些运算符。

这些类型的语句/表达式（例如 if (..)、||、&& 等）在其条件决策中展示的是显式强制还是隐式强制？

再次强调，这取决于你的视角。规范明确规定它们仅用布尔条件值作出决策，如果接收到非布尔值，则需要强制转换。另一方面，也可以强有力地争辩说，任何内部强制转换都是对 if / && / 等的主要工作的一种 "隐含"（implicit）效果。

此外，如前面在 ToBoolean() 讨论中提到的，有些人认为任何 ToBoolean() 的激活都不是强制转换。

不过，我认为这有些牵强。我的看法是：Boolean(..) 是最可取的显式强制转换形式。我认为 !!、if、for、while、&& 和 || 都是在隐式强制非布尔值，但我对此没有意见。

由于大多数开发者，包括像 Doug Crockford 这样的知名人物，实际上在代码中也使用隐式（布尔）强制转换，我认为我们可以说，至少某些形式的隐式强制转换在广泛接受的范围内，尽管有普遍的反对言论。

**To String**

与 ToBoolean() 一样，有多种方法可以激活 ToString() 强制转换（如前面在本章中讨论的）。选择哪种方法同样是主观的。

与 Boolean(..) 函数一样，String(..) 函数（没有新关键字）是激活显式 ToString() 强制转换的主要方式：

```js
String(true); // "true"
String(42); // "42"
String(-0); // "0"
String(Infinity); // "Infinity"

String(null); // "null"
String(undefined); // "undefined"
```

然而，String(..) 不仅仅是激活 ToString()。例如：

```js
String(Symbol("ok")); // "Symbol(ok)"
```

这可以正常工作，因为对符号值的显式强制转换是允许的。但在符号被隐式强制转换为字符串的情况下（例如 Symbol("ok") + ""），底层的 ToString() 操作会抛出异常。这证明了 String(..) 不仅仅是激活 ToString()。稍后会详细讨论符号的隐式字符串强制转换。

如果你用对象值（例如数组等）调用 String(..)，它会激活 ToPrimitive() 操作（通过 ToString() 操作），然后查找并调用该值的 toString() 方法：

```js
String([1, 2, 3]); // "1,2,3"

String((x) => x + 1); // "x => x + 1"
```

除了 String(..)，任何原始的、非空值（既不是 null 也不是 undefined）都可以在其各自的对象包装中自动装箱（参见第 3 章），提供一个可调用的 toString() 方法。

```js
true.toString(); // "true"
(42).toString(); // "42"
-(0).toString(); // "0"
Infinity.toString(); // "Infinity"
Symbol("ok").toString(); // "Symbol(ok)"
```

<Callout icon="💡" type="info">
  请记住，这些 toString() 方法并不一定会激活 ToString()
  操作，它们只是定义了如何以字符串形式表示值的规则。
</Callout>

如前面提到的 String(..)，各种对象子类型——如数组、函数、正则表达式、日期和错误实例等——都定义了自己的特定 toString() 方法，可以直接调用：

```js
[1, 2, 3].toString(); // "1,2,3"

((x) => x + 1).toString(); // "x => x + 1"
```

此外，任何默认链接到 Object.prototype 的普通对象都有一个默认的 toString() 方法可用：

```js
({ a: 1 }).toString(); // "[object Object]"
```

toString() 强制转换的方法是显式还是隐式？再次，这取决于情况。它显然是一种自描述机制，倾向于显式。但它通常依赖于自动装箱，这本身是一种相当隐式的强制转换。

让我们看一个常见的——并且广受推崇的！——用于将值强制转换为字符串的习语。回想一下第 2 章中的“字符串连接”，+ 运算符被重载为在任一操作数已经是字符串时优先进行字符串连接，因此在必要时将非字符串操作数强制转换为字符串。

考虑以下例子：

```js
true + ""; // "true"
42 + ""; // "42"
null + ""; // "null"
undefined + ""; // "undefined"
```

- "" 的字符串强制转换习语利用了 + 的重载，而不改变最终强制转换的字符串值。顺便说一下，反转操作数时（即 "" + ..），所有这些都工作相同。

<Callout icon="⚠️" type="warning">
  一个极为常见的误解是 String(x) 和 x + ""
  基本上是等效的强制转换，分别只是形式上的显式与隐式。但，这并不完全正确！我们将在本章后面的“强制为原始值”部分重新审视这一点。
</Callout>

有些人觉得这是显式强制，但我认为这显然更隐式，因为它利用了 + 的重载；此外，"" 间接用于激活强制转换而未进行修改。此外，考虑当这个习语应用于符号值时会发生什么：

```js
Symbol("ok") + ""; // TypeError exception thrown
```

<Callout icon="⚠️" type="warning">
  允许对符号的显式强制转换（String(Symbol("ok"))），但不允许隐式强制转换（Symbol("ok")
  + ""），这是 TC39
  的深思熟虑。人们认为，Symbol作为原始值，常常用于字符串被用到的地方，可能过于容易被误解为字符串。因此，他们希望确保开发者明确表示有意将Symbol强制转换为字符串，从而避免许多预期中的混淆。这是语言设计在显式与隐式强制转换之间明确表达意见并进行区分的极少数情况之一。
</Callout>

为什么会有这个例外？JavaScript 将 + "" 视为隐式强制转换，这就是为什么当与Symbol一起激活时会抛出异常。我认为这是一种相当确凿的证明。

尽管如此，正如我在本章开头提到的，Brendan Eich 支持 + "" 作为将值强制转换为字符串的最佳方法。我认为这在支持至少一部分隐式强制转换实践方面具有很大影响力。他对隐式强制转换的看法可能比“都是坏事”要细腻得多。

**To Number**

数字强制转换比字符串强制转换要复杂一些，因为我们可能讨论的是 number 或 bigint 作为目标类型。有效数字的表示值集也要小得多（其他所有值都会变为 NaN）。

让我们先从 Number(..) 和 BigInt(..) 函数（没有新关键字）开始：

```js
Number("42"); // 42
Number("-3.141596"); // -3.141596
Number("-0"); // -0

BigInt("42"); // 42n
BigInt("-0"); // 0n
```

数字强制转换如果失败（未被识别），结果将是 NaN（见第 1 章的“无效数字”），而 BigInt 则会抛出异常：

```js
Number("123px"); // NaN

BigInt("123px");
// SyntaxError: Cannot convert 123px to a BigInt
```

此外，尽管 42n 是有效的 bigint 字面量语法，但字符串 "42n" 无论通过哪个强制转换函数形式都永远不会被识别为 bigint 的字符串表示：

```js
Number("42n"); // NaN

BigInt("42n");
// SyntaxError: Cannot convert 42n to a BigInt
```

然而，我们可以强制转换其他数字表示形式的数字字符串（见第 1 章获取更多信息）：

```js
Number("0b101010"); // 42

BigInt("0b101010"); // 42n
```

通常，Number(..) 和 BigInt(..) 接收字符串值，但实际上并不是必须的。例如，true 和 false 会强制转换为它们典型的数字等价物：

```js
Number(true); // 1
Number(false); // 0

BigInt(true); // 1n
BigInt(false); // 0n
```

你还可以在 number 和 bigint 类型之间进行强制转换：

```js
Number(42n); // 42
Number(42n ** 1000n); // Infinity

BigInt(42); // 42n
```

我们还可以使用一元 + 运算符，通常预期其效果与 Number(..) 函数相同：

```js
+"42"; // 42
+"0b101010"; // 42
```

但要小心。如果这些强制转换在某些方面不安全/无效，则会抛出异常：

```js
BigInt(3.141596);
// RangeError: The number 3.141596 cannot be converted to a BigInt

+42n;
// TypeError: Cannot convert a BigInt value to a number
```

显然，3.141596 并不安全地强制转换为整数，更别说 bigint 了。

但是 +42n 抛出异常是一个有趣的案例。相比之下，Number(42n) 工作正常，因此 +42n 失败有点令人惊讶。

<Callout icon="⚠️" type="warning">
  这种惊讶尤其明显，因为在数字前加 + 通常被认为只是表示“正数”，就像在数字前加 -
  被认为表示“负数”一样。然而，如第 1 章所述，JavaScript 数字语法（number 和
  bigint）并不识别“负值”的语法。所有数字字面量默认解析为“正数”。如果前面加了 +
  或 -，则将其视为应用于解析的（正数）数字的单目运算符。
</Callout>

好的，+42n 被解析为 +(42n)。但问题是……为什么在这里 + 会抛出异常？

你可能记得之前我们展示了 JavaScript 允许对symbol值进行显式字符串强制转换，但不允许隐式字符串强制转换？这里发生的事情是一样的。<mark>JavaScript 语言设计将一元 + 视为对 bigint 值的隐式 ToNumber() 强制转换（因此不被允许！），而 Number(..) 被解释为显式 ToNumber() 强制转换（因此被允许！）。</mark>

换句话说，与普遍的假设/陈述相反，Number(..) 和 + 是不可互换的。我认为 Number(..) 是更安全/更可靠的形式。

**数学运算**

数学运算符（例如 `+`、`-`、`*`、`/`、`%` 和 `**`）期望它们的操作数是数字。如果你使用非数字与它们进行运算，该值将被强制转换为数字以进行数学计算。

类似于` x + ""` 是将 `x` 强制转换为字符串的习语，像 `x - 0` 这样的表达式安全地将 `x` 强制转换为数字。

<Callout icon="⚠️" type="warning">
  x + 0 并不是那么安全，因为 +
  运算符被重载为在任一操作数已经是字符串时执行字符串连接。-
  运算符并没有这样重载，因此唯一的强制转换将是数字。当然，x * 1、x / 1，甚至 x
  ** 1
  通常在数学上也是等效的，但这些用法要少得多，可能应该避免，因为可能会让读代码的人感到困惑。即使
  x % 1 似乎应该是安全的，但它可能引入浮点误差（见第 2 章的“浮点不精确”）。
</Callout>

不论使用哪个数学运算符，如果强制转换失败，结果将是 NaN，而所有这些运算符都会将 NaN 传播出来作为它们的结果。

**位运算**

位运算符（例如 `|`、`&`、`^`、`>>`、`<<` 和 `<<<`）都期望数字操作数，但特别是它们将这些值限制为 32 位整数。

如果你确定正在处理的数字安全地在 32 位整数范围内，x | 0 是另一个常见的表达式习语，其效果是必要时将 x 强制转换为数字。

此外，由于 JS 引擎知道这些值将是整数，因此它们有可能在看到 x | 0 时进行整数数学的优化。这是多年前 ASM.js 努力中的几种推荐“类型注释”之一。

**属性访问**

对象的属性访问（和数组的索引访问）是另一个可能发生隐式强制转换的地方。

考虑以下示例：

```js
myObj = {};

myObj[3] = "hello";
myObj["3"] = "world";

console.log(myObj);
```

你期望这个对象的内容是什么？你期望两个不同的属性，数字 3（持有 "hello"）和字符串 "3"（持有 "world"）吗？还是你认为这两个属性在同一个位置？

如果你尝试那段代码，你会发现我们确实得到了一个只有一个属性的对象，并且它持有 "world" 值。这意味着 JavaScript 在访问这些属性时要么将 3 强制转换为 "3"，要么反之。

有趣的是，开发者控制台可能会将这个对象表示为：

```js
console.log(myObj);
// {3: 'world'}
```

那里的 3 是表示属性是数字 3 吗？并不是。尝试向 myObj 添加另一个属性：

```js
myObj.something = 42;

console.log(myObj);
// {3: 'world', something: 42}
```

我们可以看到这个开发者控制台不对字符串属性键进行引号处理，因此从 3 和如果控制台使用 "3" 作为键名之间，我们无法推断出任何信息。

让我们改为查阅对象值的规范[^ObjectValue]，我们发现：

属性键值可以是 ECMAScript 字符串值或Symbol值。所有字符串和Symbol值，包括空字符串，都是有效的属性键。属性名称是属性键的字符串值。

好的！所以，在 JavaScript 中，对象只持有字符串（或Symbol）属性。这意味着数字 3 必须被强制转换为字符串 "3"，对吗？

在规范的同一部分中，我们进一步阅读到：

整数索引是一个字符串值的属性键，它是一个规范的数字字符串（见 7.1.21），其数字值为 +0𝔽 或正整数值 ≤ 𝔽(253 - 1)。数组索引是其数字值 i 在范围 +0𝔽 ≤ i < 𝔽(232 - 1) 内的整数索引。

如果属性键（如 "3"）看起来像数字，则被视为整数索引。嗯……这似乎几乎暗示了我们刚刚推测的相反的结论，对吧？

尽管如此，我们知道从前面的引用中，属性键仅是字符串（或Symbol）。所以这里的“整数索引”并不是描述实际位置，而是描述在 JavaScript 代码中使用 3 作为开发者表达的“整数索引”；JavaScript 仍然必须将其实际存储在“规范数字字符串”的位置。

考虑尝试使用其他值类型，如 true、null、undefined，甚至非原始值（其他对象）：

```js
myObj[true] = 100;
myObj[null] = 200;
myObj[undefined] = 300;
myObj[{ a: 1 }] = 400;

console.log(myObj);
// {3: 'world', something: 42, true: 100, null: 200,
// undefined: 300, [object Object]: 400}
```

如你所见，所有这些其他值类型都被强制转换为字符串，以便作为对象属性名称。

但在我们说服自己所有（甚至数字）都被强制转换为字符串之前，让我们看看一个数组示例：

```js
myArr = [];

myArr[3] = "hello";
myArr["3"] = "world";

console.log(myArr);
// [empty × 3, 'world']
```

开发者控制台可能会以与普通对象略有不同的方式表示数组。尽管如此，我们仍然看到这个数组在对应于 3 的数字索引位置上只有单个 "world" 值。

这种输出似乎暗示我们之前解释的相反：数组的值似乎仅在数字位置上存储。如果我们向 myArr 添加另一个字符串属性名称：

```js
myArr.something = 42;
console.log(myArr);
// [empty × 3, 'world', something: 42]
```

现在我们看到这个开发者控制台在没有属性名称（位置）的情况下表示数组中的数字索引位置，但输出中有 something 属性的名称。

同样，JavaScript 引擎（如 v8）出于性能优化原因，往往会将看起来像数字的字符串属性特殊处理为实际上存储在数字位置，就像它们是数组一样。因此，即使 JavaScript 程序行为上将属性名称视为 "3"，实际上在后台，v8 可能会将其视为强制转换为 3！

我们能从这一切中得出什么？

规范明确告诉我们，<mark>对象属性的行为是将其视为字符串（或symbols）。这意味着我们可以假设使用 3 来访问对象上的位置将内部效应地将该属性名称强制转换为 "3"。</mark>

但在数组中，我们观察到一种相反的语义：使用 "3" 作为属性名称会导致访问数字索引位置 3，就好像字符串被强制转换为数字一样。但这主要只是因为<mark>数组总是倾向于以数字索引的方式行为</mark>，或者可能是 JavaScript 引擎中的底层实现/优化细节的反映。

重要的是，我们需要认识到，对象不能简单地使用任何值作为属性名称。如果它不是字符串或数字，我们可以预期该值会发生强制转换。

我们需要预期并为此做好计划，而不是让它在后续出现错误时让我们感到意外！

<Callout icon="📝" type="notes">
个人总结:
1. 对象属性强制转换：在 JavaScript 中，所有对象的属性键都被视为字符串或符号。因此，数字 3 会被强制转换为字符串 "3"。

2. 数组的特殊行为：虽然数组也是对象，但它们倾向于以数字索引的方式行为，字符串 "3" 被视为数字索引 3 的访问。

3. 预期强制转换：任何非字符串或非数字的值作为属性名称都将被强制转换。

</Callout>

**To Primitive**

JavaScript 中的大多数运算符，包括我们看到的字符串和数字的强制转换，都是设计用来处理原始值的。当任何这些运算符被用于对象值时，将激活抽象的 ToPrimitive 算法（如前所述），以将对象强制转换为原始值。

让我们设置一个可以用来检查不同操作行为的对象：

```js
spyObject = {
  toString() {
    console.log("toString() invoked!");
    return "10";
  },
  valueOf() {
    console.log("valueOf() invoked!");
    return 42;
  },
};
```

这个对象定义了 toString() 和 valueOf() 方法，每个方法返回不同类型的值（字符串与数字）。

让我们尝试一些我们已经看到的强制转换操作：

```js
String(spyObject);
// toString() invoked!
// "10"

spyObject + "";
// valueOf() invoked!
// "42"
```

哇！我敢打赌这让你们中的一些读者感到惊讶；这确实让我感到意外。<mark>人们常常声称 String(..) 和 + "" 是激活 ToString() 操作的等效形式。但它们显然不是！</mark>

区别在于每个操作提供给 ToPrimitive() 的提示。String(..) 清楚地提供了 "string" 作为提示，而 + "" 习语则没有提示（类似于提示 "number"）。但不要忽视这个细节：尽管 + "" 调用 valueOf()，当返回的数字原始值为 42 时，该值随后被强制转换为字符串（通过 ToString()），因此我们得到的是 "42" 而不是 42。

让我们继续：

```js
Number(spyObject);
// valueOf() invoked!
// 42

+spyObject;
// valueOf() invoked!
// 42
```

这个例子暗示<mark> Number(..) 和一元 + 运算符都执行相同的 ToPrimitive() 强制转换</mark>（提示为 "number"），在我们的例子中返回 42。由于这已经是请求的数字值，因此值会顺利返回。

但如果 valueOf() 返回一个 bigint 呢？

```js
spyObject2 = {
  valueOf() {
    console.log("valueOf() invoked!");
    return 42n; // bigint!
  },
};

Number(spyObject2);
// valueOf() invoked!
// 42     <--- look, not a bigint!

+spyObject2;
// valueOf() invoked!
// TypeError: Cannot convert a BigInt value to a number
```

我们在“转换为数字”部分早些时候看到了这个区别。JavaScript 允许将 42n bigint 值显式强制转换为 42 数字值，但不允许它认为是隐式强制转换形式。

那么 BigInt(..)（没有新关键字）强制转换函数呢？

```js
BigInt(spyObject);
// valueOf() invoked!
// 42n    <--- look, a bigint!

BigInt(spyObject2);
// valueOf() invoked!
// 42n

// *******************************

spyObject3 = {
  valueOf() {
    console.log("valueOf() invoked!");
    return 42.3;
  },
};

BigInt(spyObject3);
// valueOf() invoked!
// RangeError: The number 42.3 cannot be converted to a BigInt
```

同样，如我们在“转换为数字”部分所见，42 可以安全地强制转换为 42n。另一方面，42.3 不能安全地强制转换为 bigint。

我们已经看到 toString() 和 valueOf() 在某些字符串和数字 / bigint 强制转换时被调用。

**没有找到原始值？**

如果 ToPrimitive() 未能生成原始值，将抛出异常：

```js
spyObject4 = {
  toString() {
    console.log("toString() invoked!");
    return [];
  },
  valueOf() {
    console.log("valueOf() invoked!");
    return {};
  },
};

String(spyObject4);
// toString() invoked!
// valueOf() invoked!
// TypeError: Cannot convert object to primitive value

Number(spyObject4);
// valueOf() invoked!
// toString() invoked!
// TypeError: Cannot convert object to primitive value
```

如果你要通过 toString() / valueOf() 定义自定义的原始强制转换，请确保至少从其中一个方法返回一个原始值！

**对象转换为布尔值**

对象的布尔强制转换怎么样？

```js
Boolean(spyObject);
// true

!spyObject;
// false

if (spyObject) {
  console.log("if!");
}
// if!

result = spyObject ? "ternary!" : "nope";
// "ternary!"

while (spyObject) {
  console.log("while!");
  break;
}
// while!
```

每个对象都在激活 ToBoolean()。但如果你还记得以前的内容，这个算法从不委托给 ToPrimitive()；因此，我们不会看到 "valueOf() 被调用！" 的日志。

**解箱：包装原始值**

一种特殊形式的对象经常被 ToPrimitive() 强制转换：包装的原始值（如第 3 章所见）。这种特定的对象到原始值的强制转换通常被称为解箱（unboxing）。

考虑以下示例：

```js
hello = new String("hello");
String(hello); // "hello"
hello + ""; // "hello"

fortyOne = new Number(41);
Number(fortyOne); // 41
fortyOne + 1; // 42
```

上面的对象包装器 hello 和 fortyOne 配置了 toString() 和 valueOf() 方法，以便行为类似于我们之前示例中的 spyObject 等对象。

要谨慎处理的包装对象原始值的一个特殊情况是与 Boolean() 相关的：

```js
nope = new Boolean(false);
Boolean(nope); // true   <--- oops!
!!nope; // true   <--- oops!
```

请记住，这是因为 <mark>ToBoolean() 并不通过 ToPrimitive 将对象简化为其原始形式；它仅仅查找该值在其内部表中的值，由于普通（非特殊）对象总是为真，因此返回 true。</mark>

<Callout icon="💡" type="info">
  这是一个棘手的陷阱。确实可以论证 new Boolean(false)
  应该在内部配置为一个特殊的“假值对象”。不幸的是，这一变化发生在 JavaScript
  发展历史的 25 年前，可能会导致程序出现问题。因此，JavaScript
  并未对此陷阱进行修改。
</Callout>

**重写默认的 toString()**

正如我们所见，你可以始终在对象上定义一个 toString() 以使其在适当的 ToPrimitive() 强制转换中被调用。但另一个选择是重写 Symbol.toStringTag：

```js
spyObject5a = {};
String(spyObject5a);
// "[object Object]"
spyObject5a.toString();
// "[object Object]"

spyObject5b = {
  [Symbol.toStringTag]: "my-spy-object",
};
String(spyObject5b);
// "[object my-spy-object]"
spyObject5b.toString();
// "[object my-spy-object]"

spyObject5c = {
  get [Symbol.toStringTag]() {
    return `myValue:${this.myValue}`;
  },
  myValue: 42,
};
String(spyObject5c);
// "[object myValue:42]"
spyObject5c.toString();
// "[object myValue:42]"
```

Symbol.toStringTag 旨在定义一个自定义字符串值，以描述对象无论何时直接或隐式通过强制转换调用其默认 toString() 操作；在其缺失的情况下，使用的值是 "Object"，在常见的 "[object Object]" 输出中。

spyObject5c 中的 get .. 语法定义了一个 getter。这意味着当 JavaScript 尝试像正常一样访问 Symbol.toStringTag 作为属性时，这个 getter 代码将导致我们指定的函数被调用以计算结果。我们可以在这个 getter 中运行任何任意逻辑，以动态确定用于默认 toString() 方法的字符串标签。

**重写 ToPrimitive**

你可以通过设置特殊符号属性 Symbol.toPrimitive 来替代任何对象的默认 ToPrimitive() 操作：

```js
spyObject6 = {
  [Symbol.toPrimitive](hint) {
    console.log(`toPrimitive(${hint}) invoked!`);
    return 25;
  },
  toString() {
    console.log("toString() invoked!");
    return "10";
  },
  valueOf() {
    console.log("valueOf() invoked!");
    return 42;
  },
};

String(spyObject6);
// toPrimitive(string) invoked!
// "25"   <--- not "10"

spyObject6 + "";
// toPrimitive(default) invoked!
// "25"   <--- not "42"

Number(spyObject6);
// toPrimitive(number) invoked!
// 25     <--- not 42 or "25"

+spyObject6;
// toPrimitive(number) invoked!
// 25
```

如你所见，如果你在对象上定义这个函数，完全会替代默认的 ToPrimitive() 抽象操作。由于提示仍然提供给这个被调用的函数（[Symbol.toPrimitive](..)），理论上你可以实现自己的算法版本，在对象上调用 toString()、valueOf() 或任何其他方法（这个上下文引用）。

或者你可以像上面那样手动定义一个返回值。无论如何，JavaScript 不会自动调用 toString() 或 valueOf() 方法。

<Callout icon="⚠️" type="warning">
  如前面在“没有找到原始值？”部分讨论的那样，如果定义的 Symbol.toPrimitive
  函数实际上没有返回原始值，将抛出关于无法“...将对象转换为原始值”的异常。确保始终从该函数返回一个实际的原始值！
</Callout>

**相等性**

到目前为止，我们看到的强制转换主要集中在单个值上。现在我们将注意力转向相等比较，这本质上涉及两个值，这两个值都可能受到强制转换。

在本章早些时候，我们讨论了几个用于值相等比较的抽象操作。

例如，SameValue() 操作是最严格的相等比较，绝对没有强制转换。依赖于 SameValue() 的最明显的 JavaScript 操作是：

```js
Object.is(42, 42); // true
Object.is(-0, -0); // true
Object.is(NaN, NaN); // true

Object.is(0, -0); // false
```

SameValueZero() 操作——回忆一下，它仅通过将 -0 和 0 视为不可区分而与 SameValue() 不同——在很多地方使用，包括：

```js
[1, 2, NaN].includes(NaN); // true
```

我们可以在这里看到 SameValueZero() 的 0 / -0 混淆：

```js
[1, 2, -0].includes(0); // true  <--- oops!

new Set([1, 2, 0]).has(-0); // true  <--- ugh

new Map([[0, "ok"]]).has(-0); // true  <--- :(
```

在这些情况下，有一种（某种程度上的）强制转换将 -0 和 0 视为不可区分。不是的，这在技术上并不算“强制转换”，因为类型没有被改变，但我有点模糊了定义，以将这个案例纳入我们对强制转换的更广泛讨论。

&zwj;<mark>将 includes() / has() 方法与激活 SameValueZero() 相对比，使用传统的 indexOf(..) 数组工具则激活 IsStrictlyEqual()。这个算法在某种程度上比 SameValueZero() 更“强制”，因为它防止 NaN 值被视为相等</mark>：

```js
[1, 2, NaN].indexOf(NaN); // -1  <--- not found
```

如果 includes(..) 和 indexOf(..) 的这些细微差别让你感到困扰，当在数组中搜索——查找某个值的相等匹配时，你可以避免任何“强制”怪癖，并强制最严格的 SameValue() 相等匹配，通过 Object.is(..) 实现。

```js
vals = [0, 1, 2, -0, NaN];

vals.find((v) => Object.is(v, -0)); // -0
vals.find((v) => Object.is(v, NaN)); // NaN

vals.findIndex((v) => Object.is(v, -0)); // 3
vals.findIndex((v) => Object.is(v, NaN)); // 4
```

<Callout icon="📝" type="notes">

个人总结:

- Object.is 是最严格的相等比较方法，没有强制转换，并且能区分 0 和
  -0，以及 NaN(底层是SameValue)。

- SameValueZero 比较方法将 0 和 -0
  视为相等，通常在 includes 和 Set.has 方法中使用。

- IsStrictlyEqual
  比较方法（如 indexOf）不会将 NaN 视为相等。

</Callout>

**相等运算符：== 与 ===**

在相等检查中，涉及强制转换的最明显地方是 == 运算符。尽管你可能对 == 有任何先入为主的看法，但它的行为是非常可预测的，确保在进行相等检查之前，两个操作数的类型匹配。

说一些可能不太明显的话：<mark>==（以及 ===）运算符总是返回一个布尔值（true 或 false），指示相等检查的结果；无论发生什么强制转换，它们永远不会返回其他值。</mark>

现在，回忆一下本章早些时候讨论的 IsLooselyEqual() 操作。其行为，以及 == 的表现，可以通过以下两个事实来直观理解：

1. 如果两个操作数的类型相同，== 的行为与 === 完全相同——IsLooselyEqual() 立即委托给 IsStrictlyEqual()。

例如，当两个操作数都是对象引用时：

```js
myObj = { a: 1 };
anotherObj = myObj;

myObj == anotherObj; // true
myObj === anotherObj; // true
```

在这里，== 和 === 确定它们各自的操作数都是对象引用类型，因此两个相等检查的行为完全相同；它们比较对象引用是否相等。

2. 但如果操作数类型不同，<mark>== 允许强制转换直到它们匹配，并偏好数字比较；</mark>它会尝试将两个操作数强制转换为数字（如果可能）：

```js
42 == "42"; // true
```

在这里，字符串 "42" 被强制转换为数字 42（而不是相反），因此比较变成了 42 == 42，显然返回 true。

掌握了这些知识后，我们现在可以消除一个常见的误解，即只有 === 检查类型和值，而 == 仅检查值。这不是真的！

实际上，<mark>== 和 === 都是对类型敏感的，各自检查其操作数的类型。== 运算符允许不匹配类型的强制转换，而 === 则不允许任何强制转换。</mark>

几乎普遍认为，== 应该避免使用，而优先使用 ===。我可能是公开倡导相反观点的唯一开发者之一。我认为人们更倾向于使用 === 的主要原因，除了遵循现状外，就是缺乏花时间真正理解 ==。

稍后在本章的“类型意识相等”部分，我将重提这一主题，以支持更倾向于使用 == 而非 ===。我只请求，无论你目前有多强烈地不同意我，请保持开放的心态。

**空值强制转换**

我们已经看到了一些 JavaScript 操作是 空值 的——<mark>将 null 和 undefined 视为强制相等</mark>，包括 ?. 可选链运算符和 ?? 空值 合并运算符（见第 1 章的“空值”）。

但 == 是 JavaScript 显示 空值 强制相等的最明显地方：

```js
null == undefined; // true
```

&zwj;<mark>null 和 undefined 永远不会被强制等于语言中的任何其他值，除了彼此</mark>。这意味着 == 使得将这两个值视为不可区分变得方便。

你可能会利用这种能力，如下所示：

```js
if (someData == null) {
  //'someData' 是 “unset” （null 或 undefined），
  // 因此，请将其设置为某个默认值
}
// OR:

if (someData != null) {
  //'someData' 是 “unset” （null 或 undefined），
  // 因此，请将其设置为某个默认值
}
```

记住，!= 是 == 的否定，而 !== 是 === 的否定。不要匹配 = 的数量，除非你想让自己困惑！

比较这两种方法：

```js
if (someData == null) {
  // ..
}

// vs:

if (someData === null || someData === undefined) {
  // ..
}
```

这两个 if 语句的行为完全相同。你更愿意写哪一个，以及你更愿意稍后阅读哪一个？

公平地说，你们中的一些人更喜欢更冗长的 === 等价物。这没问题。我不同意，我认为这个 == 版本的检查更好。而且我还认为，== 版本在风格上更一致，符合其他像 ?. 和 ?? 的 空值 运算符的行为。

但你可能还要考虑另一个小事实：在我多次运行的性能基准测试中，JavaScript 引擎可以执行单个 == null 检查，速度比两个 === 检查的组合稍快。换句话说，让 JavaScript 的 == 执行隐式的 空值 强制转换，提供了一个微小但可测量的好处，而不是试图自己明确列出两个检查。

我注意到，即使是许多死忠的 === 粉丝也倾向于承认 == null 至少是一个 == 更可取的情况。

**== 布尔陷阱**

除了我们将在下一部分讨论的一些强制转换的边缘情况外，== 最需要注意的陷阱可能与布尔值有关。

请格外关注，因为这是人们受到伤害后憎恨 == 的最大原因之一。如果你遵循我在本节末尾的简单建议，你将永远不会成为受害者！

考虑以下代码片段，假设 isLoggedIn 1 分钟前没有持有布尔值（true 或 false）：

```js
if (isLoggedIn) {
  // ..
}

// vs:

if (isLoggedIn == true) {
  // ..
}
```

我们已经覆盖了第一个 if 语句形式。我们知道 if 期望布尔值，因此在这种情况下，isLoggedIn 将通过 ToBoolean() 抽象操作中的查找表被强制转换为布尔值。这个预测相当简单，对吧？

但看看 isLoggedIn == true 表达式。你认为它会以相同的方式表现吗？

如果你的直觉是“是的”，那么你刚刚掉进了一个小陷阱。回想一下本章早些时候我警告过的 ToBoolean() 强制转换的规则，只有在 JavaScript 操作实际激活该算法时才适用。在这里，似乎 JavaScript 必须在这样做，因为 == true 看起来显然是一个“与布尔有关”的比较。

但并不是。去重新阅读本章早些时候的 IsLooselyEqual() 算法（对于 ==）。去吧，我会等你。如果你不喜欢我的总结，可以阅读规范算法本身。

好吧，你在里面看到任何提到在任何情况下调用 ToBoolean() 的内容吗？

没有！

记住：当两个 == 操作数的类型不同时，它更倾向于将它们都强制转换为数字。

如果 isLoggedIn 中的值不是布尔值，那可能是什么呢？那么它可能是一个字符串值，比如 "yes"。在这种情况下，如果 ("yes") `{ .. }` 显然会通过条件检查并执行代码块。

但 if 条件的 == 形式会发生什么？它将像这样工作：

```js
// (1)
"yes" == true;

// (2)
"yes" == 1;

// (3)
NaN == 1;

// (4)
NaN === 1; // false
```

换句话说，如果 isLoggedIn 持有像 "yes" 这样的值，if (isLoggedIn) `{ .. }` 块将通过条件检查，但 if (isLoggedIn == true) 检查将不会。呃！

如果 isLoggedIn 持有字符串 "true" 呢？

```js
// (1)
"true" == true;

// (2)
"true" == 1;

// (3)
NaN == 1;

// (4)
NaN === 1; // false
```

😢

这是个小测验：isLoggedIn 需要持有什么值，才能使这两个 if 语句的条件都通过？

...

...

...

...

如果 isLoggedIn 持有数字 1 呢？1 是真值，所以 if (isLoggedIn) 形式通过。而涉及强制转换的另一个 == 形式：

```js
// (1)
1 == true;

// (2)
1 == 1;

// (3)
1 === 1; // true
```

但如果 isLoggedIn 持有字符串 "1" 呢？同样，"1" 是真值，但那 == 强制转换又如何呢？

```js
// (1)
"1" == true;

// (2)
"1" == 1;

// (3)
1 == 1;

// (4)
1 === 1; // true
```

好的，因此 1 和 "1" 是 isLoggedIn 可以持有的两个安全值，可以与 true 安全强制转换进行 == 相等检查。但基本上几乎没有其他值可以安全地赋给 isLoggedIn。

如果检查是 == false，我们也会有类似的陷阱。这样的比较中哪些值是安全的？"" 和 0 有效。但：

```js
if ([] == false) {
  // this will run!
}
```

[] 是一个真值，但它也与 false 强制相等？！哎呀。

我们该如何看待这些与 == true 和 == false 检查相关的陷阱？我有一个简单明了的答案。

在任何情况下，绝对不要执行 == 检查，如果比较的任一侧是 true 或 false 值。它看起来好像会表现得像一个不错的 ToBoolean() 强制转换，但它狡猾地不会，并且会被卷入各种强制转换的边缘情况（将在下一部分中讨论）。同时也避免使用 === 形式。

当你处理布尔值时，请坚持使用真正激活 ToBoolean（） 的隐式强制形式，例如 if （isLoggedIn），并远离 == / === 形式。

---

### 强制转换的边缘情况

到目前为止，我在表达我对强制转换的支持意见时非常明确。这只是一个观点，虽然它是基于对语言规范和可观察的 JavaScript 行为的研究得出的事实解释。

这并不是说强制转换是完美的。我们需要意识到几个令人沮丧的边缘情况，以避免跌入这些坑洼。为了确保清楚，我接下来对这些边缘情况的描述只是我个人的观点。你的体验可能会有所不同。

**字符串**

我们已经看到数组的字符串强制转换看起来像这样：

```js
String([1, 2, 3]); // "1,2,3"
```

我个人觉得这非常烦人，因为它不包括周围的 [ ]。特别是，这导致了这个荒谬的现象：

```js
String([]); // ""
```

我们甚至无法判断它是否是一个数组，因为我们得到的只是一个空字符串？太好了，JS。这真是愚蠢。抱歉，我必须这么说。而且情况还更糟：

```js
String([null, undefined]); // ","
```

什么！？我们知道 null 变为字符串 "null"，而 undefined 变为字符串 "undefined"。但是如果这些值在数组中，它们在数组到字符串的强制转换中就神奇地消失了，只留下 "," 来暗示我们数组中确实有东西！这不是很荒谬吗？

那对象呢？几乎同样令人恼火，但方向正好相反：

```js
String({}); // "[object Object]"

String({ a: 1 }); // "[object Object]"
```

嗯... 好吧。谢谢你，JS，完全没有帮助我们理解对象的值。

**数字**

我要揭示我认为所有强制转换角落案例中最糟糕的根源。准备好了吗？！

```js
Number(""); // 0
Number("       "); // 0
```

我仍然在摇头，尽管我已经知道这件事近二十年了。我仍然不明白Brendan当初是怎么想的。

&zwj;<mark>空字符串是没有任何内容的；它没有任何可以用来确定数字表示的内容。0 绝对不是缺失/无效数字值的数字等价物。你知道我们有什么数字值适合传达这个吗？NaN。更别提在将字符串强制转换为数字时，字符串中的空白会被剥离，所以非常不空的 " " 字符串仍然在数字强制转换中被视为与 "" 相同。</mark>

更糟糕的是，回想一下 [] 强制转换为字符串 ""？由此可推：

```js
Number([]); // 0
```

哎呀！如果 "" 不强制转换为 0 —— 记住，这是所有强制转换邪恶的根源！—— 那么 [] 也不会强制转换为 0。

这简直是荒谬，颠倒宇宙的境地。

虽然更温和，但仍然略显烦人：

```js
Number("NaN"); // NaN  <--- 偶然!

Number("Infinity"); // Infinity
Number("infinity"); // NaN  <--- oops, watch case!
```

字符串 "NaN" 不会被解析为一个可识别的数字值，因此强制转换失败，意外地产生 NaN 值。"Infinity" 是明确可解析的，但其他任何大小写，包括 "infinity"，都会失败，导致再次产生 NaN。

下一个例子，你可能不会认为这是一个边缘案例：

```js
Number(false); // 0
Number(true); // 1
```

这仅仅是程序员的约定，源自那些最初没有布尔 true 和 false 值的语言，我们将 0 当作 false，1 当作 true。但反向处理真有意义吗？

想想这个：

```js
false + true + false + false + true; // 2
```

真的？我认为没有任何情况下将布尔值视为其数字等价物在程序中是合理的。我能理解反向处理的原因，出于历史原因：Boolean(0) 和 Boolean(1)。

但我真心觉得 Number(false) 和 Number(true)（以及任何隐式强制转换形式）应该产生 NaN，而不是 0 / 1。

强制转换的荒谬

为了证明我的观点，让我们把荒谬推向第11级：

```js
[] == ![]; // true
```

怎么可能！？这似乎难以置信，一个值竟然可以强制等于其否定，对吧！？

但跟随强制转换的兔子洞：

1. [] == ![]

2. [] == false

3. "" == false

4. 0 == false

5. 0 == 0

6. 0 === 0 -> true

我们有三个不同的荒谬因素在作祟：String([])，Number("")，和 Number(false)；如果其中任何一个不成立，这种荒谬的角落案例结果就不会发生。

---

### 类型意识

我们现在从各个角度切分、剖析并检查强制转换，从规范的抽象内部开始，然后移动到实际触发强制转换的具体表达和语句。

但这一切有什么意义？这一章中的细节，甚至到目前为止整本书，是否主要只是小知识？嗯，我不这么认为。

让我们回到我在本章开头提出的观察/问题。

对强制转换的看法（尤其是负面的）不乏其人。几乎普遍的看法是，强制转换是 JS 语言设计中一个主要/完全不好的部分。尽管如此，几乎每个开发者在写的几乎每个 JS 程序中都面临着强制转换无法避免的现实。

换句话说，无论你做什么，你都无法摆脱了解、理解和管理 JS 的值类型及其转换的需求。与普遍假设相反，拥抱动态类型（甚至是弱类型）语言并不意味着对类型的无视或不在乎。

类型意识的编程总是比对类型无知/无动于衷的编程要好得多。

呃... TypeScript？

此刻你肯定在想：“我为什么不能只用 TypeScript，声明我所有的类型，避免动态类型和强制转换的混淆？”

<Callout icon="💡" type="info">
  我对 TypeScript
  以及它在我们生态系统中更大角色的看法还有很多详细的想法；我会把这些观点留到附录中（“关于
  TypeScript 的想法”）。
</Callout>

让我们直接面对 TypeScript 在类型意识编程中所起的作用，以及它在这一方面的局限。

TypeScript 是静态类型的（意味着类型在作者时间声明，并在编译时检查）和强类型的（意味着变量/容器是有类型的，并且这些关联是强制的；强类型系统也不允许隐式强制转换）。TypeScript 最大的优点是，它通常强迫代码的作者和阅读者面对构成大部分（理想上是全部！）程序的类型。这绝对是好事。

相比之下，JS 是动态类型的（意味着类型在运行时被发现和管理）和弱类型的（意味着变量/容器没有类型，因此没有强制的关联，变量因此可以持有任何值类型；弱类型系统允许任何形式的强制转换）。

<Callout icon="💡" type="info">
  我在这里做了很高层次的概括，故意不深入探讨静态/动态和强/弱类型光谱上的很多细微差别。如果你此刻感到“好吧，其实...”的冲动，请稍等，我将阐明我的论点。
</Callout>

**没有 TypeScript 的类型意识**

一个动态类型的系统是否自动意味着你编程时对类型的关注更少？许多人会争辩，但我不同意。

我并不认为声明静态类型（注释，如在 TypeScript 中）是实现有效类型意识的唯一方法。显然，支持静态类型的人认为这是最好的方法。

让我举个例子，说明没有 TypeScript 的静态类型意识。考虑这个变量声明：

```js
let API_BASE_URL = "https://some.tld/api/2";
```

这个语句在任何方面都是类型意识吗？当然，API_BASE_URL 后面没有 : string 注释。但我确实认为它仍然是类型意识的！我们很清楚地看到赋值给 API_BASE_URL 的值类型（字符串）。

<Callout icon="⚠️" type="warning">
  不要被 let 声明是可重新赋值（与 const 相对）所分心。JS 的 const
  不是其类型系统的第一类特性。我们并没有因为知道 const 变量的重新赋值被 JS
  引擎禁止而获得额外的类型意识。如果代码结构良好——嗯哼，结构以类型意识为优先——我们可以很清楚地阅读代码，并清楚地看到
  API_BASE_URL
  没有被重新赋值，因此仍然是之前分配的值类型。从类型意识的角度来看，这基本上与它不能被重新赋值是一样的。
</Callout>

如果我稍后想做类似的事情：

```js
// 我们是否使用安全的 API URL?
isSecureAPI = /^https/.test(API_BASE_URL);
```

我知道正则表达式 test（..） 方法需要一个字符串，因为我知道 API_BASE_URL 保存了一个字符串，所以我知道该操作是类型安全的。

同样，由于我知道关于字符串值的 ToBoolean() 强制转换的一些简单规则，我知道这样的语句也是类型安全的：

```js
// 我们是否已确定 API URL?
if (API_BASE_URL) {
  // ..
}
```

但如果稍后我开始写类似的代码：

```js
APIVersion = Number(API_BASE_URL);
```

警报声在我脑中触发。因为我知道关于字符串值如何强制转换为数字的规则，所以我意识到这个操作不是类型安全的。因此，我以不同的方式处理它：

```js
// 从 API URL 中提取版本号
versionDigit = API_BASE_URL.match(/\/api\/(\d+)$/)[1];

// 确保版本实际上是一个数字
APIVersion = Number(versionDigit);
```

我知道 API_BASE_URL 是一个字符串，进一步知道其内容的格式包括以 `".../api/{digits}"` 结尾。这让我知道正则表达式匹配将成功，因此 [1] 数组访问是类型安全的。

我还知道 versionDigit 将持有一个字符串，因为那是正则表达式匹配返回的内容。现在，我知道将那个数字数字字符串强制转换为数字是安全的。

根据我的定义，这种思考方式和编码风格就是类型意识。类型意识编程意味着仔细考虑这些事情是否对代码的读者来说是清晰和明显的。

**与 TypeScript 的类型意识**

TypeScript 的支持者会指出，TypeScript 可以通过类型推断，在不需要任何类型注释的情况下进行静态类型（强制）检查。因此，无论我们写的是这两种方式，TypeScript 都可以处理并提供其编译时静态类型强制的风味。

换句话说，TypeScript 将为我们提供在类型检查方面的相同好处，无论我们写的是：

```ts
let API_BASE_URL: string = "https://some.tld/api/2";

// vs:

let API_BASE_URL = "https://some.tld/api/2";
```

但没有免费的午餐。我们需要面对一些问题。首先，TypeScript 在这里不会触发错误：

```js
API_BASE_URL = "https://some.tld/api/2";

APIVersion = Number(API_BASE_URL);
// NaN
```

直观上，我希望一个类型意识系统能够理解为什么这是不安全的。但也许这对我们来说太过苛求。或者也许如果我们为 API_BASE_URL 变量定义一个更狭窄/特定的类型，而不仅仅是字符串，这可能会有所帮助？我们可以使用一种 TypeScript 技巧，称为“模板字面量类型”：

```ts
type VersionedURL = `https://some.tld/api/${number}`;

API_BASE_URL: VersionedURL = "https://some.tld/api/2";

APIVersion = Number(API_BASE_URL);
// NaN
```

不，TypeScript 仍然没有看到任何问题。是的，我知道为什么会这样（Number(..) 本身是有类型的）。

<Callout icon="💡" type="info">
  我想那些非常聪明、精通 TypeScript
  的人可能会有创造性的想法，如何让我们扭曲自己以引发错误。也许甚至有十几种不同的方法可以强迫
  TypeScript 在那段代码上触发。但这并不是重点。
</Callout>

我的观点是，我们不能完全依赖 TypeScript 的类型来解决我们所有的问题，让我们可以忽视类型的细微差别，以及在这种情况下的强制转换行为。

但是！你肯定会反对这一论点，急于主张即使 TypeScript 无法理解某个特定情况，使用 TypeScript 也不会更糟！对吧！？

让我们看看 TypeScript 关于这一点的说法：

```ts
type VersionedURL = `https://some.tld/api/${number}`;

let API_BASE_URL: VersionedURL = "https://some.tld/api/2";

let versionDigit = API_BASE_URL.match(/\/api\/(\d+)$/)[1];
// Object is possibly 'null'.
```

该错误表明 [1] 访问不是类型安全的，因为如果正则表达式未能在字符串上找到任何匹配项，match(..) 将返回 null。

你看，即使我能够根据字符串的内容与正则表达式的写法进行推理，即使我努力让 TypeScript 确切了解那些特定字符串的内容，它也没有足够聪明来将这两者对齐，看到假设匹配实际上是完全类型安全的。

<Callout icon="💡" type="info">
  真的是一个类型意识工具的工作，以及最佳使用方式，是扭曲自己以表达每一个可能的类型安全的细微差别吗？我们不需要完美和通用的工具来从它们所能做的事情中获得巨大的好处。
</Callout>

而且，将上一节的代码风格与本节的代码进行比较（无论是否有注释），TypeScript 是否真的让我们的编码更具类型意识？

比如，类型 VersionedURL = .. 和 API_BASE_URL: VersionedURL 的内容是否真的让我们的代码更清晰地表现出类型意识？我不一定这么认为。

**TypeScript 智能**

是的，我听到你通过电脑屏幕对我尖叫。是的，我知道 TypeScript 提供了它发现（或推断）的类型信息到你的代码编辑器，这通过智能自动补全、帮助性的内联警告标记等形式展现出来。

但我认为，即使这些本身并不能让你作为一个开发者更具类型意识。

为什么？因为类型意识不仅仅关乎作者的体验，它也关系到阅读体验，甚至可能更为重要。而且并非所有读取代码的地方/机制都有访问所有额外智能的好处。

看看，一个语言服务器将智能注入到你的代码编辑器中，确实是令人惊叹的。这是很酷、非常有帮助的。

我并不反对 TypeScript 作为一个工具推断我的 JS 代码并通过愉快的代码编辑器集成给我提示和建议。我只是并不想为了让工具的抱怨沉默而必须以某种极其具体的方式注释类型信息。

**TypeScript 之上的门槛**

但是即使我拥有了所有这些，它仍然不足以让我在代码作者和阅读者的身份上完全具备类型意识。

这些工具无法捕捉到所有可能发生的类型错误，无论我们多么想告诉自己它们可以，无论我们经历多少复杂的类型语法技巧来希望如此。所有试图强迫和诱导工具捕捉那些细微错误的努力，最终都是... 至多是错误的努力。

而且，没有任何工具是免于误报的，它们会抱怨一些实际上并不是错误的事情；这些工具永远不会像我们人类一样聪明。你真的在追逐一些奇怪的语法技巧以平息工具的抱怨上浪费了时间。

如果你想真正成为一个类型意识的代码作者和阅读者，就必须学习语言内置类型系统的工作原理。是的，这意味着你团队中的每一个开发者都需要花时间去学习。你不能为了让较不经验丰富的开发者更容易理解而稀释这些内容。

即使我们假设你可以避免 100% 的隐式强制转换——你做不到——你绝对会面临需要显式强制转换的情况——所有程序都是如此！

如果你对此事实的反应是建议你将理解这些内容的心理负担转移给像 TypeScript 这样的工具……那么我很遗憾地告诉你，你显然在追求我所挑战的那种类型意识的标准上落后了。

我并不是在这里提倡你放弃 TypeScript。如果你喜欢它，那很好。但我非常明确而热情地向你发起挑战：停止将 TypeScript 作为拐杖。停止屈服于 TypeScript 引擎的控制。停止愚蠢地追逐每一个类型的兔子，深入每一个语法的洞穴。

根据我的观察，使用类型意识工具（如 TypeScript）与追求实际类型意识作为代码作者和阅读者之间存在一种悲惨的反向关系。你越依赖 TypeScript，似乎就越容易被诱导和鼓励将注意力从 JS 的类型系统（尤其是强制转换）转移到替代的 TypeScript 类型系统上。

不幸的是，TypeScript 永远无法完全摆脱 JS 的类型系统，因为 TypeScript 的类型在编译器中会被擦除，剩下的只是 JS，JS 引擎必须处理。

<Callout icon="💡" type="info">
  想象一下，如果有人递给你一杯过滤水喝。在你准备喝一口之前，他们说：“我们从一个废物倾倒场附近的地下抽取了这水。但别担心，我们用了一个非常好的过滤器，这水是完全安全的！”你有多信任那个过滤器？更重要的是，回到我的总体观点，在你了解水的来源、所有过滤过程以及你手中玻璃水中的一切之前，你喝这水是否会感觉更舒适！？或者说信任那个过滤器就足够了吗？
</Callout>

**类型意识的平等**

我将以一个最终的例子结束这一漫长而曲折的章节，展示我认为开发者应该如何——凭借更具批判性思维而非盲目顺应——以类型意识的方式进行编码，无论你是否使用像 TypeScript 这样的工具。

我们再次回顾平等比较（== 与 ===），从类型意识的角度来看。早些时候在本章中，我承诺将为 == 优于 === 做出论证，现在开始。

让我们总结一下我们关于 == 和 === 迄今所知的内容：

1. 如果 == 的操作数类型匹配，它的行为与 === 完全相同。

2. 如果 === 的操作数类型不匹配，它将始终返回 false。

3. 如果 == 的操作数类型不匹配，它将允许强制转换任一操作数（通常优先选择数字类型的值），直到类型最终匹配；一旦匹配，参见（1）。

好的，那么让我们分析这些事实在我们的程序中如何相互作用。

如果你像这样比较 x 和 y 的相等性：

```js
if ( /* x 和 y 是否相等 */ ) {
    // ..
}
```

我们可能处于哪些条件下，涉及 x 和 y 的类型？

1. 我们可能确切知道 x 和 y 可以是什么类型，因为我们知道这些变量是如何被赋值的。

2. 或者我们可能无法判断这些类型可能是什么。可能是 x 或 y 可能是任何类型，或者至少是几种不同类型中的任何一种，以至于比较中类型的可能组合过于复杂，难以理解/预测。

我们能否同意（1）远比（2）可取？我们还可以进一步同意（1）代表以类型意识的方式编写我们的代码，而（2）则代表显然缺乏类型意识的代码？

如果你使用 TypeScript，你很可能知道 x 和 y 的类型，对吧？即使你不使用 TypeScript，我们已经展示了你可以采取有意的步骤，以使你的代码以某种方式编写，使 x 和 y 的类型是已知且明显的。

**（2）未知类型**

如果你处于场景 (2)，我会断言你的代码处于问题状态。你的代码不理想。你的代码需要重构。如果你发现代码处于这种状态，最好的做法是……修复它！

将代码更改为类型意识。如果这意味着使用 TypeScript，甚至插入一些类型注释，那就这样做。或者如果你觉得只用 JS 就能达到类型意识的状态，那就这样做。无论哪种方式，尽你所能达到场景 (1)。

如果你无法确保在 x 和 y 之间进行这种相等性比较的代码是类型意识的，并且你没有其他选择，那么你绝对必须使用 === 严格相等运算符。不这样做将是极其不负责任的。

```js
if (x === y) {
  // ..
}
```

如果你对类型一无所知，你怎么可能（或任何未来阅读你代码的人）知道 == 中的强制步骤将如何表现！？你无法知道。

唯一负责任的做法是，避免强制转换并使用 ===。

但不要忽视这一事实：你只有在代码如此缺乏类型意识——咳咳，类型损坏！——以至于没有其他选择时，才选择 ===。

(1) 已知类型
好的，现在我们假设你处于场景 (1)。你知道 x 和 y 的类型。在代码中，这些参与相等性检查的特定类型非常清晰。

太好了！

但你仍然可能处于两个子条件中：

- (1a)：x 和 y 可能已经是相同的类型，无论是字符串、数字等。

- (1b)：x 和 y 可能是不同的类型。

让我们分别考虑这两种情况。

**(1a) 已知匹配类型**

如果相等性比较中的类型匹配（无论它们是什么），我们已经可以确定 == 和 === 完全相同。没有任何区别。

除了，== 短了一位字符。大多数开发者本能地觉得，最简洁但等价的版本通常是最可取的。当然，这不是普遍的，但至少是一种一般偏好。

```js
// this is best
if (x == y) {
  // ..
}
```

在这个特殊的例子中，一个额外的代码对我们使代码更清晰没有任何帮助。事实上，这只会让比较变得更糟!

```js
// 这绝对更糟糕！!
if (x === y) {
  // ..
}
```

为什么这更糟？

因为在场景 (2) 中，我们已经确定，当我们对类型不够了解/一无所知时，使用 === 是最后的选择。我们使用 === 是为了确保避免强制转换，而我们知道可能会发生强制转换。

但这不适用于这里！我们已经知道不会发生强制转换。没有理由在这里用 === 来混淆读者。如果你在一个已经知道类型的地方使用 ===，而且更重要的是，它们是匹配的！这实际上可能会给读者发送混合信号。他们可能会假设他们知道相等性检查会如何进行，但看到 === 后，他们会对自己产生怀疑！

再说一遍，<mark>如果你知道相等性比较的类型，并且你知道它们匹配，唯一正确的选择是：==。</mark>

```js
// 坚持此选项
if (x == y) {
  // ..
}
```

**(1b) 已知不匹配类型**

好的，现在我们进入最后一个场景。我们需要比较 x 和 y，并且我们知道它们的类型，但我们也知道它们的类型不是相同的。

在这种情况下，我们应该使用哪个运算符？

如果你选择 ===，你就犯了一个大错误。为什么！？因为对于已知不匹配的类型，使用 === 将永远不会返回 true。它将始终失败。

```js
// 'x' 和 'y' 有不同的类型?
if (x === y) {
  // 恭喜，这里的这段代码永远不会运行
}
```

好的。那么，当类型已知且不匹配时，=== 被排除了。我们的唯一选择是什么？

实际上，我们又有两个选项。我们可以决定：

- (1b-1)：让我们更改代码，这样我们就不再尝试用已知不匹配的类型进行相等性检查；这可能涉及显式强制其中一个或两个值，使它们的类型现在匹配，在这种情况下回到场景 (1a)。

- (1b-2)：如果我们要比较已知不匹配的类型，且我们希望这个检查有任何希望通过，我们必须使用 ==，因为它是唯一能够强制一个或两个操作数，直到类型匹配的相等运算符。

```js
/* 
'x' 和 'y' 有不同的类型，
所以让我们让 JS 来强制他们
用于相等比较 
*/
if (x == y) {
  // .. (所以，你是说有机会吗？?)
}
```

就这样。我们结束了。我们已经查看了所有可能的类型敏感相等比较条件（在 x 和 y 之间）。

**总结类型敏感相等比较**

始终偏好 == 而不是 === 的理由如下：

1. 无论你是否使用 TypeScript——但尤其是如果你使用 TypeScript——目标应该是让代码的每一个部分，包括所有相等性比较，都具备类型意识。

2. 如果你知道类型，你应该始终偏好 ==。

   - 在类型匹配的情况下，== 既较短又更适合这个检查。

   - 在类型不匹配的情况下，== 是唯一一个能够强制操作数，直到类型匹配的运算符，因此这是唯一能够使此检查有希望通过的方式。

3. 最后，只有在你由于某种令人沮丧的原因无法知道/预测类型，并且没有其他选择时，才退而求其次使用 === 作为最后的选择。并且可能在那里添加代码注释，承认为什么使用 ===，并可能提示未来的开发者稍后更改代码，以修复这一缺陷并移除 === 的依赖。

**TypeScript 的不一致问题**

让我非常清楚地说：如果你正确使用 TypeScript，并且你知道相等比较的类型，那么使用 === 进行那种比较就是错误的！没错。

问题是，TypeScript 奇怪且令人沮丧的是，仍然要求你使用 ===，除非它已经知道类型是匹配的。

这因为 TypeScript 要么完全不理解类型意识和强制转换，要么——这甚至更让人恼火！——它完全理解，但仍然如此厌恶 JS 的类型系统，以至于甚至抛弃最基本的类型意识推理。

你不信我？觉得我太苛刻？试试在 TypeScript 中：

```ts
let result = 42 == "42";
// 此条件将始终返回 'false'，因为
// 类型 'number' 和 'string' 没有重叠。
```

我无言以对来形容这让我多么恼火。如果你关注这一长而重的章节，你会知道 TypeScript 在这里基本上是在撒谎。当然，42 == "42" 在 JS 中会返回 true。

好吧，这不是谎言，但它揭示了一个许多人仍未完全理解的基本真理：TypeScript 完全抛弃了 JS 类型系统的正常规则，因为 TypeScript 的立场是，JS 的类型系统——尤其是隐式强制——是糟糕的，需要被替代。

在 TypeScript 的世界中，42 和 "42" 永远不能相等。因此会出现错误消息。但在 JS 的世界中，42 和 "42" 是绝对强制相等的。我相信我在这里已经做出了一个有力的论证，认为它们应该被认为是安全的强制等价。

更让我烦恼的是，TypeScript 在这方面有各种不一致之处。TypeScript 对于以下代码中的隐式强制是完全可以接受的：

```ts
irony = `The value '42' and ${42} are coercively equal.`;
```

该 42 在插入句子时被隐式强制为字符串。为什么 TypeScript 对这种隐式强制感到没问题，而对 42 == "42" 的隐式强制却不行？

TypeScript 对这段代码也没有抱怨：

```js
API_BASE_URL = "https://some.tld/api/2";
if (API_BASE_URL) {
  // ..
}
```

为什么 ToBoolean() 是一个可以接受的隐式强制，而在 == 算法中的 ToNumber() 却不行？

我留给你思考：你真的认为写的代码最终将在 JS 引擎中运行，但使用一个有意抛弃了整个 JS 语言支柱的大部分工具和代码风格是个好主意吗？而且，仅仅为了迎合 JS 开发者的旧习惯，它在各种不一致的例外中翻转，是可以接受的吗？

---

### 剩下的是什么？

我希望到现在为止，你对 JS 的类型系统如何运作有了更多的了解，从原始值类型到对象类型，再到引擎如何执行类型强制。

更重要的是，你现在对使用 JS 的类型系统进行选择的利弊有了更完整的认识，比如在不同的时刻选择隐式或显式强制。

但我们还没有完全覆盖类型系统运作的上下文。在本书的剩余部分，我们将转向 JS 的语法/语法规则，这些规则支配着运算符和语句的行为。
