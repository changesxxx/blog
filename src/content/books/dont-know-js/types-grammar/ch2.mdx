---
title: "原始值的行为"
description: "到目前为止，我们已经探索了 JS 中七种内置原始值类型：null、undefined、boolean、string、number、bigint 和 symbol。第一章的内容相当多，远比大多数读者预期的要复杂。如果您在阅读完这些内容后仍在恢复，不用担心，可以先休息一下再继续！一旦您清醒并准备好继续，我们就来深入研究这些值类型所隐含的某些行为。我们将仔细观察这些各种行为。"

name: "types-grammar-ch2"
---
### 原始值的不可变性

&zwj;<mark>所有原始值都是不可变的，这意味着在 JS 程序中没有任何东西可以进入值的内容并以任何方式修改它。</mark>

```js 
myAge = 42;

// later:

myAge = 43;
```

myAge = 43 语句并没有改变值。它将不同的值 43 重新分配给 myAge，完全替换了之前的值 42。

新的值也是通过各种操作创建的，但同样这些并不修改原始值：

```js 
42 + 1;             // 43

"Hello" + "!";      // "Hello!"
```

值 43 和 "Hello!" 是与之前的 42 和 "Hello" 值完全不同的新值。

即使是字符串值，看起来仅仅是一个字符数组——而数组内容通常是可变的——实际上也是不可变的：

```js 
greeting = "Hello.";

greeting[5] = "!";

console.log(greeting);      // Hello.
```


<Callout icon="⚠️" type="warning">
在非严格模式下，赋值给只读属性（如 greeting[5] = ..）会静默失败。在严格模式下，禁止的赋值会抛出异常。
</Callout>


&zwj;<mark>原始值不可变的特性不会因持有值的变量或对象属性的声明方式而受到影响。例如，无论使用 const、let 还是 var 声明上述的 greeting 变量，它所持有的字符串值都是不可变的。</mark>

{/* todo */}
const 并不会创建不可变值，它声明的是不能重新分配的变量（即不可变赋值）——有关更多信息，请参见本系列的《作用域与闭包》一书。

对象的属性可以被标记为只读——具有 writable: false 描述符属性，如本系列的《对象与类》一书中讨论的。但这对值的性质没有影响，仅仅是防止属性的重新分配。

**带属性的原始值？**

此外，任何原始值都不能添加属性：

```js 
greeting = "Hello.";

greeting.isRendered = true;

greeting.isRendered;        // undefined

```

这个代码片段看起来像是给 greeting 的值添加了一个属性 isRendered，但这个赋值静默失败（即使在严格模式下也是如此）。

对空原始值 null 和 undefined 的属性访问是完全不允许的。但可以访问所有其他原始值的属性——是的，这听起来有点违反直觉。

例如，所有字符串值都有一个只读的 length 属性：

```js 
greeting = "Hello.";

greeting.length; 
```

length 不能被设置，但可以被访问，它揭示了存储在值中的代码单元数量（参见第一章中的“JS 字符编码”），这通常意味着字符串中的字符数量。


<Callout icon="💡" type="info">
在某种程度上。对于大多数标准字符，这是真的；一个字符是一个代码点，即一个代码单元。然而，如第一章所解释的，超出代码点 65535 的扩展 Unicode 字符将作为两个代码单元（代理对）存储。因此，对于这样的每个字符，length 会在计数中包含 2，尽管该字符在视觉上打印为一个symbol。
</Callout>

非空原始值还有几个可以访问的标准内置方法：

```js 
greeting = "Hello.";

greeting.toString();    // "Hello." <-- redundant
greeting.valueOf();     // "Hello."
```

此外，大多数原始值类型定义了它们自己的方法，具有该类型固有的特定行为。我们将在本章后面讨论这些。

<Callout icon="💡" type="info">
正如在第一章中简要提到的，这种对原始值的属性/方法访问实际上是通过一种隐式的强制行为称为自动装箱（auto-boxing）来实现的。我们将在第三章的“自动对象”中详细讨论这一点。
</Callout>

---

### 原始值赋值

将原始值从一个变量/容器赋值到另一个变量是值的拷贝：

```js 
myAge = 42;

yourAge = myAge;        // 分配 值复制

myAge;                  // 42
yourAge;                // 42
```

在这里，myAge 和 yourAge 变量各自拥有数字值 42 的副本。

<Callout icon="💡" type="info">
在 JS 引擎内部，可能只有一个 42 值存在于内存中，且引擎将 myAge 和 yourAge 变量指向共享的值。由于原始值是不可变的，因此 JS 引擎这样做没有危险。但对我们作为 JS 开发者来说，重要的是，在我们的程序中，myAge 和 yourAge 的行为就像它们拥有自己副本的值，而不是共享它。
</Callout>

如果我们稍后将 myAge 重新赋值为 43（当我过生日时），这不会影响仍然赋值为 42 的 yourAge。
```js 
myAge++;            // sort of like: myAge = myAge + 1

myAge;              // 43
yourAge;            // 42 <-- unchanged
```

---

### 字符串行为

字符串值具有许多特定的行为，每个 JS 开发者都应该了解。

**字符访问**

虽然字符串实际上不是数组，但 JS 允许通过 [ .. ] 进行数组样式的访问，获取指定数字（0 基础）索引位置的字符：

```js 
greeting = "Hello!";

greeting[4];            // "o"
```

如果 [ .. ] 中的值/表达式无法解析为数字，该值将隐式强制转换为其整体/整数数值（如果可能）。

```js 
greeting["4"];          // "o"
```

如果值/表达式解析为超出整数范围的数字（0 - length - 1）或为 NaN，或者如果它不是数字值类型，则该访问将被视为字符串等效属性名称的属性访问。如果属性访问因此失败，结果将是 undefined。


<Callout icon="💡" type="info">
稍后我们将深入讨论强制转换。
</Callout>


**字符迭代**

字符串不是数组，但在许多方面确实与数组非常相似。其中一个行为是，像数组一样，字符串是可迭代的。这意味着字符串的字符（代码单元）可以单独迭代：

```js 
myName = "Kyle";

for (let char of myName) {
    console.log(char);
}
// K
// y
// l
// e

chars = [ ...myName ];
chars;
// [ "K", "y", "l", "e" ]
```

{/* todo */}
诸如字符串和数组这样的值是可迭代的（通过 ...、for..of 和 Array.from(..)），如果它们在特殊符号属性位置 Symbol.iterator 上暴露了一个生成迭代器的方法（参见第一章中的“知名符号”）：

```js 
myName = "Kyle";
it = myName[Symbol.iterator]();

it.next();      // { value: "K", done: false }
it.next();      // { value: "y", done: false }
it.next();      // { value: "l", done: false }
it.next();      // { value: "e", done: false }
it.next();      // { value: undefined, done: true }
```


<Callout icon="💡" type="info">
迭代器协议的具体细节，包括 `{ value: "e" .. } `结果仍然显示 done: false 的事实，在本系列的《同步与异步》中有详细介绍。
</Callout>


**长度计算**

如第一章所提到的，字符串值具有一个 length 属性，自动暴露字符串的长度；该属性只能被访问，尝试设置它会被静默忽略。

报告的长度值在某种程度上对应于字符串中的字符数量（实际上是代码单元），但正如我们在第一章中所看到的，当涉及 Unicode 字符时，这会更复杂。

大多数人视觉上将符号区分为独立的字符；这种独立视觉符号的概念被称为字形（grapheme）或字形簇（grapheme cluster）。因此，当计算字符串的“长度”时，我们通常意味着我们在计算字形的数量。

但计算机处理字符的方式并非如此。

在 JS 中，每个字符是一个代码单元（16 位），其代码点值在 65535 或以下。字符串的 length 属性始终计算字符串值中的代码单元数量，而不是代码点。代码单元可能单独代表一个字符，或者可能是代理对的一部分，或者可能与相邻的组合符号组合在一起，或是字形簇的一部分。因此，length 并不匹配计算可视字符/字形的典型概念。

为了更接近字符串的预期/直观的字形长度，字符串值首先需要通过 normalize("NFC") 进行标准化（参见第一章中的“标准化 Unicode”），以生成任何组合代码单元（在可能的情况下），以防某些字符最初以分解的形式存储为单独的代码单元。

例如：

```js 
favoriteItem = "teléfono";
favoriteItem.length;            // 9 -- uh oh!

favoriteItem = favoriteItem.normalize("NFC");
favoriteItem.length;            // 8 -- phew!
```

不幸的是，正如我们在第一章中所看到的，我们仍然可能遇到代码点大于 65535 的字符，因此需要用代理对来表示。这类字符在长度计算中将被计为双倍：

```js 
// "☎" === "\u260E"
oldTelephone = "☎";
oldTelephone.length;            // 1

// "📱" === "\u{1F4F1}" === "\uD83D\uDCF1"
cellphone = "📱";
cellphone.length;               // 2 -- oops!
```

那么我们该怎么办？

一种解决方法是使用字符迭代（通过 ... 运算符），正如我们在前一节中看到的，因为它会自动返回代理对中的每个组合字符：

```js 
cellphone = "📱";
cellphone.length;               // 2 -- oops!
[ ...cellphone ].length;        // 1 -- phew!
```

但不幸的是，字形簇（如第一章所解释的）又给字符串的长度计算带来了麻烦。例如，如果我们将拇指向下的表情符号`（"\u{1F44E}"）`与中等偏暗肤色的修饰符`（"\u{1F3FE}"）`结合在一起，我们得到：
```js 
// "👎🏾" = "\u{1F44E}\u{1F3FE}"
thumbsDown = "👎🏾";

thumbsDown.length;              // 4 -- oops!
[ ...thumbsDown ].length;       // 2 -- oops!
```

正如您所看到的，这两个是不同的代码点（而不是代理对），由于它们的顺序和相邻性，导致计算机的 Unicode 渲染绘制出拇指向下的符号，但肤色比默认的更暗。因此，计算出的字符串长度是 2。

要能够识别这些代码点簇作为长度计算的单个“字符”，几乎需要复制大多数平台复杂的 Unicode 渲染逻辑。有些库声称可以做到这一点，但它们并不一定完美，并且在额外代码方面的成本很高。



<Callout icon="💡" type="info">
作为 Twitter 用户，您可能期望能够在单条推文中放入 280 个拇指向下的表情符号，因为它看起来像一个单一的字符。Twitter 将 "👎"（默认拇指向下）、"👎🏾"（中等偏暗肤色拇指向下），甚至 "👩‍👩‍👦‍👦"（家庭表情符号字形簇）都各算作 2 个字符，尽管从 JS 的角度，它们各自的字符串长度是 2、4 和 7；因此，您只能在推文中放入一半的表情符号（140 而不是 280）。实际上，Twitter 在 2018 年实施了这一变化，专门将所有 Unicode 字符的计数标准化为每个符号 2 个字符。对于 Twitter 用户来说，这是一项受欢迎的改变，尤其是那些希望使用最能代表预期性别、肤色等的表情符号的用户。尽管如此，Twitter 选择将所有 Unicode/表情符号算作每个 2 个字符，而不是更直观的每个 1 个字符（字形），这仍然令人好奇。
</Callout>


计算字符串的长度以匹配我们人类的直觉是一个相当具有挑战性的任务，或许更像是一种艺术而不是科学。在许多情况下，我们可以获得可接受的近似值，但还有很多其他情况可能会困扰我们的程序。

**国际化（i18n）和本地化（l10n）**

为了满足 JS 程序在任何国际语言/文化环境中按预期运行的日益增长的需求，ECMAScript 委员会还发布了 ECMAScript [国际化 API](https://402.ecma-international.org/9.0/)。

JS 程序根据运行程序的环境（如网页浏览器页面、Node 实例等）默认为一个区域/语言。生效的区域会影响排序（和数值比较）、格式化及其他几种假定行为。这种改变的行为在字符串上可能更为明显，但在数字（和日期）上也可以看到！

但字符串字符也可以嵌入语言/区域信息，这优先于环境默认设置。如果字符串字符在其语言/区域上是模糊的/共享的（例如 "a"），则使用默认环境设置。

根据字符串的内容，它可能被解读为从左到右（LTR）或从右到左（RTL）排序。因此，我们稍后将讨论的许多字符串方法在其名称中使用逻辑描述符，如“开始”、“结束”、“开头”、“末尾”和“最后”，而不是方向性术语如“左”和“右”。

例如，希伯来语和阿拉伯语都是常见的 RTL 语言：

```js 
hebrewHello = "\u{5e9}\u{5dc}\u{5d5}\u{5dd}";

console.log(hebrewHello);                       // שלום
```

注意，在字符串字面量中的第一个字符`（"\u{5e9}"）`在字符串渲染时实际上是最右边的字符？

尽管希伯来语是 RTL 语言，但您实际上并不会以相反（RTL）顺序输入字符串字面量中的字符。您以逻辑顺序输入字符，其中位置 0 是第一个字符，位置 1 是第二个字符，依此类推。渲染层是将 RTL 字符反向显示为正确的顺序。

这也意味着，如果您访问 hebrewHello[0]（或 hebrewHello.charAt(0)）——以获取位置 0 的字符——您将得到 "ש"，因为这在逻辑上是字符串的第一个字符，而不是 "ם"（逻辑上是字符串的最后一个字符）。索引位置访问遵循逻辑位置，而不是渲染位置。

这是另一个 RTL 语言（阿拉伯语）的相同示例：

```js 
arabicHello = "\u{631}\u{62d}\u{628}\u{627}";

console.log(arabicHello);                       // رحبا

console.log(arabicHello[0]);                    // ر
```

JS 程序可以使用各种 Intl API 强制指定语言/区域，例如 [Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator)：

多个单词的字符串可以使用 [Intl.Segmenter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter) 进行分段：

```js 
arabicHelloWorld = "\u{645}\u{631}\u{62d}\u{628}\u{627} \
\u{628}\u{627}\u{644}\u{639}\u{627}\u{644}\u{645}";

console.log(arabicHelloWorld);      // مرحبا بالعالم

arabicSegmenter = new Intl.Segmenter("ar",{ granularity: "word" });

for (
    let { segment: word, isWordLike } of
    arabicSegmenter.segment(arabicHelloWorld)
) {
    if (isWordLike) {
        console.log(word);
    }
}
// مرحبا
//لعالم
```

<Callout icon="💡" type="info">
该 segment(..) 方法（来自 Intl.Segmenter 的实例）返回一个标准的 JS 迭代器，这里通过 for..of 循环进行消费。有关迭代协议的更多信息，请参见本系列的《同步与异步》。
</Callout>

**字符串比较**

字符串值可以使用各种内置操作符与其他字符串值进行比较（包括相等和关系排序）。重要的是要记住，这种比较对实际字符串内容非常敏感，特别是来自非 BPM Unicode 字符的底层代码点。

无论对于大小写字符，等号 (===) 和双等号 (==) 的比较都是大小写敏感的。要进行不区分大小写的比较，首先要规范化这两个值的大小写（使用 toUpperCase() 或 toLowerCase()）。

**字符串相等性**

=== 和 == 操作符（以及它们的否定对应符 !== 和 !=）是比较原始值（包括字符串值）最常用的方式：

```js 
"my name" === "my n\x61me";               // true

"my name" !== String.raw`my n\x61me`;     // true
```

=== [操作符](https://262.ecma-international.org/13.0/#sec-islooselyequal)——通常称为“严格相等”——首先检查类型是否匹配，如果不匹配，立即返回 false。如果类型匹配，则检查值是否相同；对于字符串来说，这是从开始到结束的逐代码单元比较。

尽管有“严格”这个名称，但 === 仍然有一些细微差别（例如 -0 和 NaN 的处理），我们稍后会详细讨论。

**强制相等性**

相对而言，== 操作符——通常称为“宽松相等”——执行强制相等：如果两个操作数的值类型不匹配，== 首先会强制一个或两个操作数，直到值类型匹配，然后内部将比较交给 === 处理。

强制转换是一个极其重要的话题——它是 JS 类型系统的一个固有部分，是语言的三大支柱之一——但我们只会在本章简要介绍，稍后会详细回顾。

注意：


<Callout icon="💡" type="info">
您可能听过这样一种常见但不准确的解释，认为 == 和 === 之间的区别在于 == 比较值，而 === 则比较值和类型。实际上并非如此，您可以自己查看规范以验证——isStrictlyEqual(..) 和 isLooselyEqual(..) 规范算法在前面的段落中作为脚注链接。总结一下：== 和 === 都对操作数的类型敏感。如果操作数类型相同，这两个操作符实际上执行的是完全相同的操作；如果类型不同，== 会强制转换直到类型匹配，而 === 则会立即返回 false。
</Callout>

开发者常常认为 == 操作符令人困惑，并且在使用时容易出现意外（因此几乎普遍偏好 ===）。我认为这种看法完全错误，实际上，JS 开发者应该默认使用 ==（并尽可能避免 ===）。但是，我们需要更多的讨论来支撑这样一个有争议的观点；请您在稍后讨论时再表达异议。

现在，为了对 == 的强制性质有一些直观了解，最有启发性的一点是，&zwj;<mark>如果类型不匹配，== 更倾向于进行数值比较。这意味着它会尝试将两个操作数都转换为数字，然后进行相等检查（与 === 相同）。</mark>

因此，与我们当前的讨论相关，只有在两个操作数都是字符串时，实际的字符串相等性才能得到检查：

```js 
//实际字符串相等性检查（通过 === 内部）:
"42" == "42";           // true
```

== 并不真正执行字符串相等性检查。如果操作数的值类型都是字符串，== 只是将比较交给 ===。如果它们不是字符串，== 中的强制步骤将使比较匹配降到数值而不是字符串：

```js 
// numeric (not string!) 相等性检查:
42 == "42";             // true
```

我们稍后会在本章中讨论数值相等性。

真正严格的相等性

除了 == 和 ===，JS 还提供了 Object.is(..) 工具，如果两个参数完全相同，则返回 true，否则返回 false（没有例外或细微差别）：

```js 
Object.is("42",42);             // false

Object.is("42","\x34\x32");     // true
```

由于 === 在 == 的基础上增加了一个 = 使其行为更严格，我开玩笑地说 Object.is(..) 工具就像一个 ====（再增加一个 =）操作符，用于真正严格、没有例外的相等性检查！

话虽如此，在比较两个实际已经存在的字符串值时，===（和由于其内部委托给 === 的 ==）的行为非常可预测，没有奇怪的例外。我强烈建议在这种检查中使用 ==（或 ===），将 Object.is(..) 保留给特殊情况（主要是数值）。

**字符串关系比较**

除了字符串之间的相等性检查，JS 还支持原始值之间的关系比较，如字符串的 `<`、`<=`、`>` 和 `>=`。

`<`（小于）和 `>`（大于）操作比较两个字符串值的字典序——就像您在字典中排序单词一样，因此应该相当容易理解：

```js 
"hello" < "world";          // true
```

<Callout icon="💡" type="info">
如前所述，运行中的 JS 程序有一个默认区域，这些操作符根据该区域进行比较。
</Callout>


与 `==` 一样，`<` 和 `>` 操作符是数值强制的。任何非数字值都会被强制转换为数字。因此，进行字符串的关系比较的唯一方法是确保两个操作数都是字符串值。

或许有点令人惊讶的是，`<` 和 `>` 没有像 `===` 那样避免 `==` 强制转换的严格比较等价物。这些操作符在类型不匹配时总是强制的，而在 JS 中没有方法可以避免这一点。

那么，当两个值看起来是数字字符串时会发生什么？

```js 
"100" < "11";               // true
```

在数值上，当然，100 应该不小于 11。

但是两个字符串之间的关系比较使用字典序。因此，"100" 中的第二个 "0" 字符小于 "11" 中的第二个 "1"，因此 "100" 会在字典中排在 "11" 之前。<mark>关系操作符只有在操作数类型不都是字符串时才会强制转换为数字。</mark>

`<=`（小于等于）和 `>=`（大于等于）操作符实际上是复合检查的简写。

```js 
"hello" <= "hello";                             // true
("hello" < "hello") || ("hello" == "hello");    // true

"hello" >= "hello";                             // true
("hello" > "hello") || ("hello" == "hello");    // true
```


<Callout icon="💡" type="info">
这里有一个有趣的规范细微差别：JS 实际上并没有定义底层的“大于”（>）或“大于等于”（>=）操作。相反，它通过将参数反转为其小于补充对应物来定义它们。因此，`x > y` 本质上被 JS 视为 `y <= x`，而 `x >= y` 本质上被视为 `y < x`。因此，JS 只需要指定 `<` 和 `==` 的工作方式，从而获得 `>` 和 `>=` 的免费使用权！
</Callout>

**语言敏感的关系比较**

正如我刚才提到的，关系操作符假设并使用当前有效的区域。然而，有时强制使用特定的区域进行比较是有用的（例如，在对字符串列表进行排序时）。

JS 为此提供了 localeCompare(..) 方法：

```js 
"hello".localeCompare("world");
// -1 (or negative number)

"world".localeCompare("hello","en");
// 1 (or positive number)

"hello".localeCompare("hello","en",{ ignorePunctuation: true });
// 0

// examples from MDN:
//
// in German, ä sorts before z
"ä".localeCompare("z","de");
// -1 (or negative number) // a negative value

// in Swedish, ä sorts after z
"ä".localeCompare("z","sv");
// 1 (or positive number)
```

localeCompare(..) 的可选第二和第三个参数通过 Intl.Collator API 控制使用哪个区域，如前所述。

您可以在对字符串数组进行排序时使用 localeCompare(..)：

```js 
studentNames = [
    "Lisa",
    "Kyle",
    "Jason"
];

// Array::sort() mutates the array in place
studentNames.sort(function alphabetizeNames(name1,name2){
    return name1.localeCompare(name2);
});

studentNames;
// [ "Jason", "Kyle", "Lisa" ]
```

但如前所述，使用 Intl.Collator 直接进行排序是一种更直接的方式（在排序许多字符串时更高效）：

```js 
studentNames = [
    "Lisa",
    "Kyle",
    "Jason"
];

nameSorter = new Intl.Collator("en");

// Array::sort()就地更改数组
studentNames.sort(nameSorter.compare);

studentNames;
// [ "Jason", "Kyle", "Lisa" ]
```

**字符串连接**

两个或更多字符串值可以使用 + 操作符连接（组合）成一个新的字符串值：

```js 
greeting = "Hello, " + "Kyle!";

greeting;               // Hello, Kyle!
```

该 + 操作符将作为字符串连接，<mark>如果两个操作数中的任何一个（操作符左右两侧的值）已经是字符串（甚至是空字符串 ""）。</mark>

&zwj;<mark>如果一个操作数是字符串而另一个不是，非字符串的那个操作数将被强制转换为其字符串表示形式，以便进行连接：</mark>

```js 
userCount = 7;

status = "There are " + userCount + " users online";

status;         // There are 7 users online
```

{/* todo */}
这种类型的字符串连接本质上是将数据插入字符串中，这也是模板字面量的主要目的（见第一章）。因此，以下代码将产生相同的结果，但通常被认为是更优先的做法：

```js 
userCount = 7;

status = `There are ${userCount} users online`;

status;         // There are 7 users online
```

字符串连接的其他选项包括 "one".concat("two","three") 和 [ "one", "two", "three" ].join("")，但这些方法只有在要连接的字符串数量依赖于运行时条件或计算时才更可取。如果字符串有固定/已知的内容，如上所述，模板字面量是更好的选择。

**字符串值方法**

字符串值提供了一整套额外的字符串特定方法（作为属性）：

- charAt(..)：在指定数字索引处生成一个新的字符串值，类似于 [ .. ]；与 [ .. ] 不同，结果始终是一个字符串，要么是位置 0 的字符（如果是有效数字且在索引范围之外），要么是空字符串 ""（如果缺失/无效索引）。

- at(..)：与 charAt(..) 类似，但负索引从字符串的末尾向后计数。

- charCodeAt(..)：返回指定索引处的数字代码单元（见第一章中的“JS 字符编码”）。

- codePointAt(..)：从指定索引处返回整个代码点；如果找到了代理对，则返回整个字符（代码点）。

- substr(..) / substring(..) / slice(..)：生成一个新的字符串值，表示原始字符串中的字符范围；这些方法在指定或确定范围的起止索引方式上有所不同。

- toUpperCase()：生成一个新的字符串值，所有字符均为大写。

- toLowerCase()：生成一个新的字符串值，所有字符均为小写。

- toLocaleUpperCase() / toLocaleLowerCase()：使用区域映射进行大写或小写操作。

- concat(..)：生成一个新的字符串值，该值是原始字符串和所有传入的字符串值参数的连接。

- indexOf(..)：在原始字符串中搜索字符串值参数，可选择从第二个参数指定的位置开始；如果找到，则返回基于 0 的索引位置，如果未找到，则返回 -1。

- lastIndexOf(..)：类似于 indexOf(..)，但从字符串的末尾开始（在 LTR 区域中从右开始，在 RTL 区域中从左开始）。

- includes(..)：类似于 indexOf(..)，但返回布尔结果。

- search(..)：类似于 indexOf(..)，但使用指定的正则表达式进行匹配。

- trimStart() / trimEnd() / trim()：生成一个新的字符串值，去除字符串开头（在 LTR 区域中是左侧，在 RTL 区域中是右侧）、字符串结尾（在 LTR 区域中是右侧，在 RTL 区域中是左侧）或两者的空格。

- repeat(..)：生成一个新字符串，原始字符串值重复指定的次数。

- split(..)：在指定的字符串或正则表达式边界处生成一个字符串值数组。

- padStart(..) / padEnd(..)：生成一个新的字符串值，对左侧（LTR 区域中的左侧，RTL 区域中的右侧）或右侧（LTR 区域中的右侧，RTL 区域中的左侧）应用填充（默认为空格 " "，但可以覆盖），使最终字符串结果至少达到指定长度。

- startsWith(..) / endsWith(..)：检查原始字符串的开始（LTR 区域中的左侧，RTL 区域中的右侧）或结束（LTR 区域中的右侧）是否包含字符串值参数；返回布尔结果。

- match(..) / matchAll(..)：返回与原始字符串的正则表达式匹配结果的类数组。

- replace(..)：返回一个新字符串，替换原始字符串中匹配指定正则表达式的一个或多个匹配项。

- normalize(..)：对内容执行 Unicode 标准化，生成新的字符串（见第一章中的“Unicode 标准化”）。

- localeCompare(..)：函数，根据当前区域比较两个字符串（对排序有用）；如果原始字符串值在字典序上排在参数字符串值前面，返回负数（通常为 -1，但不保证），如果原始字符串值在字典序上排在参数字符串值后面，返回正数（通常为 1，但不保证），如果两个字符串相同，则返回 0。

- anchor()、big()、blink()、bold()、fixed()、fontcolor()、fontsize()、italics()、link()、small()、strike()、sub() 和 sup()：历史上，这些在生成 HTML 字符串片段中是有用的；现在已被弃用，应避免使用。


<Callout icon="⚠️" type="warning">
上述许多方法依赖于位置索引。如前面“长度计算”一节所述，这些位置依赖于字符串值的内部内容，这意味着如果存在扩展 Unicode 字符并占用两个代码单元，那么这将计为两个索引位置，而不是一个。未考虑分解的代码单元、代理对和字形簇是 JS 字符串处理中的常见错误来源。
</Callout>


这些字符串方法可以直接在字面量值上调用，或在持有字符串值的变量/属性上调用。在适用时，它们会生成一个新字符串值，而不是修改现有的字符串值（因为字符串是不可变的）：

```js 
"all these letters".toUpperCase();      // ALL THESE LETTERS

greeting = "Hello!";
greeting.repeat(2);                     // Hello!Hello!
greeting;                               // Hello!
```

**静态字符串助手**

以下字符串实用函数直接提供在 String 对象上，而不是作为单独字符串值的方法：

- String.fromCharCode(..) / String.fromCodePoint(..)：根据一个或多个表示代码单元（fromCharCode(..)）或整个代码点（fromCodePoint(..)）的参数生成字符串。

- String.raw(..)：一个默认模板标签函数，允许在模板字面量上进行插值，但防止字符转义序列被解析，因此它们保持在字面量中的原始输入字符。

此外，通过将大多数值（尤其是原始值）传递给 String(..) 函数（不带 new 关键字），可以显式将其强制转换为字符串等效值。例如：

```js 
String(true);           // "true"
String(42);             // "42"
String(Infinity);       // "Infinity"
String(undefined);      // "undefined"
```

我们将在后面的章节中详细讨论这种类型的强制转换。

---

### 数字行为

数字在我们的程序中用于多种任务，但主要是用于数学计算。请密切关注 JS 数字的行为，以确保结果符合预期。

**浮点数不精确性**

我们需要重新审视第一章中讨论的 IEEE-754。

在任何编程语言的 IEEE-754 数字系统中（这并非 JS 所独有），经典的陷阱之一是并非所有操作和数值都能完美适配到 IEEE-754 表示中。

最常见的例子是：

```js 
point3a = 0.1 + 0.2;
point3b = 0.3;

point3a;                        // 0.30000000000000004
point3b;                        // 0.3

point3a === point3b;            // false <-- oops!
```

操作 0.1 + 0.2 最终会产生浮点错误（漂移），存储的值实际上是 0.30000000000000004。

相应的位表示为：

```js 
// 0.30000000000000004
00111111110100110011001100110011
00110011001100110011001100110100

// 0.3
00111111110100110011001100110011
00110011001100110011001100110011
```

如果您仔细查看这些位模式，只有最后两个位有所不同，从 00 变为 11。但这足以使这两个数字不相等！

再次强调：这种行为绝对不是 JS 独有的。在任何遵循 IEEE-754 的编程语言中，在相同情况下都是如此。如我上面所述，大多数编程语言都使用 IEEE-754，因此它们都会遭遇同样的命运。

我知道，嘲笑 JS 因为 0.1 + 0.2 !== 0.3 的诱惑很强，但这种做法完全没有意义。

<Callout icon="💡" type="info">
几乎所有程序员都需要意识到 IEEE-754，并确保他们对这些陷阱保持谨慎。令人失望的是，了解 IEEE-754 的程序员非常少。如果您花时间阅读并理解这些概念，您现在就属于那些真正努力理解程序中数字的少数人之一！
</Callout>


**Epsilon 阈值**

一个常见的建议是使用这个非常小的数值来解决浮点不精确性问题，这个数值由 JS 定义：

```js 
Number.EPSILON;                 // 2.220446049250313e-16
```

Epsilon 是 JS 能够表示的 1 和下一个大于 1 的值之间的最小差异。虽然这个值在技术上依赖于实现/平台，但通常约为 2.2E-16，或 2^-52。

对于那些没有仔细关注细节的人——包括我过去的自己——通常认为，从单一操作中浮点精度的任何偏差绝不会大于 Number.EPSILON。因此，理论上，我们可以使用 Number.EPSILON 作为一个非常小的容差值，以确保数字相等性比较是安全的：

```js 
function safeNumberEquals(a,b) {
    return Math.abs(a - b) < Number.EPSILON;
}

point3a = 0.1 + 0.2;
point3b = 0.3;

// are these safely "equal"?
safeNumberEquals(point3a,point3b);      // true
```

<Callout icon="⚠️" type="warning">
在第一版的《类型与语法》一书中，我确实推荐了这种方法。我错了。我应该更仔细地研究这个主题。
</Callout>


但是，事实证明，这种方法根本不安全：

```js 
point3a = 10.1 + 0.2;
point3b = 10.3;

safeNumberEquals(point3a,point3b);      // false :(
```

真是令人失望！

不幸的是，Number.EPSILON 仅在某些小数字/操作的情况下作为“安全相等”错误阈值有效，而在其他情况下，它又过于小，导致假阴性。

您可以通过某个因子缩放 Number.EPSILON 来生成一个更大的阈值，以避免假阴性，但使用哪个因子完全是基于您程序将涉及的值及其操作的大小的手动判断。没有自动化的方法来计算一个可靠的、通用的阈值。

除非您确实知道自己在做什么，否则您应该根本不要使用这种 Number.EPSILON 阈值方法。

<Callout icon="💡" type="info">
如果您想了解更多细节和可靠的建议，我强烈推荐阅读这篇[文章](https://stackoverflow.com/questions/51019475/what-are-the-possible-usage-scenarios-for-number-epsilon/56967003#56967003)。但如果我们不能使用 Number.EPSILON 来避免浮点偏差的危险，我们该怎么办？如果您可以通过将所有数字放大，使它们都是整数（或大整数）来避免浮点数，请这样做。只有在完成所有数学运算后，需要输出/表示最终值时，才处理小数值。如果这不可能或不实用，请使用任意精度十进制模拟库，完全避免数字值。或者在一个不基于 IEEE-754 的外部编程环境中进行数学运算。
</Callout>

**数字比较**

与字符串一样，数字值也可以使用相同的操作符进行比较（包括相等和关系排序）。

请记住，无论数字值以何种形式作为字面量指定（十进制、八进制、十六进制、指数等），存储的底层值才是会被比较的。此外，请牢记前一节讨论的浮点不精确性问题，因为比较将对确切的二进制内容敏感。

**数字相等性**

与字符串类似，数字的相等性比较使用 == / === 操作符或 Object.is(..)。还请回忆，如果两个操作数的类型相同，== 的行为与 === 完全相同。

```js 
42 == 42;                   // true
42 === 42;                  // true

42 == 43;                   // false
42 === 43;                  // false

Object.is(42,42);           // true
Object.is(42,43);           // false
```

&zwj;<mark>对于 == 的强制相等（当操作数类型不匹配时），如果任一操作数不是字符串值，== 会优先进行数字相等性检查（这意味着两个操作数都被强制转换为数字）。</mark>

```js 
// numeric (not string!) comparison
42 == "42";                 // true
```

在这个片段中，强制相等将 "42" 转换为 42，而不是反向转换（42 变为 "42"）。<mark>一旦两个类型都是数字，它们的值就会按照与 === 相同的方式进行精确相等比较。</mark>

请记住，JS 不区分值如 42、42.0 和 42.000000；在内部，它们都是相同的。毫不奇怪，== 和 === 的相等性检查验证了这一点：
```js 
42 == 42.0;                 // true
42.0 == 42.00000;           // true
42.00 === 42.000;           // true
```

您可能的直觉是，如果两个数字是字面上相同的，它们就是相等的。这就是 JS 的解释。但是 0.3 并不字面上等于 0.1 + 0.2 的结果，因为（正如我们之前看到的），后者产生的底层值非常接近 0.3，但并不完全相同。

有趣的是，这两个值如此接近，以至于它们的差值小于 Number.EPSILON 阈值，因此 JS 实际上无法准确表示这种差异。

您可能会认为，至少在非正式的情况下，这样的 JS 数字应该是“相等”的，因为它们之间的差异太小，无法表示。但请注意：JS 可以表示存在差异，这就是为什么当 JS 计算 0.1 + 0.2 时，您会看到小数部分的 4。在这种情况下，您可以写出数字字面量 0.00000000000000004（也就是 4e-17），这是 0.3 和 0.1 + 0.2 之间的差异。

JS 不能做到的是，使用其 IEEE-754 浮点数字准确地表示如此小的数字，以至于对其进行操作会产生预期的结果。它太小，无法在 JS 提供的数字类型中完全和正确地表示。

因此，0.1 + 0.2 == 0.3 得到 false，因为这两个值之间存在差异，即使 JS 无法准确表示或处理如此小的差异值。

与字符串类似，`!=`（强制不等）和 `!==`（严格不等）操作符也适用于数字。`x != y` 基本上等于 `!(x == y)`，而 `x !== y` 基本上等于 `!(x === y)`。

在数字相等性方面，有两个令人沮丧的例外（无论您使用 == 还是 ===）：

```js 
NaN === NaN;                // false -- ugh!
-0 === 0;                   // true -- ugh!
```

NaN 从不等于自身（即使使用 ===），-0 始终等于 0（即使使用 ===）。有时人们会惊讶于即使是 === 也有这两个例外。

然而，Object.is(..) 相等性检查没有这些例外，因此对于 NaN 和 -0 的相等性比较，避免使用 == / === 操作符，使用 Object.is(..) -- 对于 NaN 特别使用 Number.isNaN(..)。

**数字关系比较**

与字符串值类似，JS 关系操作符（`<`、`<=`、`>` 和 `>=`）也适用于数字。`<`（小于）和 `>`（大于）操作应该相当自解释：

```js 
41 < 42;                    // true

0.1 + 0.2 > 0.3;            // true (ugh, IEEE-754)
```

请记住：就像 `==` 一样，`<` 和 `>` 操作符也是强制的，这意味着任何非数字值都会被强制转换为数字——除非两个操作数都是字符串，正如我们之前看到的那样。没有严格的关系比较操作符。

&zwj;<mark>如果您在进行数字之间的关系比较，避免强制转换的唯一方法是确保比较始终有两个数字。</mark>否则，这些操作符将执行强制关系比较，类似于`==` 执行强制相等比较的方式。

**数学运算符**

正如我之前所说，编程语言中存在数字的主要原因是为了对它们执行数学运算。那么我们来谈谈如何进行这些运算。

基本的算术运算符是 `+`（加法）、`-`（减法）、`*`（乘法）和 `/`（除法）。还有可用的运算符 `**`（指数运算）和 `%`（取模，或称为除法余数）。此外，还有 `+=`、`-=`、`=`、`/=`、`**`= 和 `%=` 形式的运算符，这些运算符会将结果重新赋值给左侧操作数——必须是有效的赋值目标，如变量或属性。


<Callout icon="💡" type="info">
正如我们已经看到的，+ 运算符是重载的，可以同时与数字和字符串一起使用。当一个或两个操作数是字符串时，结果是字符串连接（包括必要时将任一操作数强制转换为字符串）。但如果两个操作数都不是字符串，结果就是数字相加，如预期的那样。
</Callout>


所有这些数学运算符都是二元的，这意味着它们期望两个值操作数，一个在运算符的左侧，另一个在右侧；它们都期望操作数是数字值。<mark>如果任一或两个操作数不是数字，则非数字操作数会被强制转换为数字以执行运算。</mark>我们将在后面的章节中详细讨论强制转换。

考虑以下内容：

```js 
40 + 2;                 // 42
44 - 2;                 // 42
21 * 2;                 // 42
84 / 2;                 // 42
7 ** 2;                 // 49
49 % 2;                 // 1

40 + "2";               // "402" (字符串连接)
44 - "2";               // 42 (因为 “2” 被强制为 2)
21 * "2";               // 42 (..同上..)
84 / "2";               // 42 (..同上..)
"7" ** "2";             // 49 (两个操作数都强制为数字)
"49" % "2";             // 1 (..同上..)
```

`+` 和 `-` 运算符也有一元形式，这意味着它们只有一个操作数；同样，操作数预期为数字，并在不是数字时被强制转换为数字：

```js 
+42;                    // 42
-42;                    // -42

+"42";                  // 42
-"42";                  // -42
```

您可能已经注意到 -42 看起来像是一个“负四十二”的数字字面量。但这并不完全正确。JS 语法的一个细微之处是，它不识别负数字字面量。相反，JS 将其视为一个正数字字面量 42，前面有一个一元的 - 运算符对其进行取反。

有些令人惊讶的是：

```js 
-42;                    // -42
- 42;                   // -42
-
    42;                 // -42
```

如您所见，- 一元运算符与其操作数之间允许有空格（甚至换行）；实际上，这对所有运算符和操作数都是适用的。

**自增和自减**

还有两个一元数字运算符：++（自增）和 --（自减）。它们都执行各自的操作，然后将结果重新赋值给操作数——必须是有效的赋值目标，如变量或属性。

您可以将 ++ 理解为等同于 += 1，将 -- 理解为等同于 -= 1：

然而，这些是特殊运算符，它们可以出现在后缀（在操作数之后）位置，如上所示，也可以出现在前缀（在操作数之前）位置：

```js 
myAge = 42;

myAge++;
myAge;                  // 43

numberOfHeadHairs--;
```

在这种情况下，前缀和后缀位置似乎给出相同的结果（自增或自减），可能看起来有些奇怪。差别是微妙的，并且与最终重新赋值的结果无关。我们将在后面的章节中再次探讨这些特定的运算符，以深入了解位置差异。

**按位运算符**

JS 提供了几个按位运算符，以对数字值执行位级操作。

然而，这些位操作不是在 IEEE-754 数字的打包位模式上执行的（见第一章）。相反，操作数数字会首先转换为 32 位有符号整数，进行位操作，然后结果再转换回 IEEE-754 数字。

请记住，与其他原始运算符一样，这些运算符计算新的值，而不会实际就地修改值。

- `&`（按位与）：对两个操作数的每个对应位执行与操作；42 & 36 === 32（即 0b00...101010 & 0b00...100100 === 0b00..100000）

- `|`（按位或）：对两个操作数的每个对应位执行或操作；42 | 36 === 46（即 0b00...101010 | 0b00...100100 === 0b00...101110）

- `^`（按位异或）：对两个操作数的每个对应位执行异或操作；42 ^ 36 === 14（即 0b00...101010 ^ 0b00...100100 === 0b00...001110）

- `~`（按位取反）：对单个操作数的位执行取反操作；~42 === -43（即 ~0b00...101010 === 0b11...010101）；使用二进制补码，有符号整数的第一位设置为 1，表示负数，其余位（根据二进制补码反转回去，即 1 的补码位翻转后加 1）将为 43（0b10...101011）；在十进制数值运算中，~x === -(x + 1)，因此 ~42 === -43。

- `<<`（左移）：将左操作数的位向左移动，移动的位数由右操作数指定；42 `<<` 3 == 336（即 0b00...101010 `<<` 3 === 0b00...101010000）。

- `>>`（右移）：对左操作数的位执行符号传播的右移，丢弃右侧溢出的位；左侧的最左位（0 或 1，表示负数）将作为左侧的位复制（从而在结果中保留原始值的符号）；42 >> 3 === 5（即 0b00..101010 >> 3 === 0b00...000101）。

- `>>>`（零填充右移，或称为无符号右移）：执行与 >> 相同的右移，但从左侧移入的位用 0 填充，而不是复制最左位（从而忽略结果中原始值的符号）；42 >>> 3 === 5，但 -43 >>> 3 === 536870906（即 0b11...010101 >>> 3 === 0b0001...111010）。

- `&=`、`|=`、`<<=`、`>>`= 和 `>>>=`（带赋值的按位运算符）：执行相应的按位操作，然后将结果赋值给左操作数（必须是有效的赋值目标，如变量或属性，而不仅仅是字面值）；注意，~= 不在列表中，因为没有这种“二元取反与赋值”运算符。

老实说，在 JS 中按位操作并不常见。但您有时会看到类似这样的语句：

```js 
myGPA = 3.54;

myGPA | 0;              // 3
```

由于位运算符仅对 32 位整数有效，| 0 操作会截断（即，进行 Math.trunc(..)）任何小数值，仅保留整数。


<Callout icon="⚠️" type="warning">
一个常见的误解是
</Callout>


**数字值方法**

数字值提供了以下方法（作为属性）用于特定于数字的操作：

- toExponential(..)：使用科学记数法生成数字的字符串表示（例如，"4.2e+1"）。

- toFixed(..)：生成数字的非科学记数法字符串表示，具有指定的小数位数（根据需要进行四舍五入或零填充）。

- toPrecision(..)：类似于 toFixed(..)，但它将数字参数应用为有效数字的数量（即精度），包括整数部分和小数部分（如果有）。

- toLocaleString(..)：根据当前区域生成数字的字符串表示。

```js 
myAge = 42;

myAge.toExponential(3);         // "4.200e+1"
```

JS 语法的一个特定细微之处是，在处理数字字面量和属性/方法访问时，`.` 可能会产生歧义。

如果 `.` 紧接在数字字面量数字后面（没有空格），并且数字值中没有已经存在的小数点，则 `.` 被认为是数字的小数部分的开始。但如果 `.` 的位置显然不是数字字面量的一部分，那么它总是被视为属性访问。

```js 
42 .toExponential(3);           // "4.200e+1"
```

在这里，空格消除了 `.` 的歧义，将其指定为属性/方法访问。使用 (..) 而不是空格来进行这种消歧义可能更常见/更受欢迎：

```js 
(42).toExponential(3);          // "4.200e+1"
```

这个 JS 解析语法规则的一个不寻常的效果是：

```js 
42..toExponential(3);           // "4.200e+1"
```

所谓的“双点”习惯用法，这个表达式中的第一个 `.` 是一个小数，因此第二个 `.` 显然不是小数，而是一个属性/方法访问。

另外，请注意，第一个 `.` 后面没有数字；在数字字面量上留下一个尾随的 `.` 是完全合法的语法：

```js 
myAge = 41. + 1.;

myAge;                          // 42
```

大整数类型的值不能有小数，因此在字面量后面（带有尾随的 n）的 `.` 的解析是明确的，总是属性访问：

```js 
42n.toString();                 // 42
```

**静态数字属性**

- Number.EPSILON：1 和下一个更高数字之间可能的最小值。

- Number.NaN：与全局 NaN 符号相同，表示特殊的无效数字。

- Number.MIN_SAFE_INTEGER / Number.MAX_SAFE_INTEGER：绝对值最大的正整数和负整数（离 0 最远）。

- Number.MIN_VALUE / Number.MAX_VALUE：数字类型可表示的最小（离 0 最近的正值）和最大（离 0 最远的正值）。

- Number.NEGATIVE_INFINITY / Number.POSITIVE_INFINITY：与全局 -Infinity 和 Infinity 相同，表示离 0 最远的最大（非有限）值。

静态数字助手

- Number.isFinite(..)：返回布尔值，指示值是否有限——不是 NaN，也不是两个无穷大之一。

- Number.isInteger(..) / Number.isSafeInteger(..)：都返回布尔值，指示值是否是没有小数位的整数，以及它是否在安全范围内（-2^53 + 1 到 2^53 - 1）。

- Number.isNaN(..)：修复过的全局 isNaN(..) 工具，识别提供的参数是否为特殊的 NaN 值。

- Number.parseFloat(..) / Number.parseInt(..)：用于解析字符串值中的数字字符，从左到右，直到字符串结束或遇到第一个非浮点（或非整数）字符。

**静态数学命名空间**

由于数字值的主要用途是进行数学运算，JS 在 Math 命名空间中包含了许多标准数学常量和操作工具。

有很多这样的工具，所以我将省略列出每一个。但以下是一些示例：

```js 
Math.PI;                        // 3.141592653589793

// absolute value
Math.abs(-32.6);                // 32.6

// rounding
Math.round(-32.6);              // -33

// min/max selection
Math.min(100,Math.max(0,42));   // 42
```

与 Number（也是 Number(..) 函数，用于数字强制转换）不同，Math 只是一个对象，包含这些属性和静态函数工具；它不能作为函数调用。


<Callout icon="⚠️" type="warning">
Math 命名空间的一个特殊成员是 Math.random()，用于生成 0 和 1.0 之间的随机浮点值。考虑随机数生成——一个本质上是有状态/有副作用的任务——作为数学运算是很不寻常的。它在安全性方面也一直是一个潜在风险，因为 JS 使用的伪随机数生成器（PRNG）在加密学的角度下并不安全（可以被预测）。几年前，Web 平台推出了更安全的 crypto.getRandomValues(..) API（基于更好的 PRNG），它填充一个类型数组以生成可以解释为一个或多个整数（具有类型指定的最大幅度）的随机位。现在普遍不鼓励使用 Math.random()。
</Callout>


**大整数与数字不混合**

正如我们在第一章中讨论的，数字类型和大整数类型的值不能在同一操作中混合。这可能会让您陷入困境，即使您在进行简单的自增操作（如在循环中）：

```js 
myAge = 42n;

myAge + 1;                  // TypeError thrown!
myAge += 1;                 // TypeError thrown!

myAge + 1n;                 // 43n
myAge += 1n;                // 43n

myAge++;
myAge;                      // 44n
```

因此，<mark>如果您在程序中同时使用数字和大整数值，您需要定期手动将一种值类型强制转换为另一种。</mark>BigInt(..) 函数（不带 new 关键字）可以将数字值强制转换为大整数。反之，要将大整数转换为数字，使用 Number(..) 函数（同样，不带 new 关键字）：

```js 
BigInt(42);                 // 42n

Number(42n);                // 42
```


不过请记住：在这些类型之间进行强制转换有一定风险：

```js 
BigInt(4.2);                // RangeError thrown!
BigInt(NaN);                // RangeError thrown!
BigInt(Infinity);           // RangeError thrown!

Number(2n ** 1024n);        // Infinity
```

---

### 原始值是基础

在过去的两章中，我们深入探讨了原始值在 JS 中的行为。我敢打赌，有相当多的读者和我一样，准备跳过这些主题。但现在，希望您能看到理解这些概念的重要性。

但故事并没有到此结束，远非如此！在下一章中，我们将转向理解 JS 的对象类型（对象、数组等）。