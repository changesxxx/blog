---
title: "阐明词法作用域"
description: "在第一章中，我们探讨了作用域是如何在代码编译过程中确定的，这种模型被称为“词法作用域”。“词法”一词指的是编译的第一阶段（词法分析/解析）。

为了正确推理我们的程序，建立一个扎实的作用域工作概念基础是非常重要的。如果我们依赖猜测和直觉，我们可能偶尔会得到正确的答案，但在很多情况下，我们的答案会偏离。这并不是成功的良方。

就像在小学数学课上，如果我们没有展示出正确的步骤，获得正确答案是不够的！我们需要构建准确且有用的心理模型，以此作为未来的基础。

本章将通过几个比喻来阐明作用域。这里的目标是思考你的程序是如何被 JavaScript 引擎处理的，以更接近 JavaScript 引擎的实际工作方式。"
name: "scope-closures-ch2"
---

### 弹珠、桶和气泡……哦，我的天！

我发现一个有效理解作用域的比喻是将彩色弹珠分类到相应颜色的桶中。

想象一下，你发现了一堆弹珠，注意到所有的弹珠都是红色、蓝色或绿色的。让我们将所有的弹珠分类，把红色的放入红色桶，绿色的放入绿色桶，蓝色的放入蓝色桶。分类后，当你需要一个绿色弹珠时，你已经知道绿色桶就是取它的地方。

在这个比喻中，弹珠就是我们程序中的变量。桶是作用域（函数和块），我们只是为了讨论的目的，概念上为它们分配不同的颜色。每个弹珠的颜色因此由它最初创建时所在的颜色作用域决定。

接下来，让我们在第一章的运行程序示例中标注作用域颜色标签：

```js
// outer/global scope: RED

var students = [
    { id: 14, name: "Kyle" },
    { id: 73, name: "Suzy" },
    { id: 112, name: "Frank" },
    { id: 6, name: "Sarah" }
];

function getStudentName(studentID) {
    // function scope: BLUE

    for (let student of students) {
        // loop scope: GREEN

        if (student.id == studentID) {
            return student.name;
        }
    }
}

var nextStudent = getStudentName(73);
console.log(nextStudent);   // Suzy
```

我们用代码注释指定了三种作用域颜色：红色（最外层的全局作用域）、蓝色（函数 getStudentName(..) 的作用域）和绿色（for 循环内部的作用域）。但在查看代码列表时，可能仍然很难识别这些作用域桶的边界。

图 2 通过在每个作用域周围绘制彩色气泡（即桶）来帮助可视化这些作用域的边界：

![Fig. 2: Colored Scope Bubbles](/assets/images/books/know-js/objects-classes/fig2.png)

1. 气泡 1（红色）包含了全局作用域，其中有三个标识符/变量：students（第 1 行）、getStudentName（第 8 行）和 nextStudent（第 16 行）。

2. 气泡 2（蓝色）包含了函数 getStudentName(..) 的作用域（第 8 行），其中只有一个标识符/变量：参数 studentID（第 8 行）。

3. 气泡 3（绿色）包含了 for 循环的作用域（第 9 行），其中也只有一个标识符/变量：student（第 9 行）。


{/* todo */}
<Callout icon="💡" type="info">
技术上讲，参数 studentID 并不完全在蓝色（2）的作用域中。我们将在附录 A 的“隐含作用域”中解开这一混淆。现在，把 studentID 标记为蓝色（2）弹珠就足够了。
</Callout>



&nbsp;<mark>作用域气泡是在编译期间确定的，基于函数/块的作用域书写的位置、彼此之间的嵌套等。每个作用域气泡完全包含在其父作用域气泡内——一个作用域从不部分位于两个不同的外部作用域中。</mark>

每个弹珠（变量/标识符）的颜色是基于其声明所在的气泡（桶），而不是它可能被访问的作用域的颜色（例如，第 9 行的 students 和第 10 行的 studentID）。

{/* todo */}
<Callout icon="💡" type="info">

请记住，我们在第一章中断言 id、name 和 log 都是属性，而不是变量；换句话说，它们不是桶中的弹珠，因此不会根据我们在本书中讨论的任何规则而上色。要了解这些属性访问是如何处理的，请参见系列的第三本书《对象与类》。

</Callout>

当 JavaScript 引擎处理程序（在编译期间）并找到变量的声明时，它本质上会问：“我当前处于哪个颜色的作用域（气泡或桶）？”该变量被指定为相同的颜色，这意味着它属于该桶/气泡。

绿色（3）桶完全嵌套在蓝色（2）桶内，类似地，蓝色（2）桶完全嵌套在红色（1）桶内。作用域可以像这样嵌套，深度可以根据程序的需要而变化。

&nbsp;<mark>对变量/标识符的引用（非声明）是被允许的，只要在当前作用域或任何位于当前作用域上方的作用域中有匹配的声明，但不能与来自下层/嵌套作用域的声明相匹配。</mark>

在红色（1）桶中的表达式只能访问红色（1）弹珠，而不能访问蓝色（2）或绿色（3）。在蓝色（2）桶中的表达式可以引用蓝色（2）或红色（1）弹珠，而不能引用绿色（3）。而在绿色（3）桶中的表达式可以访问红色（1）、蓝色（2）和绿色（3）弹珠。

我们可以将运行时确定这些非声明弹珠颜色的过程概念化为查找。由于第 9 行的 for 循环语句中的 students 变量引用不是一个声明，因此没有颜色。因此，我们询问当前的蓝色（2）作用域桶是否有匹配该名称的弹珠。由于没有匹配，查找继续进行到下一个外部/包含的作用域：红色（1）。红色（1）桶中有一个名为 students 的弹珠，因此循环语句的 students 变量引用被确定为红色（1）弹珠。

第 10 行的 if (student.id == studentID) 语句同样被确定为引用一个名为 student 的绿色（3）弹珠和一个名为 studentID 的蓝色（2）弹珠。

<Callout icon="💡" type="info">
JavaScript 引擎通常不会在运行时确定这些弹珠颜色；这里的“查找”是一个修辞工具，帮助你理解这些概念。在编译期间，大多数或所有变量引用将匹配已知的作用域桶，因此它们的颜色已经确定，并与每个弹珠引用一起存储，以避免在程序运行时不必要的查找。关于这一细微差别的更多信息将在第三章中讨论。
</Callout>


关键要点：

- 变量在特定作用域中声明，可以视为来自匹配颜色桶的彩色弹珠。

- 任何在其声明的作用域内或在任何更深层嵌套作用域中出现的变量引用，都会被标记为相同颜色的弹珠——除非中间的作用域“遮蔽”了变量声明；有关“遮蔽”的信息请见第三章。

- 色桶及其包含的弹珠的确定在编译期间发生。这些信息在代码执行期间用于变量（弹珠颜色）“查找”。