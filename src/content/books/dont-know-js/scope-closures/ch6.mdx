---
title: "限制作用域暴露"
description: "到目前为止，我们的重点一直是解释作用域和变量的工作机制。在这一基础之上，我们将注意力提升到更高的思考层面：在整个程序中应用的决策和模式。首先，我们将讨论如何以及为什么应该使用不同级别的作用域（函数和块）来组织程序的变量，具体目的是减少作用域的过度暴露。"
name: "scope-closures-ch6"
---

### 最小暴露

函数定义了自己的作用域是有道理的。但为什么我们需要块来创建作用域呢？

软件工程阐述了一种基本的原则，通常应用于软件安全，称为“最小特权原则”（POLP）。而与当前讨论相关的这一原则的变体通常被称为“最小暴露原则”（POLE）。

POLP 表达了一种对软件架构的防御态度：系统的组件应设计为以最小的特权、最小的访问权限和最小的暴露来运行。如果每个组件的连接具有最低限度的必要功能，整体系统在安全性方面就会更强，因为一个组件的被攻击或失败对其他组件的影响会最小化。

如果 POLP 关注的是系统级组件设计，那么 POLE 变体则关注于更低的层次；我们将其应用于作用域之间的交互。

在遵循 POLE 时，我们希望最小化什么的暴露？简单来说：每个作用域中注册的变量。

可以这样想：为什么不把程序的所有变量放在全局作用域中呢？这听起来似乎是个坏主意，但值得考虑为什么这样做是不好的。当程序的一个部分使用的变量暴露给另一个部分时，通常会出现三种主要问题：

- **命名冲突**：<mark>如果程序的两个不同部分使用了一个常见且有用的变量/函数名称，但标识符来自一个共享作用域（如全局作用域），那么就会发生命名冲突，这很可能导致错误，因为一个部分以一种方式使用变量/函数，而另一个部分则以不同的方式使用它。</mark>

例如，假设所有循环都使用一个全局的 i 索引变量，那么如果某个函数中的一个循环在执行时，恰好和另一个函数中的循环同时运行，那么共享的 i 变量可能会得到一个意外的值。

- **意外行为**：<mark>如果你暴露了原本应该私有的变量/函数，其他开发人员就可以以你不打算的方式使用它们，这可能违反预期行为并导致错误。</mark>

例如，如果你的部分程序假设一个数组包含所有数字，但其他人的代码访问并修改了该数组，使其包含布尔值和字符串，那么你的代码可能会出现意外的行为。

更糟糕的是，私有细节的暴露会邀请那些有恶意的人尝试绕过你施加的限制，以便在你的软件部分做一些不应该允许的事情。

- **意外依赖**：<mark>如果你不必要地暴露变量/函数，就会邀请其他开发人员使用和依赖这些原本私有的部分。虽然这不会今天就破坏你的程序，但它在未来会造成重构隐患，因为现在你不能轻易重构该变量或函数，否则可能会破坏你无法控制的其他部分。</mark>

例如，如果你的代码依赖于一个数字数组，而你后来决定最好使用其他数据结构而不是数组，那么你现在必须承担调整其他受影响部分的责任。

&zwj;<mark>POLE 应用于变量/函数作用域时，本质上是说，默认暴露最少必要内容，将其他所有内容保持为尽可能私有。尽可能在最小和最深的作用域中声明变量，而不是将所有内容放在全局（甚至外部函数）作用域中。</mark>

如果你按照这个原则设计软件，就有更大的机会避免（或至少最小化）这三种危险。

考虑以下示例：

```js
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```
在这个 diff(..) 函数中，我们希望确保 y 大于或等于 x，以便当我们计算 y - x 时，结果为 0 或更大。如果 x 初始值更大（结果将为负），我们使用一个临时变量 tmp 来交换 x 和 y，以保持结果为正。

在这个简单的例子中，tmp 放在 if 块内或函数级别似乎并没有太大关系——当然它不应该是一个全局变量！然而，遵循 POLE 原则，tmp 应该尽可能隐藏在作用域中。因此我们使用 let 将 tmp 限制在 if 块内。

---

### 在（函数）作用域中隐藏

现在应该清楚为什么在尽可能低（最深嵌套）的作用域中隐藏我们的变量和函数声明是重要的。但是，我们该如何做到这一点呢？

我们已经看到了 let 和 const 关键字，它们是块级作用域的声明符；稍后我们会更详细地回到这些。但首先，关于在作用域中隐藏 var 或函数声明呢？这可以通过在声明周围包裹一个函数作用域轻松实现。

让我们考虑一个函数作用域可以派上用场的例子。

数学运算“阶乘”（记作“6!”）是将一个给定整数与所有逐渐降低的整数相乘，直到1——实际上，你可以在2时停止，因为乘以1没有效果。换句话说，“6!” 等于 “6 * 5!” ，这又等于 “6 * 5 * 4!” ，依此类推。由于涉及到的数学性质，一旦计算出任何给定整数的阶乘（例如“4!”），我们就不需要再次进行这种计算，因为答案总是相同的。

因此，如果你天真地计算了 6 的阶乘，然后想要计算 7 的阶乘，你可能会不必要地重新计算从 2 到 6 的所有整数的阶乘。如果你愿意以牺牲内存换取速度，可以通过在计算每个整数的阶乘时进行缓存来解决这个浪费的计算问题：

```js

var cache = {};

function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
        cache[x] = x * factorial(x - 1);
    }
    return cache[x];
}

factorial(6);
// 720

cache;
// {
//     "2": 2,
//     "3": 6,
//     "4": 24,
//     "5": 120,
//     "6": 720
// }

factorial(7);
// 5040

```

我们将所有计算出的阶乘存储在缓存中，以便在多次调用 factorial(..) 时，之前的计算结果得以保留。但缓存变量显然是 factorial(..) 工作的私有细节，而不是应该暴露在外部作用域中的内容——尤其是全局作用域。


<Callout icon="💡" type="info">
factorial(..) 在这里是递归的——它从内部调用自身——但这只是为了代码简洁；非递归实现在作用域分析上也会得到相同的结果。

</Callout>


然而，解决这个过度暴露问题并不像看起来那么简单，因为我们需要缓存在多次调用中持续存在，因此它必须位于该函数之外的作用域。那么我们该怎么办呢？

我们可以定义另一个中间作用域（在外部/全局作用域和 factorial(..) 内部之间），以便缓存可以存在于其中：

```js
//外部/全局范围

function hideTheCache() {
    //“中间范围”，我们隐藏缓存`
    var cache = {};

    return factorial;

    // **********************

    function factorial(x) {
        // inner scope
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

该 hideTheCache() 函数除了创建一个作用域以便缓存在多次调用 factorial(..) 中持续存在外，没有其他目的。但为了让 factorial(..) 可以访问缓存，我们必须在同一作用域内定义 factorial(..)。然后我们将函数引用作为值从 hideTheCache() 返回，并将其存储在一个同名的外部作用域变量中。现在，当我们多次调用 factorial(..) 时，它的持久缓存保持隐藏，但仅对 factorial(..) 可访问！

好的，但是……每当出现这种仅用于隐藏变量的作用域时，定义（并命名！）一个 hideTheCache(..) 函数会显得很繁琐，尤其是我们可能希望避免与这个函数发生命名冲突，因此每次都要给它一个唯一的名称。真让人头疼。

{/* todo */}
<Callout icon="⚠️" type="warning">

所示的技术——缓存函数的计算输出以优化对同一输入的重复调用时的性能——在函数式编程（FP）领域非常常见，通常称为“记忆化”（memoization）；这种缓存依赖于闭包（详见第七章）。另外，还有内存使用问题（在附录 B 的“关于内存的一句话”中讨论）。FP 库通常会提供一个优化且经过验证的记忆化函数的实用工具，来替代这里的 hideTheCache(..)。记忆化超出了我们讨论的范围（玩笑话！），但有关更多信息，请参阅我的《Functional-Light JavaScript》一书。
</Callout>


与其每次出现这种仅用于隐藏变量的情况时定义一个新的、独特命名的函数，不如使用函数表达式可能是更好的解决方案：

```js
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040

```

等等！这仍然是使用一个函数来创建隐藏缓存的作用域，并且在这种情况下，函数仍然被命名为 hideTheCache，那这有什么解决呢？

回想一下“函数名称作用域”（在第三章），函数表达式中的名称标识符会发生什么。由于 hideTheCache(..) 被定义为函数表达式而不是函数声明，它的名称处于其自己的作用域——基本上与缓存在同一作用域内——而不是在外部/全局作用域中。

这意味着我们可以将每个这样的函数表达式的每个实例命名为完全相同的名称，而不会发生任何冲突。更恰当地说，我们可以根据我们要隐藏的内容为每个实例命名，而不必担心我们选择的任何名称会与程序中的其他函数表达式作用域发生冲突。

{/* todo */}
实际上，我们可以完全省略名称——从而定义一个“匿名函数表达式”。但附录 A 将讨论即使对于这样的仅用于作用域的函数，名称的重要性。

**立即调用函数表达式**

在之前的阶乘递归程序中有一个重要的点容易被忽视：函数表达式末尾的那一行包含` })(); `。

注意，我们将整个函数表达式包围在一组 ( .. ) 中，然后在末尾添加了第二组 ()；这实际上是调用我们刚定义的函数表达式。此外，在这种情况下，包围函数表达式的第一组 ( .. ) 并不是严格必要的（稍后会详细说明），但我们为了可读性而使用了它们。

换句话说，我们定义了一个函数表达式，然后立即调用它。这个常见模式有一个（非常有创意的）名称：立即调用函数表达式（IIFE）。

IIFE 在我们想要创建一个作用域以隐藏变量/函数时非常有用。由于它是一个表达式，它可以在 JS 程序中的任何允许表达式的地方使用。IIFE 可以被命名，例如 hideTheCache()，或（更常见的是）无名/匿名。它可以是独立的，或者像之前那样，成为另一个语句的一部分——hideTheCache() 返回的 factorial() 函数引用然后被赋值给变量 factorial。

作为比较，下面是一个独立的 IIFE 示例：
```js
// outer scope

(function(){
    // inner hidden scope
})();

// more outer scope
```

与之前的 hideTheCache() 不同，在那里包围的 (..) 被视为可选的风格选择，对于独立的 IIFE，它们是必需的；它们将函数区分为表达式，而不是语句。然而，为了一致性，始终将 IIFE 函数包围在 (..) 中。

{/* todo */}

<Callout icon="⚠️" type="warning">
从技术上讲，包围的 (..) 并不是确保 IIFE 中的函数被 JS 解析器视为函数表达式的唯一语法方式。我们将在附录 A 中查看其他选项。

</Callout>


**函数边界**

需要注意的是，使用 IIFE 定义作用域可能会产生一些意想不到的后果，具体取决于周围的代码。由于 IIFE 是一个完整的函数，函数边界会改变某些语句/构造的行为。
{/* todo */}

例如，如果某段代码中有 return 语句，那么如果将其包裹在 IIFE 中，return 的含义将会改变，因为现在 return 将指向 IIFE 的函数。非箭头函数的 IIFE 也会改变 this 关键字的绑定——有关更多信息，请参见《对象与类》一书。此外，像 break 和 continue 这样的语句不会跨越 IIFE 函数边界来控制外部循环或块。

因此，<mark>如果你需要包裹作用域的代码中包含 return、this、break 或 continue，那么 IIFE 可能不是最佳选择。在这种情况下，你可以考虑使用块而不是函数来创建作用域。</mark>

<Callout icon="📝" type="notes">

翻译一下:
1. return 语句的改变
```js
function outerFunction() {
    return (function() {
        return "I am inside IIFE";
    })();
}

console.log(outerFunction()); // 输出: "I am inside IIFE"

```
在这个例子中，IIFE 的 return 语句返回了值，且这个值是由 outerFunction 返回的。但如果我们在 IIFE 内部有一个 return 语句，outerFunction 的返回值仍然是 IIFE 的返回值。

2. this 关键字的绑定

```js

const obj = {
    value: 42,
    getValue: function() {
        return (function() {
            return this.value; // 这里的 this 不指向 obj
        })();
    }
};

console.log(obj.getValue()); // 输出: undefined
```

在这个例子中，this.value 在 IIFE 中是 undefined，因为 IIFE 创建了一个新的上下文，this 不再指向 obj。相反，它指向全局对象（在浏览器中是 window），如果没有 value 属性就会返回 undefined。

3. break 和 continue 的限制
```js

for (let i = 0; i < 5; i++) {
    (function() {
        if (i === 3) {
            break; // 这会报错，因为 break 不能跳出 IIFE
        }
        console.log(i);
    })();
}
```
在这个例子中，如果 i 等于 3，break 语句将尝试退出循环。但由于它被包裹在 IIFE 中，这条 break 语句会导致一个错误，因为它不能跨越 IIFE 的边界。


</Callout>


---

### 用块限制作用域


到此为止，你应该对创建作用域以限制标识符暴漏的优点感到相当满意。

迄今为止，我们通过函数（即 IIFE）作用域来实现这一点。但现在让我们考虑使用 let 声明和嵌套块。一般来说，<mark>任何` { .. } `大括号对，只要是语句，都将作为一个块存在，但不一定作为一个作用域。</mark>

&zwj;<mark>只有当必要时，块才会成为作用域，以容纳其块作用域声明（即 let 或 const）。考虑以下几点</mark>：

```js
{
    //不一定是范围（目前）

    // ..

    // 现在我们知道块需要是一个范围
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        //这也是一个作用域，每个作用域都被激活
        //迭代
        if (i % 2 == 0) {
            // 这只是一个块，不是一个范围
            console.log(i);
        }
    }
}
// 0 2 4
```

并非所有的` { .. }` 大括号对都会创建块（因此也不一定成为作用域）：

- 对象字面量使用` { .. }` 大括号来限定其键值对列表，但这些对象值并不是作用域。

- 类使用` { .. } `大括号来定义其主体，但这不是一个块或作用域。

- 函数使用 `{ .. }` 来包裹其主体，但技术上这并不是一个块——它是函数主体的一个单一语句。然而，它确实是一个（函数）作用域。

- switch 语句上的 `{ .. }` 大括号（围绕一组 case 子句）并不定义块/作用域。

除了这些非块的例子之外，`{ .. }` 大括号对可以定义一个附加到语句（如 if 或 for）的块，或者单独存在——<mark>见之前代码片段中的最外层` { .. } `大括号对。这样的显式块（如果没有声明），实际上并不是一个作用域——尽管它仍然可以作为语义信号。</mark>

显式的独立 `{ .. }` 块一直是有效的 JS 语法，但由于在 ES6 的 let/const 之前它们不能成为作用域，因此它们相对少见。然而，在 ES6 之后，这种用法开始逐渐流行。

在大多数支持块作用域的语言中，显式块作用域是一种非常常见的模式，用于为一个或几个变量创建狭窄的作用域。因此，遵循 POLE 原则，我们应该在 JS 中更广泛地采用这种模式；使用（显式）块作用域来将标识符的曝光限制到最小的实际范围。

显式块作用域即使在另一个块内部也很有用（无论外部块是否是一个作用域）。

例子

```js
if (somethingHappened) {
    //这是一个块，但不是一个范围

    {
        // 该块既是一个代码块同时也是
        //明确范围
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

在这个例子中，if 语句中的` { .. }` 大括号对为 msg 提供了一个更小的内部显式块作用域，因为该变量并不需要在整个 if 块中使用。大多数开发者会将 msg 限定在 if 块中，然后继续。然而，公平地说，当代码只有几行时，这个判断实际上是个选择。但随着代码的增长，这种过度暴露的问题变得更加明显。

那么，是否值得增加额外的 `{ .. }` 对和缩进级别呢？我认为你应该遵循 POLE 原则，总是（在合理的范围内）为每个变量定义最小的块。因此，我建议使用额外的显式块作用域，如上所示。

{/* todo */}
回想一下“未初始化变量（TDZ）”中的 TDZ 错误讨论（第 5 章）。我在那里的建议是：为了最小化 let/const 声明的 TDZ 错误风险，总是将这些声明放在其作用域的顶部。

如果你发现自己在作用域中间放置 let 声明，首先想：“哦，不！TDZ 警报！”如果这个 let 声明在该块的前半部分并不需要，你应该使用内部显式块作用域以进一步缩小它的暴漏。

另一个带有显式块作用域的例子:

```js
function getNextMonthStart(dateStr) {
    var nextMonth, year;

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/
            ) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${
            String(nextMonth).padStart(2,"0")
        }-01`;
}
getNextMonthStart("2019-12-25");   // 2020-01-01
```

首先识别作用域及其标识符：

1. 外部/全局作用域有一个标识符：函数 getNextMonthStart(..)。

2. getNextMonthStart(..) 的函数作用域有三个：dateStr（参数）、nextMonth 和 year。

3. 该`{ .. } `大括号对定义了一个内部块作用域，其中包含一个变量：curMonth。

那么，为什么将 curMonth 放在一个显式块作用域中，而不是与 nextMonth 和 year 一起放在顶部的函数作用域呢？因为 curMonth 只在前两个语句中需要；在函数作用域级别上，它被过度暴露了。

这个例子比较小，所以过度暴露 curMonth 的风险相对有限。但 POLE 原则的好处在于，当你养成了默认最小化作用域暴露的习惯时，将会持续发挥作用。如果你在小案例中始终遵循这一原则，那么在程序增长时，它将为你提供更大的帮助。

现在让我们来看一个更实际的例子:

```js
function sortNamesByLength(names) {
    var buckets = [];

    for (let firstName of names) {
        if (buckets[firstName.length] == null) {
            buckets[firstName.length] = [];
        }
        buckets[firstName.length].push(firstName);
    }

    // 一个块缩小范围
    {
        let sortedNames = [];

        for (let bucket of buckets) {
            if (bucket) {
                //按字母数字对每个桶进行排序
                bucket.sort();

                //将排序后的名称附加到我们的
                //运行列表
                sortedNames = [
                    ...sortedNames,
                    ...bucket
                ];
            }
        }

        return sortedNames;
    }
}

sortNamesByLength([
    "Sally",
    "Suzy",
    "Frank",
    "John",
    "Jennifer",
    "Scott"
]);
// [ "John", "Suzy", "Frank", "Sally",
//   "Scott", "Jennifer" ]
```

在五个不同的作用域中声明了六个标识符。所有这些变量是否都可以存在于单一的外部/全局作用域中？技术上是可以的，因为它们都是唯一命名的，因此没有名称冲突。但这样做会导致代码组织非常糟糕，并可能引发混淆和未来的错误。

我们将它们适当地分散到每个内部嵌套作用域中。每个变量都在程序所需的最内层作用域中定义。

sortedNames 本可以在顶层函数作用域中定义，但它只在该函数的后半部分需要。为了避免在更高层作用域中过度暴露该变量，我们再次遵循 POLE 原则，将其在内部显式块作用域中进行块作用域限制。

**var 和 let**

接下来，我们来谈谈声明 var buckets。该变量在整个函数中使用（除了最后的返回语句）。<mark>任何在整个（或大部分）函数中需要的变量都应该以明显的方式进行声明。</mark>


<Callout icon="⚠️" type="warning">
参数名称在整个函数中并未使用，但无法限制参数的作用域，因此它的行为就像是一个函数范围的声明。
</Callout>


那么，为什么我们使用 var 而不是 let 来声明 buckets 变量呢？这里有语义和技术上的原因来选择 var。

{/* todo */}
在风格上，从 JS 最早的日子开始，var 就一直表示“属于整个函数的变量”。正如我们在“词法作用域”（第 1 章）中所阐述的，var 附加到最近的封闭函数作用域，无论它出现在哪里。这在 var 出现在块内部时仍然成立。

```js
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // tmp是函数作用域
        x = y;
        y = tmp;
    }

    return y - x;
}
```
即使 var 在一个块内部声明，它的作用域仍然是函数范围的（针对 diff(..)），而不是块范围的。

{/* todo */}

虽然你可以在一个块内部声明 var（并且它仍然是函数范围的），但我建议在除少数特定情况下（在附录 A 中讨论）不要这样做。否则，<mark>var 应该保留用于函数的顶层作用域。</mark>


那么，为什么不在同一位置使用 let 呢？<mark>因为 var 与 let 在视觉上是不同的，因此清楚地表示了“这个变量是函数范围的”。在顶层作用域使用 let，尤其是当它不在函数的前几行时，以及当所有其他块中的声明都使用 let 时，无法直观地突出函数范围声明的区别。</mark>

换句话说，我觉得 <mark>var 更好地传达了函数范围的意义，而 let 则传达（并实现）了块范围，这在 var 不够用的情况下是有用的。只要你的程序需要函数范围和块范围的变量，最合理和可读的方式就是将 var 和 let 一起使用，各自发挥最佳作用。</mark>

{/* todo */}

在不同场景中选择 var 或 let 还有其他语义和操作上的原因。我们将在附录 A 中更详细地探讨 var 和 let 的案例。


<Callout icon="⚠️" type="warning">

我建议同时使用 var 和 let 这一观点显然是有争议的，并且与大多数人的看法相悖。人们更常听到的说法是：“var 是有问题的，let 修复了这个问题”和“永远不要使用 var，let 是替代品。”这些观点是合理的，但仅仅是个人意见，就像我的观点一样。var 并没有被实际声明为有问题或弃用；自早期 JS 以来，它一直有效，并且只要 JS 还在，就会继续有效。
</Callout>


**哪里使用 let？**

我建议<mark>将 var 主要保留用于顶层函数作用域，这意味着大多数其他声明应该使用 let。</mark>但你可能仍在想，如何决定每个声明在程序中的位置？

POLE 已经指导了你的决策，但我们要确保明确说明。决定的方法不是基于你想使用哪个关键字，而是要问：“这个变量的最小作用域暴露是什么？”

一旦回答了这个问题，你就会知道一个变量是属于块作用域还是函数作用域。如果你最初决定一个变量应该是块作用域的，并且后来意识到它需要提升为函数作用域，那么这不仅会影响该变量声明的位置，还会影响所使用的声明关键字。决策过程确实应该如此进行。

&zwj;<mark>如果一个声明属于块作用域，使用 let。如果它属于函数作用域，使用 var（再次强调，这只是我的观点）。</mark>

但是，另一种可视化这种决策的方法是考虑一个 ES6 之前版本的程序。例如，让我们回顾一下之前的 diff(..)：

```js

function diff(x,y) {
    var tmp;

    if (x > y) {
        tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

在这个版本的 diff(..) 中，tmp 显然是在函数范围内声明的。这对于 tmp 来说合适吗？我认为不合适。tmp 仅在那几条语句中需要。它不需要用于返回语句。因此，它应该是块范围的。

在 ES6 之前，我们没有 let，所以实际上无法将其设置为块范围。但我们可以做出最好的信号来表达我们的意图：

```js
function diff(x,y) {
    if (x > y) {
       //`tmp`仍然是函数作用域，但是
      //这里的位置在语义上
      //信号块范围
        var tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

将 tmp 的 var 声明放在 if 语句内部，向代码的读者传达了 tmp 属于该块的信号。尽管 JavaScript 并不强制执行这种作用域，但这种语义信号对于代码的读者仍然是有益的。

根据这个观点，你可以找到任何这样的块中的 var 并将其切换为 let，以加强已经传达的语义信号。在我看来，这就是 let 的正确使用。

另一个历史上基于 var 的例子，但现在几乎总是应该使用 let 的是 for 循环：

```js
for (var i = 0; i < 5; i++) {
    // do something
}
```

无论这样的循环在哪里定义，i 基本上应该只在循环内部使用，在这种情况下，POLE 指出它应该用 let 而不是 var 来声明：

```js
for (let i = 0; i < 5; i++) {
    // do something
}
```

几乎唯一的情况是将 var 切换为 let 会“破坏”你的代码，是如果你依赖于在循环外部/循环之后访问循环的迭代器 (i) 的话，例如：

```js
for (var i = 0; i < 5; i++) {
    if (checkValue(i)) {
        break;
    }
}

if (i < 5) {
    console.log("The loop stopped early!");
}

```

这种用法模式并不算太罕见，但大多数人觉得这像是糟糕的代码结构。一个更可取的方法是使用另一个外部作用域的变量来实现这一目的：

```js
var lastI;

for (let i = 0; i < 5; i++) {
    lastI = i;
    if (checkValue(i)) {
        break;
    }
}

if (lastI < 5) {
    console.log("The loop stopped early!");
}
```

lastI 是在整个作用域中需要的，所以使用 var 声明。i 仅在每次循环迭代中需要，因此使用 let 声明。

**有什么例外？**

到目前为止，我们已经断言 var 和参数是函数作用域的，而 let/const 则表示块作用域的声明。这里有一个小例外需要提到：catch 块。

自从 ES3（1999 年）引入 try..catch 以来，catch 块使用了一个额外的（鲜为人知的）块作用域声明功能：

&zwj;<mark>catch 块中声明的 err 变量是块范围的。这个 catch 块可以通过 let 包含其他块范围的声明。但是，在这个块内的 var 声明仍然附属于外部函数/全局作用域。</mark>


ES2019（在撰写时的最新版本）改变了 catch 块，使得它的声明变为可选；<mark>c如果省略声明，那么 catch 块默认不再是一个作用域；不过它仍然是一个块！</mark>

因此，如果你需要处理发生异常的情况（以便能够优雅地恢复），但不关心错误值本身，你可以省略 catch 声明：

```js
try {
    doOptionOne();
}
catch {   // 捕获声明省略
    doOptionTwoInstead();
}
```

这对于一种相对常见的用例来说，是一个小而令人愉悦的语法简化，并且在去掉不必要的作用域时可能稍微提升性能！

<Callout icon="📝" type="notes">
翻译一下:

- 传统用法
```js
try {
    // 可能会抛出异常的代码
    throw new Error("Something went wrong!");
} catch (err) {
    var a = '暴漏了'

    console.log(err.message); // 输出: Something went wrong!
}
console.log(err); // 报错：ReferenceError: err is not defined

//var 声明仍然附属于外部函数/全局作用域。
console.log(a); //暴漏了 

```
在这个例子中，err 变量仅在 catch 块内可用，尝试在 catch 块外访问它将导致错误。

- ES2019 的新特性

    在 ES2019 中，你可以省略 catch 块的声明：
```js
try {
    throw new Error("Something went wrong!");
} catch {
    console.log("An error occurred!"); // 输出: An error occurred!
}
console.log(err); // 报错：ReferenceError: err is not defined
```
在这个例子中，catch 块没有声明任何变量，因此 catch 块默认不再是一个作用域，虽然它仍然是一个块。这样做的好处是，如果你只关心异常的发生，而不需要处理具体的错误信息，可以省略变量声明，从而简化代码。

</Callout>


---

### 块中的函数声明（FiB）

我们现在已经看到，<mark>使用 let 或 const 的声明是块作用域的，而 var 声明是函数作用域的。</mark>那么，直接出现在块中的函数声明呢？这个特性被称为“FiB”（Function in Block）。

我们通常认为函数声明类似于 var 声明。那么它们是否像 var 一样是函数作用域的呢？

答案是既不是，也可以。 我知道……这很令人困惑。让我们深入探讨：

```js

if (false) {
    function ask() {
        console.log("Does this run?");
    }
}
ask();

```

你对这个程序的预期是什么？有三种合理的结果：

1. ask() 调用可能会因引用错误（ReferenceError）而失败，因为 ask 标识符的作用域限制在 if 块内，因此在外部/全局作用域不可用。

2. ask() 调用可能会因类型错误（TypeError）而失败，因为 ask 标识符存在，但它是未定义的（因为 if 语句没有执行），因此不是一个可调用的函数。

3. ask() 调用可能会正确运行，打印出“Does it run?”的消息。

这里令人困惑的部分是：根据你尝试运行这段代码的 JavaScript 环境，你可能会得到不同的结果！这是少数几个疯狂的领域之一，在这里，现有的遗留行为背叛了一个可预测的结果。

JavaScript 规范表明，块中的函数声明是块作用域的，因此答案应该是（1）。然而，大多数基于浏览器的 JavaScript 引擎（包括来自 Chrome 的 v8 引擎，但也在 Node 中使用）将表现为（2），这意味着标识符在 if 块外是可用的，但函数值不会自动初始化，因此保持未定义。

为什么浏览器 JavaScript 引擎被允许以与规范相悖的方式行为？因为这些引擎在 ES6 引入块作用域之前已经有了某些与 FiB 相关的行为，并且人们担心改变以遵循规范可能会破坏一些现有网站的 JavaScript 代码。因此，JS 规范的附录 B 中做出了一个例外，允许浏览器 JavaScript 引擎（仅限于）某些偏差。


<Callout icon="⚠️" type="warning">
你通常不会将 Node 分类为浏览器 JavaScript 环境，因为它通常在服务器上运行。但 Node 的 v8 引擎与 Chrome（和 Edge）浏览器共享。因为 v8 首先是一个浏览器 JavaScript 引擎，所以它采用了这个附录 B 的例外，这意味着浏览器的例外扩展到了 Node。
</Callout>


在块中放置函数声明的最常见用例之一是根据某些环境状态有条件地定义一个函数（比如在 if..else 语句中）。例如：

```js
if (typeof Array.isArray != "undefined") {
    function isArray(a) {
        return Array.isArray(a);
    }
}
else {
    function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

出于性能原因以这种方式结构化代码是很诱人的，因为 typeof Array.isArray 检查只执行一次，而不是定义一个 isArray(..) 并将 if 语句放在其中——这样检查在每次调用时都会不必要地运行。


<Callout icon="⚠️" type="warning">
除了 FiB 偏差的风险，另一个问题是条件定义函数使得调试这样的程序变得更加困难。如果你在 isArray(..) 函数中遇到一个 bug，你首先需要弄清楚实际运行的是哪个 isArray(..) 实现！有时，bug 是因为条件检查不正确导致错误的实现被应用！如果定义多个版本的函数，该程序通常会更难以推理和维护。
</Callout>



除了前面的代码片段，还有几个 FiB 角落案例在潜伏；各种浏览器和非浏览器的 JavaScript 环境（非浏览器的 JavaScript 引擎）中的行为可能会有所不同。例如：

```js
if (true) {
    function ask() {
        console.log("Am I called?");
    }
}

if (true) {
    function ask() {
        console.log("Or what about me?");
    }
}

for (let i = 0; i < 5; i++) {
    function ask() {
        console.log("Or is it one of these?");
    }
}

ask();

function ask() {
    console.log("Wait, maybe, it's this one?");
}

```
{/* todo */}

回想一下，在第 5 章的《何时可以使用变量》中描述的函数提升，可能会暗示在这个代码片段中，最后一个 ask()（消息为“Wait, maybe...”）的函数声明应该提升到调用 ask() 之前。因为它是最后一个同名的函数声明，所以应该“赢”，对吧？不幸的是，答案是否定的。

我并不是想记录所有这些奇怪的边缘案例，也不想解释为什么每个案例的行为是这样的。在我看来，那些信息是古老的遗留琐事。

我对 FiB 真实关注的是，我能给出什么建议，以确保你的代码在所有情况下都表现得可预测？

在我看来，避免 FiB 变化的唯一实用答案是简单地完全避免 FiB。换句话说，<mark>永远不要将函数声明直接放在任何块中。始终将函数声明放在函数的顶层作用域（或全局作用域）中。</mark>

因此，对于之前的 if..else 示例，<mark>我的建议是尽可能避免条件定义函数。是的，这可能稍微降低性能，但这是更好的整体方法：</mark>

```js
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    }
    else {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}

```

重要的是要注意，我在 if 语句中放置的是一个函数表达式，而不是一个声明。这是完全可以的，<mark>函数表达式可以出现在块内。我们讨论 FiB 是为了避免在块中使用函数声明。</mark>

即使你测试了你的程序并且它能正常工作，你从使用 FiB 风格中获得的小好处也远远低于未来可能带来的混淆风险，或者你的代码在其他 JavaScript 环境中的运行差异。

&zwj;<mark>FiB 不值得，应该避免。</mark>

---

### 块结束

编程语言中的词法作用域规则的目的是为了我们能够适当地组织程序的变量，以便实现操作和语义代码沟通的目的。

其中一个最重要的组织技术是确保没有变量暴露给不必要的作用域（POLE）。希望你现在对块作用域有了更深刻的理解。

希望到现在为止，你对词法作用域的理解更加扎实。在这个基础上，下一章将深入讨论闭包这一重要主题。