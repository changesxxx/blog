---
title: "阐明词法作用域"
description: "在第一章中，我们探讨了作用域是如何在代码编译过程中确定的，这种模型被称为“词法作用域”。“词法”一词指的是编译的第一阶段（词法分析/解析）。

为了正确推理我们的程序，建立一个扎实的作用域工作概念基础是非常重要的。如果我们依赖猜测和直觉，我们可能偶尔会得到正确的答案，但在很多情况下，我们的答案会偏离。这并不是成功的良方。

就像在小学数学课上，如果我们没有展示出正确的步骤，获得正确答案是不够的！我们需要构建准确且有用的心理模型，以此作为未来的基础。

本章将通过几个比喻来阐明作用域。这里的目标是思考你的程序是如何被 JavaScript 引擎处理的，以更接近 JavaScript 引擎的实际工作方式。"
name: "scope-closures-ch2"
---

### 弹珠、桶和气泡……哦，我的天！

我发现一个有效理解作用域的比喻是将彩色弹珠分类到相应颜色的桶中。

想象一下，你发现了一堆弹珠，注意到所有的弹珠都是红色、蓝色或绿色的。让我们将所有的弹珠分类，把红色的放入红色桶，绿色的放入绿色桶，蓝色的放入蓝色桶。分类后，当你需要一个绿色弹珠时，你已经知道绿色桶就是取它的地方。

在这个比喻中，弹珠就是我们程序中的变量。桶是作用域（函数和块），我们只是为了讨论的目的，概念上为它们分配不同的颜色。每个弹珠的颜色因此由它最初创建时所在的颜色作用域决定。

接下来，让我们在第一章的运行程序示例中标注作用域颜色标签：

```js
// outer/global scope: RED

var students = [
  { id: 14, name: "Kyle" },
  { id: 73, name: "Suzy" },
  { id: 112, name: "Frank" },
  { id: 6, name: "Sarah" },
];

function getStudentName(studentID) {
  // function scope: BLUE

  for (let student of students) {
    // loop scope: GREEN

    if (student.id == studentID) {
      return student.name;
    }
  }
}

var nextStudent = getStudentName(73);
console.log(nextStudent); // Suzy
```

我们用代码注释指定了三种作用域颜色：红色（最外层的全局作用域）、蓝色（函数 getStudentName(..) 的作用域）和绿色（for 循环内部的作用域）。但在查看代码列表时，可能仍然很难识别这些作用域桶的边界。

图 2 通过在每个作用域周围绘制彩色气泡（即桶）来帮助可视化这些作用域的边界：

![Fig. 2: Colored Scope Bubbles](/assets/images/books/know-js/objects-classes/fig2.png)

1. 气泡 1（红色）包含了全局作用域，其中有三个标识符/变量：students（第 1 行）、getStudentName（第 8 行）和 nextStudent（第 16 行）。

2. 气泡 2（蓝色）包含了函数 getStudentName(..) 的作用域（第 8 行），其中只有一个标识符/变量：参数 studentID（第 8 行）。

3. 气泡 3（绿色）包含了 for 循环的作用域（第 9 行），其中也只有一个标识符/变量：student（第 9 行）。

{/* todo */}

<Callout icon="💡" type="info">
  技术上讲，参数 studentID 并不完全在蓝色（2）的作用域中。我们将在附录 A
  的“隐含作用域”中解开这一混淆。现在，把 studentID 标记为蓝色（2）弹珠就足够了。
</Callout>

&zwj;<mark>作用域气泡是在编译期间确定的，基于函数/块的作用域书写的位置、彼此之间的嵌套等。每个作用域气泡完全包含在其父作用域气泡内——一个作用域从不部分位于两个不同的外部作用域中。</mark>

每个弹珠（变量/标识符）的颜色是基于其声明所在的气泡（桶），而不是它可能被访问的作用域的颜色（例如，第 9 行的 students 和第 10 行的 studentID）。

{/* todo */}

<Callout icon="💡" type="info">

请记住，我们在第一章中断言 id、name 和 log 都是属性，而不是变量；换句话说，它们不是桶中的弹珠，因此不会根据我们在本书中讨论的任何规则而上色。要了解这些属性访问是如何处理的，请参见系列的第三本书《对象与类》。

</Callout>

当 JavaScript 引擎处理程序（在编译期间）并找到变量的声明时，它本质上会问：“我当前处于哪个颜色的作用域（气泡或桶）？”该变量被指定为相同的颜色，这意味着它属于该桶/气泡。

绿色（3）桶完全嵌套在蓝色（2）桶内，类似地，蓝色（2）桶完全嵌套在红色（1）桶内。作用域可以像这样嵌套，深度可以根据程序的需要而变化。

&zwj;<mark>对变量/标识符的引用（非声明）是被允许的，只要在当前作用域或任何位于当前作用域上方的作用域中有匹配的声明，但不能与来自下层/嵌套作用域的声明相匹配。</mark>

在红色（1）桶中的表达式只能访问红色（1）弹珠，而不能访问蓝色（2）或绿色（3）。在蓝色（2）桶中的表达式可以引用蓝色（2）或红色（1）弹珠，而不能引用绿色（3）。而在绿色（3）桶中的表达式可以访问红色（1）、蓝色（2）和绿色（3）弹珠。

我们可以将运行时确定这些非声明弹珠颜色的过程概念化为查找。由于第 9 行的 for 循环语句中的 students 变量引用不是一个声明，因此没有颜色。因此，我们询问当前的蓝色（2）作用域桶是否有匹配该名称的弹珠。由于没有匹配，查找继续进行到下一个外部/包含的作用域：红色（1）。红色（1）桶中有一个名为 students 的弹珠，因此循环语句的 students 变量引用被确定为红色（1）弹珠。

第 10 行的 if (student.id == studentID) 语句同样被确定为引用一个名为 student 的绿色（3）弹珠和一个名为 studentID 的蓝色（2）弹珠。

<Callout icon="💡" type="info">
  JavaScript
  引擎通常不会在运行时确定这些弹珠颜色；这里的“查找”是一个修辞工具，帮助你理解这些概念。在编译期间，大多数或所有变量引用将匹配已知的作用域桶，因此它们的颜色已经确定，并与每个弹珠引用一起存储，以避免在程序运行时不必要的查找。关于这一细微差别的更多信息将在第三章中讨论。
</Callout>

关键要点：

- 变量在特定作用域中声明，可以视为来自匹配颜色桶的彩色弹珠。

- 任何在其声明的作用域内或在任何更深层嵌套作用域中出现的变量引用，都会被标记为相同颜色的弹珠——除非中间的作用域“遮蔽”了变量声明；有关“遮蔽”的信息请见第三章。

- 色桶及其包含的弹珠的确定在编译期间发生。这些信息在代码执行期间用于变量（弹珠颜色）“查找”。

---

### 朋友之间的对话

分析变量及其来源作用域的过程可以用一个有用的比喻来描述，想象在代码被处理和执行时，JS 引擎内部发生的各种对话。我们可以“倾听”这些对话，以更好地理解作用域的工作原理。

现在，让我们认识一下在处理程序时会进行对话的 JS 引擎成员：

- &zwj;<mark>引擎：负责从开始到结束编译和执行我们的 JavaScript 程序。</mark>

- &zwj;<mark>编译器：引擎的一个朋友，处理解析和代码生成的所有繁琐工作（见前一节）。</mark>

- &zwj;<mark>作用域管理器：引擎的另一个朋友，收集并维护所有声明的变量/标识符的查找列表，并执行一套规则来管理这些变量如何被当 前执行的代码访问。
  为了让你完全理解 JavaScript
  的工作原理，你需要开始像引擎（和它的朋友们）一样思考，提出他们提出的问题，并同样回答他们的问题。</mark>

接下来，我们将探讨这些对话，再次回顾我们的运行程序示例：

```js
var students = [
  { id: 14, name: "Kyle" },
  { id: 73, name: "Suzy" },
  { id: 112, name: "Frank" },
  { id: 6, name: "Sarah" },
];

function getStudentName(studentID) {
  for (let student of students) {
    if (student.id == studentID) {
      return student.name;
    }
  }
}

var nextStudent = getStudentName(73);

console.log(nextStudent);
// Suzy
```

让我们检查 JS 将如何处理这个程序，特别是从第一条语句开始。数组及其内容只是基本的 JS 值字面量（因此不受任何作用域问题的影响），所以我们这里关注的是`var students = [ .. ]`的声明和初始化赋值部分。

我们通常将其视为一个单一语句，但这并不是我们朋友引擎所看到的。实际上，JS 将这些视为两个不同的操作，一个在编译期间由编译器处理，另一个在执行期间由引擎处理。

编译器对这个程序的第一件事就是进行词法分析，将其分解为标记，然后将其解析为树（AST）。

一旦编译器进入代码生成阶段，需要考虑的细节比表面上看起来的要多。合理的假设是，编译器将为第一条语句生成如下代码：“为变量分配内存，标记为 students，然后将数组的引用放入该变量中。”但这并不是全部。

以下是编译器处理该语句的步骤：

遇到 var students 时，编译器会询问作用域管理器，查看在该特定作用域桶中是否已经存在名为 students 的变量。如果存在，编译器将忽略此声明并继续。否则，编译器将生成代码，请求作用域管理器在该作用域桶中创建一个名为 students 的新变量。

然后，编译器生成代码，以便引擎在稍后的执行中处理 `students = []` 的赋值。引擎运行的代码将首先询问作用域管理器，当前作用域桶中是否有可访问的名为 students 的变量。如果没有，引擎会继续在其他地方查找（见下面的“嵌套作用域”）。一旦引擎找到变量，就将` [ .. ]` 数组的引用赋值给它。

以下是编译器与作用域管理器之间的对话，展示程序的第一阶段编译可能是如何进行的：

**编译器** ：嘿，作用域管理器（全局作用域），我发现有一个名为 students 的标识符的正式声明，你听说过吗？

**（全局）作用域管理器** ：没有，没听说过，所以我刚刚为你创建了它。

**编译器** ：嘿，作用域管理器，我发现有一个名为 getStudentName 的标识符的正式声明，你听说过吗？

**（全局）作用域管理器** ：没有，但我刚刚为你创建了它。

**编译器** ：嘿，作用域管理器，getStudentName 指向一个函数，所以我们需要一个新的作用域桶。

\*（函数）作用域管理器\*\* ：明白了，这里是作用域桶。

**编译器** ：嘿，作用域管理器（函数），我发现有一个名为 studentID 的正式参数声明，你听说过吗？

**（函数）作用域管理器** ：没有，但现在它在这个作用域中被创建了。

**编译器** ：嘿，作用域管理器（函数），我发现有一个需要其自己的作用域桶的 for 循环。

...

这个对话是一个问答式的交流，编译器询问当前的作用域管理器，检查遇到的标识符声明是否已经被处理。如果回答是“没有”，则作用域管理器在该作用域中创建该变量。如果回答是“是”，那么由于当前作用域管理器没有其他事情要做，这个声明实际上会被跳过。

编译器还会在遇到函数或块作用域时发出信号，以便可以实例化一个新的作用域桶和作用域管理器。

稍后，当程序开始执行时，对话将转移到引擎和作用域管理器，可能会如下进行：

**引擎** ：嘿，作用域管理器（全局作用域），在我们开始之前，你能查找一下标识符 getStudentName 吗？我想把这个函数分配给它。

**（全局）作用域管理器** ：好的，这里是这个变量。

**引擎** ：嘿，作用域管理器，我发现有一个名为 students 的目标引用，你听说过吗？

**（全局）作用域管理器** ：是的，它在这个作用域中被正式声明过，所以在这里。

**引擎** ：谢谢，我将 students 初始化为 undefined，以便可以使用。

**引擎** ：嘿，作用域管理器（全局作用域），我发现有一个名为 nextStudent 的目标引用，你听说过吗？

**（全局）作用域管理器** ：是的，它在这个作用域中被正式声明过，所以在这里。

**引擎** ：谢谢，我将 nextStudent 初始化为 undefined，以便可以使用。

**引擎** ：嘿，作用域管理器（全局作用域），我发现有一个名为 getStudentName 的源引用，你听说过吗？

**（全局）作用域管理器** ：是的，它在这个作用域中被正式声明过。这里是它。

**引擎** ：很好，getStudentName 的值是一个函数，所以我将执行它。

**引擎** ：嘿，作用域管理器，我们现在需要实例化函数的作用域。

...

这个对话是另一个问答式的交流，引擎首先询问当前的作用域管理器，以查找提升的 getStudentName 标识符，以将该函数与之关联。然后，引擎继续询问作用域管理器有关 students 的目标引用，依此类推。

总结一下，像 `var students = [ .. ]` 这样的语句是如何被处理的，分为两个不同的步骤：

1. &zwj;<mark>编译器设置作用域变量的声明（因为它在当前作用域中没有被先前声明）。</mark>

2. &zwj;<mark>在引擎执行时，为了处理语句的赋值部分，引擎询问作用域管理器查找该变量，将其初始化为 undefined，以便可以使用，然后将数组值赋给它。</mark>

<Callout icon="📝" type="notes">
  总结:JavaScript中，变量的初始化和赋值过程可以分为两个阶段：解析阶段（编译阶段）和执行阶段。
- 解析阶段

    1. 词法分析:首先将代码转换为抽象语法树(AST)。

    2. 变量声明:解析阶段,js引擎会扫描整个代码找到所有变量声明(var,let,const)。在此会将变量声明记录到相应的作用域(全局作用域和函数作用域或者块级作用域)并进行初始化。对于var声明的变量会被初始化为undefined,而对于let,const声明的变量则会提升到当前块作用域的顶部,但不会被初始化(暂时性死区)

- 执行阶段

  在执行阶段，JavaScript 引擎按顺序执行代码，并处理变量的初始化和赋值：

  1. 对于var声明的变量,在声明时已经初始化为 undefined，因此在执行阶段仅需要赋值。而let 和 const 声明的变量,当执行到 let 和 const 声明语句时，才会初始化这些变量。对于 let 声明的变量，它们会被初始化为 undefined，然后再赋值；对于 const 声明的变量，它们必须在声明时初始化。

</Callout>

---

### 嵌套作用域

当执行 getStudentName() 函数时，引擎会请求该函数作用域的作用域管理器实例，然后继续查找参数（studentID）以将 73 参数值赋给它，等等。

getStudentName(..) 的函数作用域嵌套在全局作用域内。for 循环的块级作用域同样嵌套在该函数作用域内。作用域可以根据程序定义任意深度地词法嵌套。
{/* todo */}
每个作用域在每次该作用域执行时都会获得自己的作用域管理器实例（一次或多次）。每个作用域在执行开始时会自动注册其所有标识符（这称为“变量提升”；参见第 5 章）。

&zwj;<mark>在作用域的开始，如果任何标识符来自函数声明，该变量会自动初始化为其关联的函数引用。而如果任何标识符来自 var 声明（而不是 let/const），该变量会自动初始化为 undefined 以便可以使用；否则，该变量保持未初始化状态（即处于“暂时性死区”，参见第 5 章），并且在其完整的声明和初始化执行之前不能使用。</mark>

在 `for (let student of students) {}` 语句中，students 是一个需要查找的源引用。但由于函数的作用域中找不到这样的标识符，这个查找将如何处理呢？

为了解释这个问题，让我们想象一下这样一段对话：

**引擎** ：嘿，作用域管理器（当前函数的作用域管理器），我有一个 students 的源引用，你听说过吗？

（函数）作用域管理器：没有，从没听说过。试试下一个外部作用域。

**引擎** ：嘿，作用域管理器（全局作用域的作用域管理器），我有一个 students 的源引用，你听说过吗？

（全局）作用域管理器：是的，它是正式声明的，这里有。

...

&zwj;<mark>词法作用域的一个关键方面是，当在当前作用域中找不到标识符引用时，会查找嵌套中的下一个外部作用域；这个过程会一直重复直到找到为止，或者没有更多的作用域可以查找。</mark>

**查找失败**
{/* todo */}
当引擎耗尽所有词法可用的作用域（向外移动）仍然无法解析标识符的查找时，就会存在错误情况。然而，根据程序的模式（严格模式或非严格模式）以及变量的角色（即目标还是源；参见第 1 章），这种错误情况会有不同的处理方式。

**未定义的混乱**

如果变量是源，在未解析的标识符查找情况下，变量被视为未声明（未知、缺失），这总是会导致抛出 ReferenceError。同样，如果变量是目标，并且代码在此时以严格模式运行，变量被视为未声明，并同样抛出 ReferenceError。

在大多数 JS 环境中，未声明变量情况的错误消息看起来像“Reference Error: XYZ is not defined”。短语“not defined”在英语中似乎几乎与“undefined”（未定义）一词相同。但在 JS 中，这两者是非常不同的，这个错误消息不幸地造成了持续的混淆。

&zwj;<mark>“Not defined”实际上意味着“未声明”——或者更确切地说，“未声明”，即在任何词法可用的作用域中都没有匹配的正式声明。相比之下，“undefined”实际上意味着找到了一个变量（已声明），但该变量此时没有其他值，因此默认为 undefined 值。</mark>

为了进一步加剧混淆，JS 的 typeof 操作符对于这两种状态的变量引用返回的字符串都是“undefined”：

```js
var studentName;
typeof studentName; // "undefined"

typeof doesntExist; // "undefined"
```

这两种变量引用处于非常不同的状态，但 JavaScript 确实模糊了两者的界限。这种术语混乱令人困惑且非常不幸。不幸的是，JavaScript 开发者必须非常注意，不要混淆他们所处理的哪种“undefined”！

**全局... 什么！？**

如果变量是目标并且没有启用严格模式，会出现一种令人困惑且意外的遗留行为。麻烦的结果是，全局作用域的作用域管理器会创建一个意外的全局变量来满足那个目标赋值！

考虑以下情况：

```js
function getStudentName() {
  // 赋值给未声明的变量：(
  nextStudent = "Suzy";
}

getStudentName();

console.log(nextStudent);
// "Suzy" --哎呀，一个意外的全局变量！
```

这种对话将会如何进行：

**引擎** ：嘿，作用域管理器（函数的作用域管理器），我有一个 nextStudent 的目标引用，你听说过吗？

**（函数）作用域管理器** ：没有，从没听说过。试试下一个外部作用域。

**引擎** ：嘿，作用域管理器（全局作用域的作用域管理器），我有一个 nextStudent 的目标引用，你听说过吗？

**（全局）作用域管理器** ：没有，但由于我们不在严格模式下，我帮你创建了一个全局变量，给你！

真糟糕。

这种事故（几乎肯定会导致 bug）是严格模式所提供的有益保护的一个很好的例子，也是为什么不使用严格模式是个坏主意。在严格模式下，全局作用域管理器会这样回应：

**（全局）作用域管理器** ：没有，从没听说过。抱歉，我得抛出一个 ReferenceError。

给一个从未声明的变量赋值是一个错误，所以我们在这里收到一个 ReferenceError 是正确的。

永远不要依赖意外的全局变量。总是使用严格模式，并且总是正式声明你的变量。如果你在不小心尝试给一个未声明的变量赋值时，你将会得到一个有用的 ReferenceError。

**建立在比喻之上**

为了可视化嵌套作用域解析，我更喜欢另一个比喻——办公大楼，如图 3 所示：

![Fig. 3: Scope "Building"](/assets/images/books/know-js/objects-classes/fig3.png)

这栋建筑代表了我们程序的嵌套作用域集合。大楼的第一层代表当前执行的作用域。大楼的顶层代表全局作用域。

你通过首先在当前楼层查找来解析目标或源变量引用，如果没有找到，就乘电梯到下一层（即外部作用域），在那里查找，然后再到下一层，依此类推。一旦你到达顶层（全局作用域），你要么找到你要找的东西，要么没有。但无论如何，你必须停止查找。

---

### 继续对话

到这个时候，你应该已经对作用域是什么以及 JS 引擎如何从你的代码中确定和使用它形成了更丰富的心理模型。

在继续之前，去找一些你项目中的代码，进行这些对话。认真地，大声说出来。找一个朋友，与他们一起练习每个角色。如果你们中的任何一个感到困惑或被绊住了，花更多时间复习这部分内容。

当我们向下一个（外部）章节前进时，我们将探索程序的词法作用域是如何通过一个链条连接起来的。
