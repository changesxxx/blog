---
title: "什么是作用域?"
description: "在你写完前几个程序时，你可能已经对创建变量并将值存储在其中感到有些熟悉。处理变量是编程中最基础的事情之一！

但你可能还没有仔细考虑引擎是如何组织和管理这些变量的。我所说的不是计算机上内存的分配，而是：JavaScript 如何知道在任何给定语句中哪些变量是可访问的，以及它是如何处理同名的两个变量的？

这些问题的答案以称为作用域的明确定义的规则的形式出现。本书将深入探讨作用域的各个方面——它是如何工作的，它的用途是什么，避免的陷阱——并指向指导程序结构的常见作用域模式。

我们的第一步是揭示 JavaScript 引擎在运行程序之前是如何处理我们的程序的。"
name: "scope-closures-ch1"
---

### 关于本书

欢迎来到《你还不知道的 JavaScript》系列的第二本书！如果你已经完成了第一本《入门》，那么你来对地方了！如果还没有，我建议你先从那里开始，以打好基础。

我们的重点将是 JavaScript 语言的三个支柱中的第一个：作用域系统及其函数闭包，以及模块设计模式的强大功能。

JavaScript 通常被归类为解释型脚本语言，因此大多数人认为 JavaScript 程序是以单一的自上而下的方式处理的。<mark>然而，实际上，JavaScript 在执行开始之前会经历一个单独的解析/编译阶段。在初步的解析/编译阶段，代码作者关于如何相互放置变量、函数和代码块的决策会根据作用域的规则进行分析。最终生成的作用域结构通常不受运行时条件的影响。</mark>

&zwj;<mark>JavaScript 函数本身是第一类值；它们可以像数字或字符串一样被赋值和传递。但由于这些函数持有并访问变量，它们保持其原始作用域，无论函数最终在程序中的哪个位置被执行。这被称为闭包。</mark>

&zwj;<mark>模块是一种代码组织模式，其特征是公共方法可以通过闭包对模块内部作用域中的隐藏变量和函数进行特权访问。</mark>

### 编译与解释

你可能听说过代码编译，但也许它看起来像一个神秘的黑匣子，源代码从一端输入，执行程序从另一端输出。

但这并不神秘或神奇。代码编译是处理你代码文本并将其转化为计算机可以理解的指令列表的一系列步骤。通常，整个源代码会一次性转换，而生成的指令会作为输出（通常保存在文件中）进行保存，以便后续执行。

你也可能听说过代码可以被解释，那么这与编译有什么不同呢？

解释执行的任务与编译类似，都是将你的程序转换为机器可理解的指令。但处理模型是不同的。与一次性编译程序不同，解释是逐行处理源代码；每一行或语句在立即继续处理下一行源代码之前都会被执行。

![](/assets/images/books/know-js/scope-closures/fig1.png)

---

### 编译代码

但首先，为什么JS是否编译都很重要？

作用域主要在编译阶段确定，因此理解编译和执行之间的关系是掌握作用域的关键。

在经典的编译理论中，程序通过编译器处理的基本阶段有三个：

1. 词法分析/标记化：将字符字符串拆分为对语言有意义的块，称为标记（tokens）。例如，考虑程序 var a = 2;。这个程序可能会被拆分为以下标记：var、a、=、2 和 ;。空格是否保留为标记取决于它是否有意义。

（标记化和词法分析之间的区别是微妙且学术的，但它的中心在于这些标记是否以无状态或有状态的方式进行识别。简单来说，如果标记化器调用有状态的解析规则来判断 a 是否被视为一个独立的标记或只是另一个标记的一部分，那么这就是词法分析。）

2. 解析：将一系列标记（tokens）转化为一个嵌套元素的树，整体代表程序的语法结构。这被称为抽象语法树（AST）。

例如，var a = 2; 的树可能以一个名为 VariableDeclaration 的顶层节点开始，包含一个名为 Identifier 的子节点（其值为 a），以及另一个名为 AssignmentExpression 的子节点，后者本身有一个子节点名为 NumericLiteral（其值为 2）。

3. 代码生成：将抽象语法树（AST）转化为可执行代码。这个部分根据语言、目标平台和其他因素的不同而变化。

JavaScript 引擎会将 var a = 2; 的抽象语法树转化为一组机器指令，以实际创建一个名为 a 的变量（包括保留内存等），然后将值存储到 a 中。

<Callout icon="💡" type="info">
  JavaScript
  引擎的实现细节（利用系统内存资源等）远比我们在这里探讨的要复杂。我们将重点关注程序的可观察行为，让
  JavaScript 引擎管理那些更深层次的系统级抽象。
</Callout>

JS 引擎远比这三个阶段复杂得多。在解析和代码生成的过程中，存在优化执行性能的步骤（例如，合并冗余元素）。实际上，代码甚至可以在执行过程中重新编译和优化。

因此，我在这里只是广泛地描绘了这个过程。但很快你会看到，即使是我们所覆盖的这些高层次的细节也是相关的。

JavaScript 引擎并没有时间的奢侈来进行其工作和优化，因为 JavaScript 编译并不像其他语言那样在构建步骤中发生。它通常必须在代码执行之前的微秒（甚至更少的时间）内完成。为了确保在这些约束下的最快性能，JavaScript 引擎使用各种技巧（例如 JIT，即时编译和热重编译）；这些远远超出了我们讨论的“范围”。

**必要的两个阶段**

简单来说，<mark>关于 JavaScript 程序的处理，最重要的观察是，它至少发生在两个阶段：首先是解析/编译阶段，然后是执行阶段。</mark>

解析/编译阶段与随后的执行阶段的分离是一个可观察的事实，而不是理论或观点。虽然 JavaScript 规范没有明确要求“编译”，但它要求的行为实质上只有在编译后执行的方法下才能实现。

你可以观察到的三个程序特性来证明这一点：语法错误、提前错误和提升（hoisting）。

**从一开始的语法错误**

考虑这个程序：

```js
var greeting = "Hello";

console.log(greeting);

greeting = ."Hi";
// SyntaxError: unexpected token .
```

这个程序不会产生任何输出（"Hello" 并没有被打印），而是抛出一个关于意外的 . 符号的语法错误，在 "Hi" 字符串之前。由于语法错误发生在格式正确的 console.log(..) 语句之后，如果 JavaScript 是按行自上而下执行的，人们会期望在抛出语法错误之前先打印出 "Hello" 消息。但实际上并没有发生这种情况。

事实上，<mark>JavaScript 引擎能够在执行第一行和第二行之前就知道第三行的语法错误，唯一的方式就是 JavaScript 引擎首先解析整个程序，然后再执行任何代码。</mark>

**提前错误**
接下来，考虑以下内容：

```js
console.log("Howdy");

saySomething("Hello", "Hi");
// Uncathed SyntaxError:参数名称不重复
// 在这种情况下允许

function saySomething(greeting, greeting) {
  "use strict";
  console.log(greeting);
}
```

该 "Howdy" 消息没有被打印，尽管它是一个格式正确的语句。

与前一节中的代码片段一样，这里的语法错误在程序执行之前就被抛出。在这种情况下，这种错误的原因是严格模式（仅在 saySomething(..) 函数中启用）禁止在函数中使用重复的参数名称；在非严格模式下，这是被允许的。

这里抛出的错误不是语法错误，因为它并不是一串格式错误的标记（就像之前的 ."Hi"），但在严格模式下，规范要求在任何执行开始之前抛出这样一个“提前错误”。

但是，JavaScript 引擎是如何知道 greeting 参数重复的？它又是如何知道 saySomething(..) 函数在处理参数列表时处于严格模式（"use strict" 声明只出现在函数体内的后面）？

同样，<mark>唯一合理的解释是，代码必须在执行之前完全解析。</mark>

**提升（Hoisting）**
最后，考虑以下内容：

```js
function saySomething() {
  var greeting = "Hello";
  {
    greeting = "Howdy"; // error comes from here
    let greeting = "Hi";
    console.log(greeting);
  }
}

saySomething();
// ReferenceError: Cannot access 'greeting' before
// initialization
```

在这里提到的 ReferenceError 是由 greeting = "Howdy" 这一行引发的。发生的情况是，该语句中的 greeting 变量属于下一行的声明 let greeting = "Hi"，而不是之前的 var greeting = "Hello" 语句。

&zwj;<mark>JavaScript 引擎在抛出错误的那一行能够知道下一条语句会声明一个相同名称（greeting）的块作用域变量，唯一的方式就是 JavaScript 引擎已经在之前的处理过程中解析了这段代码，并且已经设置好了所有的作用域及其变量关联。只有在执行之前解析程序，才能准确完成对作用域和声明的处理。</mark>

{/* todo */}
这里的 ReferenceError 实际上是由于 greeting = "Howdy" 访问了 greeting 变量太早，造成了一种称为时间死区（Temporal Dead Zone，TDZ）的冲突。第五章将更详细地介绍这一点。

<Callout icon="⚠️" type="warning">
  人们常常断言，let 和 const 声明并不会被提升，以此来解释刚刚演示的 TDZ
  行为。但这并不准确。我们将在第五章中回过头来解释 let 和 const 的提升和 TDZ。
</Callout>

希望你现在相信 JavaScript 程序在任何执行开始之前都会被解析。但这是否证明了它们被编译了呢？

这是一个值得思考的有趣问题。JavaScript 能否先解析一个程序，然后通过解释抽象语法树（AST）中表示的操作来执行该程序，而不先编译程序？是的，这种情况是可能的。但这极不可能，主要是因为这样做在性能上极为低效。

很难想象一个生产级别的 JavaScript 引擎会费尽心思将一个程序解析成抽象语法树（AST），却不将这个 AST 转换（即“编译”）为引擎能够执行的最有效（即二进制）表示形式。

许多人试图在这一术语上拗一些细节，因为在这个问题上有很多细微差别和“其实……”的插话。但从精神上和实践上来看，处理 JavaScript 程序时引擎所做的事情更像是编译，而不是不编译。

将 JavaScript 分类为编译语言，并不是关注其二进制（或字节码）可执行表示的分发模型，而是为了在我们心中保持一个清晰的界定，即 JavaScript 代码被处理和分析的阶段；该阶段显然且无可争辩地发生在代码开始执行之前。

如果我们想有效理解 JavaScript 和作用域，我们需要对 JavaScript 引擎如何处理我们的代码有一个正确的心理模型。

---

### 编译器语言

在了解 JavaScript 程序的两阶段处理（编译，然后执行）之后，让我们将注意力转向 JavaScript 引擎如何识别变量并确定程序作用域的过程。

首先，我们来看一个简单的 JavaScript 程序，作为接下来几章分析的基础：

```js
var students = [
  { id: 14, name: "Kyle" },
  { id: 73, name: "Suzy" },
  { id: 112, name: "Frank" },
  { id: 6, name: "Sarah" },
];

function getStudentName(studentID) {
  for (let student of students) {
    if (student.id == studentID) {
      return student.name;
    }
  }
}

var nextStudent = getStudentName(73);

console.log(nextStudent);
// Suzy
```

除了声明之外，程序中出现的所有变量/标识符都充当两个“角色”之一：要么是赋值的目标，要么是值的来源。

（当我在攻读计算机科学学位期间第一次学习编译器理论时，我们学习了分别表示这些角色的术语“LHS”（又名目标）和“RHS”（又名源）。正如您可能从“L”和“R”猜到的那样，这些首字母缩略词的意思是“左侧”和“右侧”，就像=赋值运算符的左侧和右侧一样。<mark>
但是，赋值目标和源并不总是出现在的左侧或右侧=，因此以目标/源而不是左/右来思考可能更清楚。</mark>）

&zwj;<mark>如何知道一个变量是否是目标？检查是否有值被赋给它；如果有，它就是目标。如果没有，那么这个变量就是源。</mark>

为了使 JS 引擎能够正确处理程序的变量，它必须首先将变量的每个出现标记为target或source。现在我们将深入研究如何确定每个角色。

**目标**

什么使变量成为目标？考虑一下：

```js
students = [ // ..
```

此语句显然是赋值操作；请记住，该var students部分在编译时完全作为声明处理，因此在执行期间无关紧要；我们为了清晰和重点而将其省略。 语句也是一样nextStudent = getStudentName(73)。

但是代码中还有其他三个可能不太明显的目标分配操作。其中之一：

```js

for (let student of students) {

```

student该语句为循环的每次迭代分配一个值。另一个目标引用：

```js
getStudentName(73);
```

但是，这怎么能算作对目标的赋值呢？仔细看：实参73被赋值给了形参studentID。

我们的程序中还有最后一个（微妙的）目标引用。你能发现它吗？

..

..

..

您认出这个了吗？

```js
function getStudentName(studentID) {
```

&zwj;<mark>函数声明是目标引用的一种特殊情况。你可以把它想象成 var getStudentName = function(studentID)，但这样说并不完全准确。标识符 getStudentName 在编译时被声明，但 = function(studentID) 部分也是在编译时处理的；getStudentName 和函数之间的关联是在作用域开始时自动建立的，而不是等到 = 赋值语句被执行时才建立。</mark>

<Callout icon="💡" type="info">
  这种函数和变量的自动关联被称为“函数提升”，并将在第 5 章中详细介绍。
</Callout>

**来源**

因此，我们已经确定了程序中的所有五个目标引用。其他变量引用必须是源引用（因为这是唯一的其他选项！）。

在 for (let student of students) 中，我们说 student 是一个目标，而 students 是一个源引用。在语句 if (student.id == studentID) 中，student 和 studentID 都是源引用。student 在 return student.name 中也是一个源引用。

在 getStudentName(73) 中，getStudentName 是一个源引用（我们希望它能解析为一个函数引用值）。在 console.log(nextStudent) 中，console 是一个源引用，nextStudent 也是。

<Callout icon="💡" type="info">
  id、name 和 log 都是属性，而不是变量引用。
</Callout>

理解目标与源的实际重要性是什么？在第二章中，我们将重新审视这个主题，并讨论变量的角色如何影响其查找（特别是如果查找失败时）。

---

### 作弊：运行时范围修改

现在应该很清楚，作用域是在程序编译时确定的，通常不应受到运行时条件的影响。然而，在非严格模式下，技术上仍然存在两种方法可以“作弊”，在运行时修改程序的作用域。

这两种技术都不应该被使用——它们都是危险和令人困惑的，反正你应该使用严格模式（在严格模式下这些是不允许的）。但了解它们是很重要的，以防你在某些程序中遇到它们。

eval(..) 函数接收一段代码字符串，在程序运行时动态编译并执行。如果这段代码字符串中有 var 或 function 声明，这些声明会修改当前 eval(..) 执行时的作用域：

```js
function badIdea() {
  eval("var oops = 'Ugh!';");
  console.log(oops);
}
badIdea(); // Ugh!
```

如果没有 eval(..)，在 console.log(oops) 中，oops 变量将不存在，并且会抛出一个 ReferenceError。但是 eval(..) 在运行时修改了 badIdea() 函数的作用域。这有很多不良后果，包括每次运行 badIdea() 时修改已经编译和优化的作用域所带来的性能损失。

第二种作弊方法是 with 关键字，它本质上动态地将一个对象转换为局部作用域——其属性在那个新作用域的块中被视为标识符：

```js
var badIdea = { oops: "Ugh!" };

with (badIdea) {
  console.log(oops); // Ugh!
}
```

这里并没有修改全局作用域，但 badIdea 在运行时被转换为一个作用域，而它的属性 oops 成为该作用域中的一个变量。同样，这也是个糟糕的主意，出于性能和可读性考虑。

无论如何，避免使用 eval(..)（至少是 eval(..) 创建声明）和 with。再次强调，这两种作弊方法在严格模式下都不可用，所以如果你使用严格模式（你应该这样做！），那么疑惑就会消失！

---

### 词汇范围

我们已经演示了 JavaScript 的作用域是在编译时确定的；这种类型的作用域被称为“词法作用域”。“词法”与编译的“词法分析”阶段相关，如本章前面所讨论的。

为了将本章总结到一个有用的结论，“词法作用域”的关键思想是它完全由函数、块和变量声明的相对位置控制。

&zwj;<mark>如果你将变量声明放在一个函数内部，编译器在解析该函数时会处理这个声明，并将该声明与函数的作用域关联起来。如果一个变量是块级作用域声明（使用 let 或 const），那么它会与最近的 `{ .. }` 块关联，而不是它所包含的函数（如同 var）。</mark>

此外，变量的引用（无论是目标还是源角色）必须从词法上可用的作用域中解析；否则，该变量被称为“未声明”（这通常会导致错误！）。如果在当前作用域中没有声明该变量，则会查询下一个外层/包含的作用域。这个逐层查找的过程会继续，直到找到匹配的变量声明，或者到达全局作用域且没有其他地方可以查找。

需要注意的是，编译实际上并不在作用域和变量上保留内存。程序尚未执行。

相反，编译会创建一个所有词法作用域的映射，列出程序在执行时所需的内容。你可以将这个计划视为在运行时使用的插入代码，定义所有的作用域（即“词法环境”）并为每个作用域注册所有的标识符（变量）。

换句话说，虽然作用域在编译时被识别，但它们实际上直到运行时才被创建，并且每当一个作用域需要运行时才会创建。在下一章中，我们将勾勒出词法作用域的概念基础。
