# The Ultimate React Course 2024 React 进度

### 目录

-使用组件 props和jsx

  -使用 && 进行条件渲染:jsx使用&&运算符
  -jsx中三元运算符进行条件渲染
  -jsx条件渲染
  -内容过多可以抽离配合props创建单独组件
  -通过解构的形式快速获取prop中的数据
  -react空标签`<></>` 如果需要key需要使用React.Fragemnt
  -条件渲染文本及使用模板字符串添加class
  -章节总结:jsx 使用数组方法返回一个数组提供react渲染实际内容 props单向数据流 条件渲染

-状态 事件 交互组件
  -步骤组件起步
  -react事件处理(点击事件)
  -状态介绍 组件可以定义状态来实现界面重新渲染
  -useState hook的使用 返回一个数组接收[缓存的数据,修改数据回调方法],并且useState hook不能使用在函数内及判断语句块中
  -普通js修改组件中变量不会导致界面重新渲染必须遵循react提供的setter函数 对于特殊存在的变量(对象,数组)在其他变量通过setter函数修改下使用js直接修改变量确实可以重新渲染最新数据,但可能会导致不可预测的错误
  -状态更新重新渲染流程简述
  -更新状态渲染demo
  -react工具 devtool
  -useState hook setter第二种参数形式(回调函数 函数会接受最新的状态进行处理更新,相当于是将所有的更新任务存放在同一个队列中统一更新)
  -每个组件内的state都是独立互不影响 useState 补充 1.如果状态需要进行缓存使用useState进行记录 2.state更新会导致ui重新渲染3.对于不需要进行更新ui的变量不需要使用useState定义
  -react组件与普通js定义同样的内容对比

  -旅行清单小项目
  -旅行清单起步
  -清单列表组件
  -表单组件提交 引出受控元素
  -受控元素 管理元素和元素数据
  -state和prop的区别 
  -抽箱卡 demo


-状态管理
  -章节概述
  -状态管理概念
  -状态提升 局部状态 全局状态 以及如何定义是什么状态进行使用?
  -状态提升至顶层组件中 分配对应的状态给子组件(清单数据 => list,更新清单函数 => 表单)
  -购物车状态提升图例 父子组件状态共享
  -状态共享 -共享删除清单函数
  -状态共享 清单勾选
  -派生状态 : 依赖于父组件或其他组件的属性/状态
  -对于可以根据现有状态推导出的数据 不需要定义更多的状态(基于外部输入动态的渲染自身的状态和渲染内容)
  -列表排序
  -列表清空
  -抽离单独组件
  -手风琴demo
  -利用prop创建复用组件,以及prop中特殊属性children
  -children属性定制个性化组件
  -小费计算demo 

-EAT-N-SPLIT DEMO

-中级React 
  -章节简介
  -项目概述
  -爆米花项目起步
  -拆分组件的思考:对于可复用的组件尽量抽离出一个大小合适的组件(可以根据状态和道具来进行判断,如果一个组件的prop有很多最好就是抽离更多的组件),对于不会复用的组件不进行抽离也是可以接受的;永远不要在一个组件内创建组件;
  -爆米花组件抽离实践
  -组件结构
  -电影数量状态共享 提升状态至最近的父组件实现共享状态 :产生的问题 组件嵌套太深状态传递不方便而且有的组件并不需要这些状态只是用于传递
  -利用children实现高复用插件(插槽)
  -利用children实现将状态传递给指定的组件而非需要借助别的组件逐个向下传递
  -利用children创建可复用的电影列盒子
  -通过prop同样可以实现children一样的效果 相比于children porp可以定义更加易读的名称
  -创建可复用星级组件起步
  -星星点击事件
  -星星悬停事件
  -props描述与建议
  -作为提供者利用prop提供一个可重用性星级组件实践
  -propTypes
  -文字拓展组件demo
  
{/* todo :后续需要进一步验证正确性*/}
-React工作原理
  -项目配置
  -组件的实例流程:本质组件就是一个函数,当组件使用是React调用这个函数并返回React Node ,根据React.createElement创建真实的dom元素并渲染到页面上
  -组件实例注意事项:不能直接通过调用函数的方式进行使用(React不会把他当成组件实例)
  -渲染工作原理:概述:react渲染只有两种方式:1.应用初始化第一次渲染2.组件状态发生改变触发重新渲染事件(useState会触发重新渲染,但多个useState并不会触发多次渲染 react会进行批处理 相当于将多个状态更新放置一个任务队列中 统一进行处理进行渲染)
  -渲染工作原理:渲染阶段(简述):React根据jsx中内容渲染虚拟DOM随后创建Fiber树,Fiber作用于当组件状态更新或者父组件影响会生成一个新的Fiber树 两棵Fiber树会进行比较然后进行标记元素状态是更新/删除/新增(异步) 随后进入提交阶段
  -提交阶段:fiber树比较完成后 React将进入提交阶段 会根据之前的标记来更新DOM 最后通过React-dom库实际去渲染(同步)
  -树节点如何比较:主要是根据前后节点类型,位置,属性..进行比较如果位置及类型发生了改变React会将之前节点移除并新建节点 如果只是属性发生改变React会进行复用并只更新更新的属性,对于节点中的子节点React会进行递归进行比较 规则和上述一致






