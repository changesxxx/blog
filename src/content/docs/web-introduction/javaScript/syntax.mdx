---
title: 基本语法
description: ''
slug: web-introduction/javaScript/syntax
---

### 函数

**函数声明和函数表达式**

函数声明

```js
function foo() {
  console.log(`foo函数`)
}
```

函数表达式

```js
var foo = function () {
  console.log(`foo函数`)
}
```

区别 : **函数声明会被提升到它所在作用域的顶部**，可以在函数声明之前调用该函数。而函数表达式不会。

```js
bar() //bar函数
foo() //Uncaught TypeError: foo is not a function

//函数表达式不会被提升 在页面执行js文件初次扫描时创建的则是一个foo变量 会将foo创建并赋值为undefined  所以当上面foo执行时实际为undefined () 所以报错为undefined不是一个可执行函数
var foo = function () {
  console.log(`foo函数`)
}

//函数声明提升 当页面执行js文件时会初次扫描一遍 在上面bar()执行时这个函数就已经被创建了
function bar() {
  console.log(`bar函数`)
}
```

**回调函数和匿名函数**

回调函数:通过参数传递给另一个函数，并在某个事件或条件发生后被调用的函数。

```js
//此时callback即为一个回调函数
function request(url, callback) {
  console.log(`请求${url}数据....`)

  //获取到数据
  var res = '我是请求结果'

  //回调函数 - 请求到数据后执行函数
  callback(res)
}
```

匿名函数:顾名思义，是没有名称的函数。它们可以在需要函数但不需要函数名称时使用。

```js
//第二个实参即为匿名函数
request('xxxx', function (res) {
  console.log('打印请求结果:' + res)
})
```

**立即执行函数**

立即执行函数:是一种在定义后立即执行的 JavaScript 函数。通常用来创建一个独立的作用域，这样在其中定义的变量就不会污染到全局作用域，非常适合用来初始化代码或创建独立的代码块，以避免变量冲突。

```js
//普通立即执行函数 (function...)() 第一个()表示小括号内容为一个整体 第二个()为执行函数
;(function () {
  console.log('立即执行函数...')
})()

//带有参数和返回值的立即执行函数
var res = (function (age) {
  console.log('立即执行函数...参数为:' + age)

  return 10 + age
})(20)

console.log(res) //30
```

在立即执行函数内部声明的任何变量都不会影响到全局作用域，因为立即执行函数本身就是一个函数作用域。

**箭头函数**

箭头函数 : JavaScript 中引入的一个较新的功能，它提供了一种更简洁的方式来写函数。

```js
//普通函数书写方式
function foo() {
  console.log('普通函数')
}

//箭头函数书写方式
var bar = () => {
  console.log('箭头函数')
}
```

普通函数与箭头函数的区别:

1. 更加简洁的函数语法

```js
//箭头函数
var foo = () => {
  console.log('箭头函数')
}

//如果参数只有一个 ()可以省略
var bar = (name) => {
  console.log('箭头函数', name)
}
//如果函数内只有一行执行代码 {}可以省略
var bar1 = (name) => console.log('箭头函数', name)

//如果只有一行代码,这行代码的结果会作为函数的返回值默认返回
var add = (num1, num2) => num1 + num2
console.log(add(10, 20)) //30

//如果默认返回值是一个对象,必须加上()
var fn = () => ({ name: 'zs' })
console.log(fn()) // {name :'zs'}
```

2. 没有自己的 this : 在箭头函数中，`this`关键字指向的是它被创建时的上下文（即外层函数或全局上下文）。这与传统函数不同，传统函数的`this`指向在函数被调用时确定。

```js
//箭头函数
var foo = () => {
  console.log('箭头函数', this) //this = window
}

//this引用上层作用域的this
var obj = {
  name: 'test',
  bar() {
    var fn = () => {
      console.log('箭头函数', this) //this = window
    }
    fn()
  },
}

obj.bar() //obj:{name:'test',bar...}
```

3. 不绑定 arguments 对象 : 箭头函数内部没有`arguments`对象，如果你需要访问函数的参数列表，可以使用剩余参数语法`...args`。

```js
function bar(name, age) {
  console.log('arguments', arguments) //Arguments[]
}

var foo = (name, ...args) => {
  // console.log('arguments', arguments) //test.html:23 Uncaught ReferenceError: arguments is not defined
  console.log(name, ...args) // zs 19
}
```

4. 不能用作构造函数 : 由于箭头函数没有自己的`this`，它们不能用作构造函数。如果你尝试使用`new`关键字调用箭头函数，会抛出一个错误。

5. 没有 prototype 属性 : 箭头函数没有`prototype`属性，因为它们不适合用来构造对象。

{/* todo */}
[常见面试题:为什么要有箭头函数？](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p)

**纯函数**

纯函数 : 相同的输入，总是会的到相同的输出，并且在执行过程中没有任何副作用(不会对储存的变量产生影响)。

优点:

1. 可预测性：由于纯函数对同样的输入总是产生相同的输出，它们的行为是完全可预测的，这使得程序的调试和测试变得更加容易。

2. 更少的错误：由于纯函数不修改外部状态，它们不会因为外部变量的改变而导致意外的行为变化，从而减少了程序中的错误。

3. 更好的可重用性：纯函数由于不依赖于外部状态，因此它们更容易被重用于其他部分的程序中，无论外部环境如何变化。

**arguments**

在 JavaScript 函数内部，`arguments`是一个类数组对象，它包含了传递给函数的所有参数。是所有（非箭头）函数中都可用的**局部变量**。

```js
function foo(name, age) {
  //获取arguments属性
  console.log(arguments)
  //2 参数数量
  console.log(arguments.length)
}

foo('xxx', 11)
```

<Callout icon="⚠️" type="warning">
  注:参数带有默认值并且调用参数没有进行传值将不会被计算在arguments中
</Callout>

arguments 转成数组的几种方式

`arguments`是一个类数组对象，它包含了传递给函数的所有参数。尽管它看起来和数组很相似，但`arguments`并不是一个真正的数组，因此它没有数组原型上的方法，比如`map`、`slice`等。

1. 遍历

```js
var arr = []
function foo(name, age) {
  for (var arg of arguments) {
    arr.push(arg)
  }
}
```

2. ES6 中的方式

```js
const args = Array.from(arguments)
const args = [...arguments]
```

3. 使用`slice`函数更改 this 指向

```js
var args = [].slice.apply(arguments)
```

<Callout icon="⚠️" type="warning">
  注:这种做法在某些 JavaScript 引擎（例如 V8，Chrome 和 Node.js 的底层引擎）中会阻止某些优化。原因是，这种操作要求引擎对函数的参数进行特别处理，可能会导致函数执行效率降低。

如果你关心代码的性能，建议通过遍历`arguments`对象来手动构建一个新的数组，而不是使用`slice`。这样可以避免阻碍引擎优化的问题。

</Callout>

另外，也可以使用`Array`构造函数作为一个函数，配合`apply`方法来达到同样的目的。或者采用上述第二种方式。

```js
var args = Array.apply(null, arguments)
```

---

### Object

Object 是 JavaScript 的一种数据类型。它用于存储各种键值集合和更复杂的实体。可以通过 Object() 构造函数或者使用对象字面量的方式创建对象。

**常见创建 Object 的几种方式**

1. 对象字面量 : 最直接的创建对象方式。适用于创建单个对象，简洁明了。

```js
var obj = {
  name: 'Alice',
  age: 30,
  sayHello: function () {
    console.log('Hello, ' + this.name)
  },
}
```

2. 构造函数 : 使用`new`关键字和构造函数来创建对象。适用于创建多个结构相同的对象。

```js
function Person(name, age) {
  this.name = name
  this.age = age
  this.sayHello = function () {
    console.log('Hello, ' + this.name)
  }
}

var person1 = new Person('Bob', 25)
var person2 = new Person('Carol', 28)
```

3. Object.create()方法 : 通过指定原型对象和属性来创建新对象。提供了一种更灵活的方式来设置对象的原型。

```js
const person = {
  isHuman: false,
  printIntroduction: function () {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`)
  },
}

const me = Object.create(person)

me.name = 'Matthew'
me.isHuman = true

me.printIntroduction()
```

4. class 类 : 使用`class`关键字定义类，然后通过`new`创建实例。

```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  sayHello() {
    console.log('Hello, ' + this.name)
  }
}

var person = new Person('Eve', 32)
```

**通过 new 关键字关键对象会发生什么?**

1. **创建一个新对象**：JavaScript 会创建一个全新的空对象。
2. **设置原型**：新创建的对象的`[[Prototype]]`被链接到构造函数的`prototype`对象上。这意味着新对象可以访问构造函数原型上的属性和方法。
3. **绑定 this 值**：在构造函数中，`this`关键字指向新创建的对象，允许你将属性和方法添加到这个对象上。
4. **返回新对象**：如果构造函数没有返回其他对象，调用`new`表达式会自动返回这个新创建的对象。

**属性描述符**

用于定义和控制对象中属性的行为。每个属性都有自己的属性描述符,可以通过 **Object.getOwnPropertyDescriptor()** 方法获取。也可以通过 **Object.defineProperty()** 或 **Object.defineProperties()** 方法来修改。

属性描述符包含以下特性:

- **configurable** :当该属性的值为 `true` 时,对应的属性描述符可以被修改,并且该属性也能够从对应的对象上被删除。当我们直接在一个对象定义属性时,这个属性的`configurable`为 true。当我们通过`Object.defineProperty()`定义一个属性时,这个属性的`configurable`为 false。

- **enumerable** :当该属性的值为 `true` 时,对应的属性就可以通过 `for...in` 循环或 `Object.keys()` 方法枚举出来。默认值和`configurable`一致。

- **writable** :当该属性的值为 `false` 时,对应的属性值就变成了只读(immutable),无法修改。默认值和`configurable`一致。

- **value** :该属性存放属性的值,可以是任何有效的 JavaScript 值。默认情况下为`undefined`。

- **get** 该属性关联一个获取访问器函数(getter),在读取对应属性值时会被调用。

- **set** 该属性关联一个设置访问器函数(setter),在写入对应属性值时会被调用。

```js
let person = {
  name: 'Alice',
}

Object.defineProperty(person, 'age', {
  value: 30,
  writable: false, // age 属性只读
  enumerable: true,
  configurable: true,
})

console.log(person.age) // 输出 30
person.age = 35 // 无效,因为 age 是只读属性
console.log(person.age) // 仍然输出 30

let descriptor = Object.getOwnPropertyDescriptor(person, 'age')
// 输出 { value: 30, writable: false, enumerable: true, configurable: true }
console.log(descriptor)

const obj = Object.defineProperty({}, 'info', {})
//info : { value: undefined, writable: false, enumerable: false, configurable: false }
console.log(Object.getOwnPropertyDescriptors(obj))
```

**类方法和实例方法**

类方法

```js
function Person(name) {
  this.name = name
}

//定义类方法
Person.eat = function () {
  console.log('每天都要吃')
}

//类方法调用
Person.eat() //每天都要吃
```

实例方法

```js
function Person(name) {
  this.name = name
}

//定义实例方法
Person.prototype.belief = function (belief) {
  console.log(`${this.name}的信仰是${belief}`)
}

//实例对象
var person = new Person('喽喽')
//调用实例方法
person.belief('麦门永存 🍟') //喽喽的信仰是麦门永存 🍟
```

---

### this

`this`关键字是一个指向函数执行上下文的指针，它的值取决于函数是如何被调用的，而不是如何被定义或声明的。

**绑定规则**

1. 默认绑定 : 当函数直接被调用时（即不作为任何对象的方法或通过任何明确的绑定方式调用）。

```js
function show() {
  console.log(this)
}
/* 
`this`指向全局对象（在浏览器中是`window`对象）。
在严格模式（`'use strict'`）下，`this`会被设置为`undefined`，以避免不小心修改全局对象。
*/
show()
```

2. 隐式绑定 : 当函数作为对象的方法被调用时，`this`隐式地指向这个对象。

```js
const obj = {
  value: 'hello',
  show() {
    console.log(this.value)
  },
}
obj.show() // `this`指向obj
```

3. 显式绑定 : 使用`call`、`apply`或`bind`方法可以显式地指定`this`的指向。

```js
function show() {
  console.log(this.value)
}
const obj = { value: 'hello' }

show.call(obj) // 使用`call`显式绑定`this`到`obj`
show.apply(obj) // 使用`apply`显式绑定`this`到`obj`
const boundShow = show.bind(obj) // `bind`返回一个新函数，`this`被绑定到`obj`
boundShow()
```

`call`、`apply`和`bind`都是 JavaScript 中的函数方法，用于显式地设置函数调用时的`this`指向。尽管它们的目的相同，但在参数传递和使用方式上有所不同：

`call`方法:`call`方法允许为一个函数指定`this`值，并且接受一个参数列表。该方法立即执行函数。

```js
function greet(message, name) {
  console.log(`${message}, ${name}. This is ${this.title}`)
}

const obj = { title: 'Call example' }

// 使用call，`this`被设置为obj
greet.call(obj, 'Hello', 'John') // 输出: "Hello, John. This is Call example"
```

`apply`方法:`apply`方法与`call`方法非常相似，区别在于`apply`接受的是一个参数数组，而不是参数列表。该方法也会立即执行函数。

```js
function greet(message, name) {
  console.log(`${message}, ${name}. This is ${this.title}`)
}

const obj = { title: 'Call example' }

// 使用apply，`this`被设置为obj
greet.apply(obj, ['Hello', 'John']) // 输出: "Hello, John. This is Call example"
```

`bind`方法:`bind`方法创建一个新的函数，`this`值被设置为传给`bind`的第一个参数。与`call`和`apply`不同，`bind`不会立即执行函数，而是返回一个改变了上下文`this`的新函数。`bind`也接受参数列表，这些参数将被预设到新函数的参数中。

```js
function greet(message, name) {
  console.log(`${message}, ${name}. This is ${this.title}`)
}

const obj = { title: 'Call example' }

// 使用call，`this`被设置为obj
const boundGreet = greet.bind(obj, 'Hello')
boundGreet('John') // 输出: "Hello, John. This is Bind example"
```

4. new 绑定 : 当函数作为构造器被`new`关键字调用时，`this`被绑定到新创建的对象上。

```js
function Person(name) {
  this.name = name
}
const person = new Person('John')
console.log(person.name) // `this`指向新创建的`person`对象
```

**规则优先级**

从高到低的优先级排序如下：

1. new 绑定
2. bind 绑定
3. apply/call 绑定
4. 隐式绑定
5. 默认绑定

```js
function foo() {
  console.log('foo函数,this指向为:', this)
}

var obj = {
  name: 'test',
  bar: foo,
}

//默认绑定 非严格模式下this指向全局变量 严格模式下this为undefined
foo() //Window

//隐式绑定
obj.bar() //obj

//显式绑定
foo.apply('abc') //String

//new绑定
new foo() //新创建的对象foo

//隐式绑定优先级比默认绑定优先级大 foo < obj.bar
//显式绑定比隐式绑定优先级大
obj.bar.apply('abc') //String
//而在显式绑定中bind 比 apply/call优先级大
var bindFnObj = {
  name: 'test',
  bar: obj.bar.bind(123),
}
bindFnObj.bar.apply('string') //Number
//而new绑定比显式绑定优先级大
new bindFnObj.bar() //foo
```

**间接函数引用**

间接函数引用是指将一个函数赋值给另一个变量，然后通过那个变量来调用该函数的情形。这种操作往往会涉及到`this`的绑定，**因为`this`的值是在函数被调用时确定的，而不是在函数被定义时确定的**。**间接引用一个函数可能会影响`this`的绑定，导致其指向不同的对象**。

```js
const obj = {
  myMethod: function () {
    console.log(this)
  },
}

// 直接调用
obj.myMethod() // `this`指向obj

// 间接引用
const anotherMethod = obj.myMethod
// `this`在非严格模式下指向全局对象（如window），在严格模式下为`undefined`
anotherMethod()
```

**创建对象产生 this 指向问题**

通过`new`关键字创建的对象，在这个过程中，`this`指向是明确的：由`new`操作创建的独特上下文环境，它指向通过`new`关键字创建的新对象(实例)。

而**通过对象字面量创建对象**时，不存在构造过程中`this`的绑定,所以也就不会创建上下文环境；在创建字面量对象时添加的函数(非箭头函数）中`this`一般情况指向的就是该对象,这是因为普通函数的`this`指向在函数被调用时确定。而箭头函数`this`指向则是在创建时确定。

`new`实例和字面量创建普通函数对比

```js
function Person(name) {
  this.name = name
  this.sayHello = function () {
    console.log('Hello, my name is ' + this.name)
  }
}

var person = new Person('Alice')
person.sayHello() // 这里的this指向person实例

var obj = {
  name: 'Bob',
  sayHello: function () {
    console.log('Hello, my name is ' + this.name)
  },
}

obj.sayHello() // 这里的this指向obj对象 隐式绑定
```

`new`实例和字面量创建箭头函数对比

```js
function Person(name) {
  this.name = name
  /*new创建的对象明确指出this指向自己的实例并会创建上下文环境 箭头函数找上层this便是此处的上下文环境*/
  this.sayHello = () => {
    console.log('Hello, my name is ', this, this.name)
  }
}

var person = new Person('Alice')
person.sayHello() // 这里的this指向person实例

var obj = {
  name: 'Bob',
  /*自变量创建对象不会生成自己的上下文环境 而箭头函数一般this指向则是上层的上下文this obj上层this 就是window*/
  sayHello: () => {
    console.log('Hello, my name is ', this, this.name)
  },
}

obj.sayHello() // 这里的this指向的是window
```

侧方面证实箭头函数特性 : 箭头函数 `this` 指向是在被创建时确定的

```js
var glb = {
  name: 'glb',
  child: {
    name: 'Bob',
    fn() {
      //此处this因为是普通函数,只有在被调用时才能确定this指向,glb.child.fn()隐式绑定 this指向child对象
      var sayHello = () => {
        //箭头函数在创建时就会确定this指向,指向上层上下文环境,上层this指向child,所以此时this指向的就是child
        console.log('this: ', this)
      }
      sayHello()
    },
  },
}
glb.child.fn() //child对象
```

---

### js 执行原理

**执行上下文**

当 JavaScript 引擎扫描脚本文件时，它会创建一个称为**执行上下文的**环境，用于处理代码的整个转换和执行。

有两种类型的执行上下文：**全局**和**函数**。全局执行上下文是在 JavaScript 脚本第一次开始运行时创建的，它代表 JavaScript 中的全局范围。每当调用函数时都会创建函数执行上下文，表示函数的本地范围。

由于 js 的单线程特性，这意味着它一次只能执行一项任务。会创建一堆要执行的执行上下文，称为一个执行堆。当前位于顶部的执行上下文 (EC) 成为活动执行行下文，并由 js 引擎首先执行。一旦活动执行上下文中的所有代码执行完毕，js 引擎就会弹出执行堆栈中这个执行上下文，移至其下方的下一个，依此类推。

执行上下文有两个阶段：

1. **创建阶段**：
   - 创建变量对象（Variable Object）：VO 用于存储函数声明、变量声明（初始化为`undefined`）和在函数上下文中的形参。
   - 建立作用域链（Scope Chain）：作用域链确保了当前执行上下文中的代码能够访问到父级作用域中的变量和函数，从而实现词法作用域的特性。
   - 确定 this 的指向：确定函数执行时 this 关键字所引用的对象。
   - 创建函数（Function Declaration）：将函数声明提升到作用域的顶部，可以在声明之前调用函数。
   - 创建变量（Variable Declaration）：将变量声明提升到作用域的顶部，但是不赋值（即 undefined）。
2. **执行阶段**：
   - 逐行执行代码：按照代码编写的顺序执行语句，包括赋值、函数调用、条件语句等操作。
   - 根据作用域链查找变量：在访问变量时，会根据作用域链从内到外逐级查找变量的值。
   - 执行函数：当调用函数时，会创建新的函数执行上下文，并在其中执行函数内部的代码。
   - 更新变量值：根据执行的操作更新变量的值。

**全局执行上下文**

**全局执行上下文**是 JavaScript 代码执行时根级执行环境，每个 JavaScript 环境只有一个全局执行上下文，它在程序开始执行时创建，并且在程序结束时销毁。当 JavaScript 引擎开始执行脚本时，它首先进入全局执行上下文的创建阶段。这个阶段会创建全局对象，设置全局对象的属性和方法，并初始化全局变量和函数。之后，引擎开始逐行执行全局上下文中的代码。这包括变量赋值、函数调用等操作。

**函数执行上下文**

当发现函数调用时会创建单独的函数执行上下文(FEC)，存放在执行栈内。并创建一个 AO 对象(Activation Object)这个 AO 对象会构造一个名为“ argument ”的类数组对象，其中包含提供给该函数的所有参数。在这个函数执行上下文执行之前,这个 AO 对象会作为函数执行上下文的 VO 来存放变量初始化。

- 创建阶段

  1. 创建变量对象(Variable Object)
     变量对象（VO）是执行上下文的一部分，任何的一个执行上下文都必须关联对应的 VO 对象，它包含了执行上下文中定义的所有变量和函数声明。对于全局执行上下文，变量对象实际上就是全局对象(GO)本身（在浏览器中通常是`window`对象）。而对于函数执行上下文 VO 对应的则是函数执行上下文执行之前创建的 AO(Activation Object) 。在执行上下文中，使用`var`关键字声明的变量会被添加到 VO 上，并初始化为`undefined`。函数声明也会被添加到 VO 中并优先创建出函数对象，所以可以在代码执行前被访问，这个现象称为提升（Hoisting）。

  2. 创建作用域链(scope)

     作用域链（Scope Chain）是 JavaScript 中用于解析和查找变量的一种机制。当代码需要访问一个变量时，JavaScript 引擎会通过作用域链来查找这个变量。作用域链本质上是一个指向变量对象的指针列表，这些变量对象对应着代码的词法嵌套结构。

     对于全局执行上下作用域链包含一个对象就是全局对象本身,因为全局执行上下文是作用域链的最顶端,没有外部引用。因此其作用域链仅包含自身。

     对于函数执行上下文它的作用域链包含了当前函数作用域中的变量对象以及外部环境的变量对象。**函数的作用域链在被函数定义时就已经确定**,即词法作用域规则。它基于函数是在哪里定义的,而不是哪里被调用的(this 指向对于函数来说是被调用时确定),这意味这函数可以访问自己的内部变量,定义它的外部函数变量,以及全局变量。函数执行上下文的作用域链开始于它子的变量对象,然后是定义该函数的父函数的变量对象,一直延伸到全局执行上下文的全局对象。

  3. 配置`this`关键字

     在全局执行上下文中，**this**变量引用全局对象。
     在函数内部，**this**变量根据函数的调用方式引用一个对象。如果调用没有设置**this**的值，则**this**的值引用全局对象——即浏览器中的 window 对象。然而，在严格模式下，如果在进入执行上下文时未设置该值，则该值为**undefined**

- 执行阶段

  创建阶段之后，引擎开始逐行执行全局上下文中的代码。这包括变量赋值、函数调用等操作。如果有函数被调用，那么一个新的函数执行上下文将被创建并推入执行上下文栈。

**初始化全局对象**

js 引擎在执行代码之前,会在堆内存中创建一个初始化全局对象:**Globel Object**。并绑定全局函数及对象,例:`Array`、`Object`、`parseInt`，绑定到全局对象上。这使得这些内置功能在任何地方都可用。其中还有一个`window`属性指向自身。

---

### 闭包

闭包（Closure）是一个强大的 JavaScript 特性，允许一个函数访问并操作外部函数作用域中的变量，即使外部函数已经执行完成。

闭包发生在一个函数内部创建另一个函数时。内部函数会“记住”外部函数的环境，即使外部函数已经执行结束。这是因为函数在 JavaScript 中是词法作用域的，意味着函数的作用域在函数定义的时候就已经确定，而不是在执行时。内部函数保持对外部函数作用域的引用，这个引用就是闭包。

```js
/* 创建名称 */
function createName(surname) {
  return function (name) {
    return `${surname}${name}`
  }
}

var zhangSurname = createName('张')

console.log(zhangSurname('三')) //张三
console.log(zhangSurname('六')) //张六

var wangSurname = createName('王')

console.log(wangSurname('五')) //张三
console.log(wangSurname('七')) //张六
```

结合上一文的执行原理图例:
**创建阶段**

当 JavaScript 引擎开始执行脚本时首先就会创建全局执行上下文,其次会创建一个全局对象,全局执行上下文的 VO 将引用这个全局对象。全局对象包含了一些全局函数属性及对象,并会对使用`var`声明的变量初始化为`undefined`。如果是函数,则会提前创建函数对象,每个函数对象在创建时都会有一个内部属性`[[Scope]]`，这个属性包含了函数定义时的作用域链。这也意味着函数的作用域在函数定义的时候就已经确定了，不是在执行的时候。函数对象的`[[Scope]]`属性，实际上就是捕获了函数定义时的外部作用域链，确保了函数即使在其他地方执行，也能访问到定义时的作用域内的变量。**这种机制使得闭包成为可能：一个函数可以访问并操作不属于自身局部作用域的变量。这不仅包括外围函数的局部变量，也包括全局变量。**

**执行阶段**

创建阶段完成后,代码将一行行进行执行，将会对变量对象中的变量进行赋值操作,当函数被调用时，JavaScript 引擎会为该函数调用创建一个新的执行上下文。函数执行上下文会**复制函数对象的`[[Scope]]`属性来创建作用域链**。并创建 AO 对象,函数的参数、局部变量等会被添加到这个 AO 对象中。然后，这个 AO 对象被推入作用域链的前端，这样函数内部的代码就可以访问到这些局部变量和参数。

---

### 垃圾回收机制

JavaScript 的垃圾回收（Garbage Collection, GC）机制是自动的，旨在帮助开发者管理内存，防止内存泄漏。垃圾回收机制定期查找那些不再被应用程序使用的变量或对象，然后释放它们的内存。这是通过识别哪些对象是“可达的”来完成的。可达对象是指在应用程序中仍然可以访问到的对象，因此被认为是“活动的”或“必需的”。

**基本概念**

**可达性（Reachability）**：最基本的“可达”值是那些从根(js 中指的就是 global object)集合出发可以引用到的值。根集合通常包括在全局作用域中的对象、当前嵌套调用链上的局部变量和参数等。从这些根出发，引用或者链式引用的任何对象都被视为可达的，因此不会被垃圾回收器回收。

**垃圾回收算法**

垃圾回收器主要依赖于几种算法来执行内存回收：

1. **标记-清除（Mark-and-Sweep）**：这是最常用的垃圾回收算法。当垃圾回收运行时，它“标记”根对象集合，然后访问并“标记”所有从根对象引用的对象，再标记从这些对象引用的对象，以此类推。一旦所有可达对象都被标记，那些未被标记的对象即被视为不可达，因此是垃圾。垃圾回收器随后会“清除”这些对象占用的内存，并且“取消标记”所有活动对象，以备下一次垃圾回收使用。
2. **引用计数（Reference Counting）**：这是一种较早的垃圾回收策略，每个对象保存一个引用计数，即有多少个引用指向它。当引用计数变为 0 时，意味着对象不可达，因此可以回收其内存。这种方法的主要缺点是无法处理循环引用。
3. **增量垃圾回收（Incremental GC）**：增量垃圾回收将标记-清除过程分成小片段进行，通过分散垃圾回收的负担，减少应用程序的暂停时间。
4. **分代回收（Generational Collection）**：现代垃圾回收器经常采用分代回收策略，将对象分为两组或更多组（代）。新创建的对象被分配到新生代（Young Generation），而存活时间较长的对象会被移动到老年代（Old Generation）。由于新生代中的对象通常寿命较短，所以可以更频繁地对其进行回收。
5. **压缩（Compaction）**：一些垃圾回收算法还会在清除不可达对象后，对剩余的对象进行内存整理，移动对象来消除分散的空闲内存块，从而优化内存的使用。

---

### 原型

在 JavaScript 中,原型(prototype)是一个非常重要的概念,每个对象都有一个内部的私有属性[[Prototype]],指向另一个对象,另一个对象被称为该对象的原型。当我们试图访问一个对象的属性或方法时,如果该对象本身没有定义该属性或方法,JavaScript 引擎会沿着原型链向上查找,直到找到一个匹配的属性或方法,或者到达原型链的顶端。

通过以下方式获取对象[[Prototype]]:

1. `__proto__`

`__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的`私有属性`，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。

```js
function Person() {}

const p1 = new Person()

console.log(p1.__proto__) // {constructor: ƒ Person()}
```

2. `Object.getPrototypeOf`

```js
function Person() {}

const p1 = new Person()

console.log(Object.getPrototypeOf(p1) === p1.__proto__) //true
```

**[[Prototype]]和 Prototype**

`Prototype`属性

`prototype`是函数对象特有的属性。每当声明一个函数时，JavaScript 引擎就会为这个函数创建一个`prototype`属性，这个属性指向一个对象。这个对象通常被称为原型对象，它包含了该函数构造的所有实例所继承的属性和方法。是实现基于原型的继承和属性的共享。当使用构造函数创建一个新对象时（即通过`new`关键词），被创建对象的内部链接（`[[Prototype]]`）就会指向构造函数的`prototype`对象。

`[[Prototype]]`属性

对象都有一个特殊的内部属性，称为`[[Prototype]]`。这个属性是一个指针，指向该对象的原型，即从哪个对象继承其属性。`[[Prototype]]`属性的存在使得 JavaScript 对象可以实现原型链继承。当尝试访问一个对象的属性时，如果该对象自身没有这个属性，则 JavaScript 引擎会沿着`[[Prototype]]`链向上查找，直到找到该属性或到达原型链的顶端。

```js
function Person(name) {
  this.name = name
}

Person.prototype.sayName = function () {
  console.log(this.name)
}

var person1 = new Person('Alice')
person1.sayName() //Alice
```

在这个例子中，即使我们没有为 person1 创建 sayName 方法,但是依旧可以正常执行。原因就是 person1 是 Person 构建函数通过 new 创建出来的，创建过程时会将 person1 的`[[Prototype]]`属性指向为 Person 的`Prototype`对象,当我们 person1.sayName()执行时,首先会在自身查找 sayName 函数如果没有会通过`[[Prototype]]`进行上层查找,`Prototype`原型对象存在这个方法。

**constructor 属性**

`constructor`属性是存储在原型对象上的一个属性，它指向创建当前对象的构造函数。这意味着，通过这个属性，我们可以找到一个对象实例的原始构造函数。每个原型对象默认都会有一个`constructor`属性。

---

### 继承

1. 原型链继承 : 让子类型的原型为父类型的一个实例。这样，`Student`的原型是`Person`的一个实例，从而创建了一个原型链。

```js
function Person() {}

//person原型上添加sayHello方法
Person.prototype.sayHello = function () {
  console.log('hello')
}

function Student() {}

//将student原型修改为person实例 原型链寻找过程:student实例本身 => student原型(person实例) => person原型对象
Student.prototype = new Person()

var stu = new Student()

stu.sayHello() //hello
```

缺点: 子类型实例会共享父类型的引用属性。

```js
function Person(name) {
  this.name = name
}

//person原型上添加sayHello方法
Person.prototype.sayHello = function () {
  console.log('hello')
}

function Student() {}

//将student原型修改为person原型
Student.prototype = new Person('张三')

var stu = new Student()
var stu1 = new Student()

stu.sayHello() //hello

//Student实例对象共享父类型引用属性
console.log(stu.name) //张三
console.log(stu1.name) //张三

//同样的属性需要书写重复代码
/* 
    function Student () {
      this.name = name
    }
*/
```

2. 借用构造函数继承 : 借用构造函数继承通过在子类型构造函数内部调用父类型构造函数实现。

```js
function Person(name) {
  this.name = name
  //this...更多属性
}

function Student(name) {
  Person.call(this, name)
  //Person.call(this, name,...更多属性)
}

var stu = new Student('王五')
var stu1 = new Student('赵六')

console.log(stu.name) //王五
console.log(stu1.name) //赵六
```

缺点:
只能继承父类的**实例**属性和方法，不能继承原型属性/方法。方法都在构造函数中定义，每次实例化对象都得创建一遍方法，基本无法实现函数复用。

3. 组合继承 : 组合继承结合了原型链和借用构造函数的技术，既通过原型链继承方法，又通过借用构造函数继承属性。

```js
function Person(name) {
  this.name = name
}

//person原型上添加sayHello方法
Person.prototype.sayHello = function () {
  console.log('hello')
}

function Student(name) {
  //借用构造函数 第一次调用父类构造函数
  Person.call(this, name)
}

//将student原型修改为person原型 第二次调用父类构造函数
Student.prototype = new Person('张三')

var stu = new Student('王五')
var stu1 = new Student('赵六')

stu.sayHello() //hello

console.log(stu.name) //王五
console.log(stu1.name) //赵六
```

缺点: 需要调用两次父类构造函数。

4. 原型式继承 : 类似原型链继承,不再赘述

```js
var parent = {
  name: 'parent',
  friends: ['Bob', 'Alice'],
}
//Object.create() 静态方法以一个现有对象作为原型，创建一个新对象。
var child1 = Object.create(parent)
child1.name = 'child1'
child1.friends.push('Tom')

var child2 = Object.create(parent)
child2.name = 'child2'
child2.friends.push('Jerry')

console.log(child1.friends) // ["Bob", "Alice", "Tom", "Jerry"]
console.log(child2.friends) // ["Bob", "Alice", "Tom", "Jerry"]
```

5. 寄生组合式继承 : 寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，是最理想的继承方式。

```js
function inherit(Parent, Son) {
  //原型式继承 使用Object.create避免直接调用父构造函数
  Son.prototype = Object.create(Parent.prototype)

  Object.defineProperty(Son.prototype, 'constructor', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: Son,
  })
}

function Person(name) {
  this.name = name
}

function Student(name, sno) {
  //借用构造函数
  Person.call(this, name)
  this.sno = sno
}

inherit(Person, Student)
```

6. es6 extends 关键字

```js
class Person {
  constructor(name, age) {
    this.name = name
  }

  eat(food) {
    console.log(`${this.name}在吃${food}`)
  }
}

class Student extends Person {
  constructor(name, age) {
    super(name, age)
  }
}

var student = new Student('喽喽', 18)

student.eat('🍟') // 喽喽在吃🍟
```

extends 底层实现

```js
/* 
      t:this
      o:子类原型
      e:相同属性
    */
function _callSuper(t, o, e) {
  return (
    //获取子类__proto__属性
    (o = _getPrototypeOf(o)),
    _possibleConstructorReturn(
      t,
      //判断是否支持Reflect写法 如果支持通过Reflect调用构造函数 如果不支持就用apply 上面o已被修改为子类__proto__属性 例子:Person.apply(this,[相同属性])
      _isNativeReflectConstruct()
        ? /* 
            o: 第一个参数是构造函数，这里已经通过_getPrototypeOf被设置为父类。
            e || []: 第二个参数是传递给构造函数的参数列表。如果e存在，则使用e；否则使用空数组[]。
            _getPrototypeOf(t).constructor: 第三个参数是newTarget，用于指定实际被调用的构造函数。
            这里通过_getPrototypeOf(t).constructor获取，t一般代表子类实例。这样做的目的是确保在调用父类构造函数时，new.target指向的是子类构造函数
            */
          Reflect.construct(o, e || [], _getPrototypeOf(t).constructor)
        : o.apply(t, e),
    )
  )
}

/* 
      用于处理从父类构造函数或方法调用返回的值
      self:this
      call: undefined/通过Reflect.construct创建出来对象
    */
function _possibleConstructorReturn(self, call) {
  //如果调用结果是对象或函数，那么可以直接返回该结果。
  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
    return call
  } //调用返回了一个非undefined的非对象值，抛出一个TypeError
  else if (call !== void 0) {
    throw new TypeError(
      'Derived constructors may only return object or undefined',
    )
  }
  //确保当前实例已经被正确初始化。
  return _assertThisInitialized(self)
}

function _assertThisInitialized(self) {
  //如果self为undefined，意味着父类的构造函数没有被正确调用
  if (self === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called",
    )
  }
  //返回通过父类构造函数赋值属性的子类
  return self
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {}),
    )
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t
  })()
}

/* 
      o:子类
      获取子类__proto__属性
    */
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf.bind()
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o)
      }
  return _getPrototypeOf(o)
}

/* 
      通过寄生组合式实现继承
      subClass:子类
      superClass:父类
    */
function _inherits(subClass, superClass) {
  //边界判断 父类要么是不为函数要么是不为null
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function')
  }

  //寄生式组合继承 生成一个父类实例对象 赋值给子类的原型对象 这样子类的原型对象即为父类的实例对象 形成原型链
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true },
  })

  Object.defineProperty(subClass, 'prototype', { writable: false })

  // 将子类构造函数的__proto__修改为父类构造函数
  if (superClass) _setPrototypeOf(subClass, superClass)
}

/* 
      将子类构造函数的__proto__修改为父类构造函数  例:Student.__proto__ = Person 确保Student也可以使用父类的类方法
      o:子类
      p:父类
    */
function _setPrototypeOf(o, p) {
  //判断Object.setPrototypeOf兼容性
  _setPrototypeOf = Object.setPrototypeOf
    ? Object.setPrototypeOf.bind()
    : function _setPrototypeOf(o, p) {
        o.__proto__ = p
        return o
      }
  return _setPrototypeOf(o, p)
}

function _typeof(o) {
  '@babel/helpers - typeof'
  return (
    (_typeof =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
        ? function (o) {
            return typeof o
          }
        : function (o) {
            return o &&
              'function' == typeof Symbol &&
              o.constructor === Symbol &&
              o !== Symbol.prototype
              ? 'symbol'
              : typeof o
          }),
    _typeof(o)
  )
}

/* 
      instance:this
      Constructor:构造函数本身 
      判断是否通过new调用 如果不是报错提示
    */
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}

/* 
      方法整合
      target:构造函数本身/构造函数对应的原型对象
      props: 所有函数
    */
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    //方法以键值对的形式存储  props[i]就是存储的函数 例:{key:"eat",value:函数}
    var descriptor = props[i]
    descriptor.enumerable = descriptor.enumerable || false
    descriptor.configurable = true
    if ('value' in descriptor) descriptor.writable = true
    //_toPropertyKey主要用于确保对象的属性键可以被正确处理
    //将保存的函数存放在target中
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
  }
}

/* 
      对原型对象方法和类方法进行汇总整合 
      Constructor:构造函数本身
      protoProps:实例对象上的函数
      staticProps:类方法
    */
function _createClass(Constructor, protoProps, staticProps) {
  //原型对象方法
  if (protoProps) _defineProperties(Constructor.prototype, protoProps)
  //类方法
  if (staticProps) _defineProperties(Constructor, staticProps)

  Object.defineProperty(Constructor, 'prototype', { writable: false })
  return Constructor
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, 'string')
  return 'symbol' == _typeof(i) ? i : i + ''
}

function _toPrimitive(t, r) {
  if ('object' != _typeof(t) || !t) return t
  var e = t[Symbol.toPrimitive]
  if (void 0 !== e) {
    var i = e.call(t, r || 'default')
    if ('object' != _typeof(i)) return i
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return ('string' === r ? String : Number)(t)
}

/* 
      定义的person对象
    */
var Person = /*#__PURE__*/ (function () {
  function Person(name, age) {
    //判断是否通过new创建实例对象
    _classCallCheck(this, Person)
    this.name = name
  }

  //整合所有函数
  return _createClass(
    Person,
    [
      {
        key: 'eat',
        value: function eat(food) {
          // \u5728\u5403  : 在吃
          console.log(''.concat(this.name, '\u5728\u5403').concat(food))
        },
        //类方法
      },
    ],
    [
      {
        key: 'play',
        value: function play() {
          console.log('好好玩')
        },
      },
    ],
  )
})()

/* 
      将Person以参数传入 作用:使其形成纯函数

    */
var Student = /*#__PURE__*/ (function (_Person) {
  function Student(name, age, skill) {
    var _this
    //判断是否通过new构建实例
    _classCallCheck(this, Student)

    _this = _callSuper(this, Student, [name, age])
    _this.skill = skill
    return _this
  }

  //继承
  _inherits(Student, _Person)

  return _createClass(Student)
})(Person)

var student = new Student('喽喽', 18, 'javascript')
student.eat('🍟') // 喽喽在吃🍟
```

实现流程简述

1. 父类对象生成

```js
//自动执行函数 生成Person类
var Person = /*#__PURE__*/ (function () {
  function Person(name, age) {
    //判断是否通过new创建实例对象
    _classCallCheck(this, Person)
    this.name = name
  }
  //整合所有函数
  return _createClass(
    Person,
    [
      {
        key: 'eat',
        value: function eat(food) {
          console.log(''.concat(this.name, '\u5728\u5403').concat(food))
        },
        //类方法
      },
    ],
    [
      {
        key: 'play',
        value: function play() {
          console.log('好好玩')
        },
      },
    ],
  )
})()
```

2. 执行\_createClass 函数 将定义的函数存放之原型对象/构造函数本身中

```js
/* 
      对实例方法和类方法进行汇总整合 protoProps[]存放在原型对象中 staticProps[]存放在构造函数本身
      Constructor:构造函数本身
      protoProps:实例对象上的函数
      staticProps:类方法
*/
function _createClass(Constructor, protoProps, staticProps) {
  //原型对象方法
  if (protoProps) _defineProperties(Constructor.prototype, protoProps)
  //类方法
  if (staticProps) _defineProperties(Constructor, staticProps)

  //构造函数prototype不可被更改
  Object.defineProperty(Constructor, 'prototype不可被更改', { writable: false })

  return Constructor
}

/* 
      方法整合
      target:构造函数本身/构造函数对应的原型对象
      props: 所有函数数组
    */
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    //方法以键值对的形式存储  props[i]就是存储的函数 例:{key:"eat",value:函数}
    var descriptor = props[i]
    descriptor.enumerable = descriptor.enumerable || false
    descriptor.configurable = true
    if ('value' in descriptor) descriptor.writable = true
    //_toPropertyKey主要用于确保对象的属性键可以被正确处理
    //将保存的函数存放在target中
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor)
  }
}
```

3. 子类对象生成

```js
/* 
      将Person以参数传入 作用:使其形成纯函数
  */
var Student = /*#__PURE__*/ (function (_Person) {
  function Student(name, age, skill) {
    var _this
    //判断是否通过new构建实例
    _classCallCheck(this, Student)

    _this = _callSuper(this, Student, [name, age])
    debugger
    _this.skill = skill
    return _this
  }

  //继承
  _inherits(Student, _Person)

  return _createClass(Student)
})(Person)
```

4. 调用\_inherits 函数实现继承

```js
/* 
      通过寄生组合式实现继承
      subClass:子类
      superClass:父类
    */
function _inherits(subClass, superClass) {
  //边界判断 父类要么是不为函数要么是不为null
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function')
  }

  //寄生式组合继承 生成一个父类实例对象 赋值给子类的原型对象 这样子类的原型对象即为父类的实例对象 形成原型链
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true },
  })

  //配置子类prototype属性不可被修改
  Object.defineProperty(subClass, 'prototype', { writable: false })

  // 将子类构造函数的__proto__属性修改为父类构造函数
  if (superClass) _setPrototypeOf(subClass, superClass)
}

/* 
      将子类构造函数的__proto__修改为父类构造函数  例:Student.__proto__ = Person 确保Student也可以使用父类的类方法
      o:子类
      p:父类
    */
function _setPrototypeOf(o, p) {
  //判断Object.setPrototypeOf兼容性
  _setPrototypeOf = Object.setPrototypeOf
    ? Object.setPrototypeOf.bind()
    : function _setPrototypeOf(o, p) {
        o.__proto__ = p
        return o
      }
  return _setPrototypeOf(o, p)
}
```

5. 执行\_createClass 函数 和 Person 效果一致 不再赘述

6. 创建实例对象

```js
var student = new Student('喽喽', 18, 'javascript')
```

7. Student 构造函数执行

```js
function Student(name, age, skill) {
  var _this
  //判断是否通过new构建实例
  _classCallCheck(this, Student)

  _this = _callSuper(this, Student, [name, age])
  _this.skill = skill
  return _this
}
```

8. 边界判断 是否通过 new 创建

```js
/* 
      instance:this
      Constructor:构造函数本身 
      判断是否通过new调用 如果不是报错提示
    */
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}
```

9. 调用\_callSuper 函数 实现借用构造函数为子类属性赋值

```js
/* 
      t:this
      o:子类原型
      e:相同属性
    */
function _callSuper(t, o, e) {
  return (
    //获取子类__proto__属性 在_inherits函数实现继承时已经子类__proto__属性修改为父类本身 此时获得o为父类本身
    (o = _getPrototypeOf(o)),
    _possibleConstructorReturn(
      t,
      //判断是否支持Reflect写法 如果支持通过Reflect调用构造函数 返回值为子类实例对象 如果不支持就用apply 上面o已被修改为子类__proto__属性 返回值为undefined 例子:Person.apply(this,[相同属性])
      _isNativeReflectConstruct()
        ? /* 
            o: 第一个参数是构造函数，这里已经通过_getPrototypeOf被设置为父类。
            e || []: 第二个参数是传递给构造函数的参数列表。如果e存在，则使用e；否则使用空数组[]。
            _getPrototypeOf(t).constructor: 第三个参数是newTarget，用于指定实际被调用的构造函数。
            这里通过_getPrototypeOf(t).constructor获取，t一般代表子类实例。这样做的目的是确保在调用父类构造函数时，new.target指向的是子类构造函数
            */
          Reflect.construct(o, e || [], _getPrototypeOf(t).constructor)
        : o.apply(t, e),
    )
  )
}

/* 
      o:子类
      获取子类__proto__属性
    */
function _getPrototypeOf(o) {
  //Object.setPrototypeOf兼容性判断
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf.bind()
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o)
      }
  return _getPrototypeOf(o)
}

/* 
      用于处理从父类构造函数或方法调用返回的值
      self:this
      call: undefined/通过Reflect.construct创建出来对象
    */
function _possibleConstructorReturn(self, call) {
  //如果调用结果是对象或函数，那么可以直接返回该结果。
  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
    return call
  } //调用返回了一个非undefined的非对象值，抛出一个TypeError
  else if (call !== void 0) {
    throw new TypeError(
      'Derived constructors may only return object or undefined',
    )
  }
  //确保当前实例已经被正确初始化。
  return _assertThisInitialized(self)
}

function _assertThisInitialized(self) {
  //如果self为undefined，意味着父类的构造函数没有被正确调用
  if (self === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called",
    )
  }
  //返回通过父类构造函数赋值属性的子类
  return self
}
```

10. 对不同属性进行赋值并返回实例对象

```js
function Student(name, age, skill) {
  var _this
  //判断是否通过new构建实例
  _classCallCheck(this, Student)
  //通过借用构造函数 调用父类构造函数赋值相同的属性 并将子类实例返回
  _this = _callSuper(this, Student, [name, age])
  //为不同属性进行赋值操作
  _this.skill = skill
  //返回实例对象
  return _this
}
```

---

### class

`class`关键字用于定义一个类，类是创建对象的模板。在 ES6（ECMAScript 2015）之前，JavaScript 使用函数和原型来实现类似类的结构。ES6 引入的`class`语法提供了一种更清晰、更直观的方式来定义和创建对象原型。

```js
class Person {
  constructor(name) {
    this.name = name
  }
}

var person = new Person('喽喽')
console.log(person) //Person { name: '喽喽' }
```

**类声明和函数声明区别**

函数声明和类声明之间的一个重要区别在于，函数声明会提升，类声明不会。你首先需要声明你的类，然后再访问它，否则类似以下的代码将抛出 ReferenceError

```js
var person = new Person('喽喽')

class Person {
  constructor(name) {
    this.name = name
  }
}

console.log(person) // Uncaught ReferenceError: Cannot access 'Person' before initialization
```

```js
var student = new Student('喽喽')

function Student(name) {
  this.name = name
}

console.log(student) //Student { name: '喽喽' }
```

**constructor**

constructor 是一个特殊的方法，用于创建和初始化通过类创建的对象。当通过 new 关键字调用类创建实例时,默认调用 constructor 方法。每个类只能有一个 constructor。如果未显式定义 constructor，则会使用一个默认的 constructor。如果类包含多个 constructor 的方法，则将抛出 一个 SyntaxError 。

```js
class Person {
  constructor(name) {
    this.name = name
  }
}
```

**static**

`static`关键字用于定义一个类的静态方法。静态方法可以被类本身调用，而不是由类的实例调用。相当于创建一个类方法。

```js
class Person {
  static sayHello() {
    return 'Hello!'
  }
}
console.log(Person.sayHello()) // 直接通过类调用静态方法
```

反之直接在类代码块中定义的函数则为实例对象

```js
class Person {
  constructor(name) {
    this.name = name
  }
  //存储在Person原型对象中
  eat(food) {
    console.log(`${this.name}在吃${food}`)
  }
}

var person = new Person('喽喽')

person.eat('🍟') // 喽喽在吃🍟  通过实例调用原型对象中的方法
```

### let/const

ES6 引入了块级作用域的概念，主要通过`let`和`const`声明实现。

**ES6 引入的变化**

词法环境（Lexical Environment）和变量环境（Variable Environment）取代了传统的变量对象（VO）。用于不同类型的变量声明。

执行上下文的组成 : 每个执行上下文（无论是全局的还是函数的）都包含两个与词法环境相关的主要组件：

1. **词法环境（LexicalEnvironment）**
2. **变量环境（VariableEnvironment）**

这两个组件都是词法环境的类型。

关于词法环境和变量环境:

**词法环境（LexicalEnvironment）**：在执行上下文中，这个词法环境组件用于存储使用 let 和 const 声明的变量，以及相关的函数和块作用域。它也可能指向函数作用域内部的更深层次的词法环境（如块级作用域）。

**变量环境（VariableEnvironment）**：这个组件在概念上与词法环境类似，但在 ES6 和更高版本中，它专门用于存储使用 var 声明的变量。在函数作用域中，这意味着它用于存储旧式的 var 声明的变量，这些变量具有函数作用域或全局作用域，而不是块级作用域。

词法环境的结构:

一个词法环境是由环境记录（Environment Record）和一个外部词法环境（outer Lexical Environment）组成；

1. 环境记录:存储变量和函数声明的实际位置。环境记录本身分为两种类型：

   - **声明式环境记录（Declarative Environment Record）**：用于存储函数、`let`、`const`,`var`声明的变量等。

   - **对象环境记录（Object Environment Record）**：用于定义全局环境中的变量和函数。它的主要目的是将全局作用域中声明的变量和函数关联到全局对象上。

     对象式环境记录会记录 `var` 声明的标识符，同时绑定到**绑定对象**的同名属性上,即如果在全局环境中使用 `var` 来声明，就会通过**全局环境记录**指向的**对象式环境记录**绑定到 `window` 上，所以我们可以通过 `window` 来访问用 `var` 声明的变量。

2. **外部词法环境的引用（Outer Lexical Environment Reference）**：指向外部词法环境（即父级作用域），用于实现词法作用域的链式查找机制。

**暂时性死区**

暂时性死区（TDZ）是一个术语，用于描述`let`和`const`变量从块开始到初始化之间的区域。在这个区域内访问变量会导致`ReferenceError`。这是因为`let`和`const`声明的变量不会提升至它们所在的块作用域顶部（与`var`声明的变量不同），但它们在声明之前就已经存在于作用域中。

```js
console.log(message) //undefined

//变量会被提前创建出来,但并不能被访问,直到词法绑定被求值
console.log(age) //Uncaught ReferenceError: Cannot access 'age' before initialization

let age
/*从这里开始

暂时性死区  

到这一部分*/ age = 10

var message

message = 'hello'
```

**var 和 let/const 的区别**

1. var 不会形成块级作用域,let/const 会

```js
//age将存放在全局执行上下文词法环境下的声明式环境记录中
let age = 10

{
  //不会形成块级作用域 message将存放在全局变量环境中的对象环境记录中
  var message = 'hello'

  //形成块级作用域 存储在这个块级执行上下文词法环境的声明式环境记录中
  let title = '喽喽'
}

console.log(age, message, title) //title is not defined
```

2. let/const 不会作用域提升,var 有
3. let/const 不可以重复声明,var 可以

<Callout icon="⚠️" type="warning">
  注: **对于函数声明，ES6
  之前的环境（没有块级作用域的概念），函数声明也会提升至所在作用域的顶部，并且可以在整个作用域内访问。在
  ES6
  及之后引入块级作用域的环境中，函数声明的行为类似于`let`和`const`，在块级作用域内部提升，并且只能在声明之后访问。**
</Callout>

```js
// foo() 报错:// foo is not a function

{
  function foo() {
    console.log('foo')
  }
}

foo() //foo
```

### Symbol

symbol 是一种**基本数据类型**。`Symbol()` 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。每个从 `Symbol()` 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符。

```js
var sym1 = Symbol()
//Symbol([description]) description:描述
var sym2 = Symbol('foo')
var sym3 = Symbol('foo')

//每个从 `Symbol()` 返回的 symbol 值都是唯一的。
console.log(sym1 === sym3) //false

//获取Symbol描述
console.log(sym2.description) //foo

//创建相同的Symbol sym2.description : foo
var sym4 = Symbol.for(sym2.description)

var sym5 = Symbol.for(sym2.description)

console.log(sym4 === sym5) //true

//从全局 symbol 注册表中获取指定Symbol 共享的symbol key
//sym4 sym5 共同使用foo生成 所有foo为sym4 sym5的共享symbol key
console.log(Symbol.keyFor(sym4)) //foo
```

### Proxy

\*Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

**监听对象**

ES5 使用 defineProperty 进行监听

```js
const obj = {
  name: 'zs',
  age: 10,
}

Object.keys(obj).forEach(function (key) {
  var value = obj[key]

  Object.defineProperty(obj, key, {
    set(newValue) {
      console.log(`监听:${key}属性重新赋值为:${newValue}`)

      value = newValue
    },

    get() {
      console.log(`监听:获取${key}属性值`)
      return value
    },
  })
})

obj.name = '喽喽' //监听:name属性重新赋值为:喽喽

console.log(obj) //监听:获取age属性值 10
```

缺点:无法监听属性删除

```js
const obj = {
  name: 'zs',
  age: 10,
}

/* 
      new Proxy(target, handler)
      target:Proxy 会对目标（target）对象进行包装。
      handler:handler 是定义了代理的自定义行为的对象
    */
const proxyObj = new Proxy(obj, {
  set(target, key, newValue) {
    console.log(`监听:${key}属性重新赋值为:${newValue}`)
    target[key] = newValue
  },
  get(target, key) {
    console.log(`监听:获取${key}属性值`)
    return target[key]
  },
  //必须返回一个 Boolean 类型的值，表示了该属性是否被成功删除。
  deleteProperty(target, key) {
    console.log(`监听:删除${key}属性值`)
    delete target[key]
    return true
  },
})

proxyObj.name = '喽喽' //监听:name属性重新赋值为:喽喽

console.log(proxyObj.age) //监听:获取age属性值 10

//监听:删除age属性值
delete proxyObj.age

console.log(obj) //{name: '喽喽'}
```

| 对象中的方法                       | 对应触发条件                                                                    |
| ---------------------------------- | ------------------------------------------------------------------------------- |
| handler.getPrototypeOf()           | `Object.getPrototypeOf` 方法的捕捉器                                            |
| handler.setPrototypeOf()           | `Object.setPrototypeOf` 方法的捕捉器                                            |
| handler.isExtensible()             | `Object.isExtensible` 方法的捕捉器                                              |
| handler.preventExtensions()        | `Object.preventExtensions` 方法的捕捉器                                         |
| handler.getOwnPropertyDescriptor() | `Object.getOwnPropertyDescriptor` 方法的捕捉器                                  |
| handler.defineProperty()           | `Object.defineProperty` 方法的捕捉器                                            |
| handler.has()                      | `in` 操作符的捕捉器                                                             |
| handler.get()                      | 属性读取操作的捕捉器                                                            |
| handler.set()                      | 属性设置操作的捕捉器                                                            |
| handler.deleteProperty()           | `delete` 操作符的捕捉器                                                         |
| handler.ownKeys()                  | `Object.getOwnPropertyNames` 方法和 `Object.getOwnPropertySymbols` 方法的捕捉器 |
| handler.apply()                    | 函数被`apply`调用操作的捕捉器                                                   |
| handler.construct()                | `new` 操作符的捕捉器                                                            |

### Reflect

**Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。

早期没有考虑对对象本身如何设计更加规范,许多 API 放到了 Object,导致一个内置类逐渐繁重。所以在 ES6 新增了 Reflect,让这些 API 几种存储在了 Reflect 对象上。并且对于原始的一些 Object 方法不同,`Reflect`的方法在无法完成期望操作时，往往返回`false`而不是抛出错误。这使得错误处理变得更加灵活，尤其是在使用`Proxy`进行对象操作拦截时。

传统通**过 Object.defineProperty**添加属性

```js
const obj = {
  name: 'zs',
  age: 10,
}

Object.freeze(obj)
/*  
Uncaught TypeError: Cannot define property message, 
object is not extensible at Function.defineProperty(<anonymous>) 
报错导致后面代码无法正常运行
*/
Object.defineProperty(obj, 'message', {
  value: 'hello',
})

console.log(obj)
```

使用**Reflect**添加属性

```js
const obj = {
  name: 'zs',
  age: 10,
}

Object.freeze(obj)

//不会报错 返回结果
/*  
Reflect.defineProperty(obj, 'mseeage', {
     value: 'hello'
}) 
*/

if (
  Reflect.defineProperty(obj, 'mseeage', {
    value: 'hello',
  })
) {
  // 成功
  console.log('Successfully added attribute')
} else {
  // 失败
  console.warn('Failed to add attribute...')
}

console.log(obj)
```

配合 Proxy

```js
const obj = {
  _name: 'zs',
  age: 10,

  set name(name) {
    this._name = name
  },

  get name() {
    return this._name
  },
}

const proxtObj = new Proxy(obj, {
  get(target, property, receiver) {
    console.log(`Getting property '${property}'`)
    return Reflect.get(target, property)
  },
  set(target, property, value, receiver) {
    console.log(`Setting property '${property}' to '${value}'`)
    /* 
          this绑定为receiver:代理对象
          相当于set时this._name this为代理对象 这样可以监听两次
          1.proxtObj.name赋值时触发访问器
          2.访问器中this._name = name再次触发 因为相当于 proxtObj._name = name
          这确保了所有基于this的操作
          (比如在setter内部修改另一个属性）都是在proxy上进行的，而不会直接影响到target对象。
        */

    return Reflect.set(target, property, value, receiver)
  },
})

proxtObj.name = '喽喽'

//Setting property 'name' to '喽喽'
// Setting property '_name' to '喽喽'
//  Getting property '_name'
//  喽喽
console.log(proxtObj._name)
```

| Reflect 方法                         | Object 方法                                                                       | 备注                                               |
| ------------------------------------ | --------------------------------------------------------------------------------- | -------------------------------------------------- |
| `Reflect.apply()`                    | 直接调用函数（无直接对应）                                                        | 用于调用函数，替代了函数的`apply`方法。            |
| `Reflect.construct()`                | `new`操作符（无直接对应）                                                         | 用于构造对象，类似于使用`new`操作符。              |
| `Reflect.defineProperty()`           | `Object.defineProperty()`                                                         | 用于定义对象上的一个新属性或修改现有属性。         |
| `Reflect.deleteProperty()`           | `delete`操作符（无直接对应）                                                      | 用于删除对象的属性。                               |
| `Reflect.get()`                      | 直接属性访问（无直接对应）                                                        | 用于获取对象的属性。                               |
| `Reflect.getOwnPropertyDescriptor()` | `Object.getOwnPropertyDescriptor()`                                               | 获取对象某个属性的属性描述符。                     |
| `Reflect.getPrototypeOf()`           | `Object.getPrototypeOf()`                                                         | 获取对象的原型。                                   |
| `Reflect.has()`                      | `in`操作符（无直接对应）                                                          | 判断对象是否有某个属性。                           |
| `Reflect.isExtensible()`             | `Object.isExtensible()`                                                           | 判断对象是否可扩展（能否添加新的属性）。           |
| `Reflect.ownKeys()`                  | `Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()` | 返回一个包含所有自有属性（不包括继承属性）的数组。 |
| `Reflect.preventExtensions()`        | `Object.preventExtensions()`                                                      | 防止对象扩展。                                     |
| `Reflect.set()`                      | 直接属性赋值（无直接对应）                                                        | 用于设置对象的属性。                               |
| `Reflect.setPrototypeOf()`           | `Object.setPrototypeOf()`                                                         | 设置对象的原型。                                   |

---

### Promise

Promise 代表了一个未来可能会完成或失败的操作及其结果。使用 Promise，可以更容易地组织和管理异步代码，尤其是在处理多个异步操作时，可以避免陷入回调地狱。

一个 `Promise` 必然处于以下几种状态之一：

- **Pending**（等待）：初始状态，既没有被完成，也没有被拒绝。
- **Fulfilled**（已完成）：操作成功完成。
- **Rejected**（已拒绝）：操作失败。

```js
/*
      Promise(executor function): executor function,这个函数会立即执行。
    */
let promise = new Promise(function(resolve, reject) {
    // 异步操作
    if (/* 操作成功 */) {
        resolve(value); // 将Promise的状态改为Fulfilled
    } else {
        reject(error); // 将Promise的状态改为Rejected
    }
})
```

<Callout icon="⚠️" type="warning">
  注:**一旦状态被确定下来，Promise 的状态会被 锁死，该 Promise
  的状态是不可更改的**
</Callout>

**resolve 不同值的区别**

1. 一个普通的值或者对象

```js
//一个普通的值或者对象
const promise = new Promise((resolve, reject) => {
  resolve(123)
})

//传给resolve的值作为then的回调参数
promise.then((res) => {
  console.log('res:', res) //res: 123
})
```

2. 另外一个 Promise

```js
//resolve
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('另一个promise')
  }, 3000)
})

//另外一个Promise
const promise = new Promise((resolve, reject) => {
  //新Promise会决定此Promise的状态
  resolve(p)
})

//传给resolve的值作为then的回调参数
promise
  .then((res) => {
    console.log('res:', res) //3000ms后输出 res: 另一个promise
  })
  .catch((err) => {
    console.log('err:', err) //3000ms后输出 err: 另一个promise
  })
```

3. 一个对象，并且这个对象有实现 then 方法

```js
//一个对象，并且这个对象有实现then方法
const promise = new Promise((resolve, reject) => {
  resolve({
    then(resolve, reject) {
      reject('对象then方法...')
    },
  })
})

//传给resolve的值作为then的回调参数
promise
  .then((res) => {
    console.log('res:', res) //res: 对象then方法...
  })
  .catch((err) => {
    console.log('err:', err) //err: 对象then方法...
  })
```

**链式调用**

`.then()` 方法最多接受两个参数；第一个参数是 Promise 兑现时的回调函数，第二个参数是 Promise 拒绝时的回调函数。每个 `.then()` 返回一个新生成的 Promise 对象，这个对象可被用于链式调用，例如：

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo')
  }, 300)
})

//不推荐这么写 看上去混乱
myPromise
  .then(
    (res) => {
      console.log('res:', res) //res:foo
    },
    (err) => {
      console.log('err:', err)
    },
  )
  .then(
    (res) => {
      console.log('res:', res) //res:undefined
    },
    (err) => {
      console.log('err:', err)
    },
  )

//推荐
myPromise
  .then((res) => {
    //myPromise resolve的值会被传参
    console.log('res:', res) //res:foo
  })
  .then((res) => {
    //此处的res相当于上一步.then生成新的promise; new Promise((resolve)=> { resolve()})
    console.log('res:', res) //res:undefined
  })
  .catch((err) => {
    console.log('err:', err)
  })
```

then 返回值

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo')
  }, 300)
})

myPromise
  .then((res) => {
    //默认情况下返回一个新的promise 等同于:new Promise((resolve) = > {resolve()})
    console.log('res:', res) //res:undefined
    //但我们可以手动返回想要的数据
    return 123
  })
  .then((res) => {
    //等同于:new Promise((resolve) = > {resolve(123)})
    console.log('res:', res) //res:123
    //返回一个Promise
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('resolve...')
      }, 3000)
    })
  })
  .then((res) => {
    //上一个.then的promise状态
    console.log('res:', res) // 3000ms 后输出:res:resolve...
    //thentable...
  })
  .then((res) => {
    //当then方法抛出一个异常时，那么它处于reject状态；
    throw new Error('手动抛出异常')
  })
  .catch((err) => {
    console.log('err:', err) // err: Error: 手动抛出异常
  })
```

---

### 迭代器

在 JavaScript 中，**迭代器**是一个对象，它定义一个序列，并在终止时可能附带一个返回值。迭代器对象通过 next()方法返回集合的下一个元素，并通过返回的对象的 done 属性表明是否还有更多的元素。

一个对象如果要成为迭代器，它必须实现 next()方法，这个方法必须返回一个对象，这个对象包含两个属性：

- value：序列中的下一个值。
- done：布尔值，如果序列中所有的值都已经返回，则为 true；如果序列中还有值可以返回，则为 false。

```js
const num = [1, 56, 11, 90]

function createIterator(arg) {
  let index = 0
  /* 
        迭代器对象:
        1.必须有一个next函数
        2.返回值必须为一个对象 对象包含两个属性value：迭代序列的下一个值。。done：布尔值，如果序列中所有的值都已经返回，则为true；如果序列中还有值可以返回，则为false。
      */
  return {
    next() {
      if (index < arg.length) {
        return {
          value: arg[index++],
          done: false,
        }
      } else {
        return {
          done: true,
        }
      }
    },
  }
}

const numIterator = createIterator(num)

console.log(numIterator.next()) //{value: 1, done: false}
console.log(numIterator.next()) //{value: 56, done: false}
console.log(numIterator.next()) //{value: 11, done: false}
console.log(numIterator.next()) //{ value: 90, done: false }
console.log(numIterator.next()) //done: true}
```

**可迭代对象**

要成为**可迭代**对象，该对象必须实现 **`@@iterator`** 方法，这意味着对象必须有一个键为 @@iterator 的属性，可通过常量 Symbol.iterator 访问该属性。

```js
class Student {
  constructor(subject) {
    this.subject = subject
  }

  /* 迭代器
      必须实现 @@iterator 方法,可通过常量 Symbol.iterator 访问该属性
      */
  [Symbol.iterator] = () => {
    let index = 0
    return {
      next: () => {
        if (index < this.subject.length) {
          return { done: false, value: this.subject[index++] }
        } else {
          return { done: true }
        }
      },
      //迭代器中断回调
      return: () => {
        console.log(this, '迭代器被中断')
        return { done: true }
      },
    }
  }
}

const s1 = new Student(['语文', '数学', '科学'])

const s2 = new Student(['地理', '英语', '化学'])

for (const sub of s1) {
  //语文
  //数学
  //科学
  console.log(sub)
}

for (const sub of s2) {
  //地理
  //英语
  console.log(sub)
  if (sub === '英语') break
  //Student{...}  '迭代器被中断'
}
```

**生成器函数**

**生成器函数**提供了一个强大的替代选择：它允许你定义一个非连续执行的函数作为迭代算法。这在处理异步操作、管理流控制等方面非常有用。

生成器函数的定义使用`function*`语法，而不是标准的`function`。当你调用一个生成器函数时，它并不会立即执行，而是返回一个指向生成器实例的迭代器。通过这个迭代器上的`next()`方法，生成器函数可以在每个`yield`表达式处暂停和恢复执行。

```js
function* generatorFunction() {
  yield 'Hello,'
  yield 'World!'
}

const generatorObject = generatorFunction()

console.log(generatorObject.next()) // {value: 'Hello,', done: false}
console.log(generatorObject.next()) // {value: 'World!', done: false}
console.log(generatorObject.next()) // {value: undefined, done: true}
```

参数及返回值

```js
/* 
        传参:
        第一次传参传入声明函数中即可剩余步骤则是在调用next函数中传参
        generatorObject.next('next2')
        接收参数则是在yield前声明
        例:  const name1 = yield 'Hello,'
        返回值:在yield后声明
        例:   const name1 = yield 'Hello'; 'Hello'为返回值
    */
function* generatorFunction(name) {
  console.log('第一次调用next函数...', name)
  const name1 = yield 'Hello'
  const name2 = yield 'World'
}

const generatorObject = generatorFunction('next1')

console.log(generatorObject.next()) // {value: 'Hello,', done: false}
console.log(generatorObject.next('next2')) // {value: 'World!', done: false}
console.log(generatorObject.next('next3')) // {value: undefined, done: true}
```

return 和 throw

```js
function* generatorFunction(name) {
  console.log('第一次调用next函数...', name)
  const name1 = yield 'Hello'
  console.log('第二次调用next函数...', name1)
  const name2 = yield 'World'
}

const generatorObject = generatorFunction('next1')

console.log(generatorObject.next()) // {value: 'Hello,', done: false}
console.log(generatorObject.throw(new Error('new throw error'))) //Uncaught Error: new throw error
// console.log(generatorObject.return());//{} value: undefined, done: true}
```

生成器替代迭代器

```js
const num = [1, 56, 11, 90]

/* 迭代器 */
function createIterator(arg) {
  let index = 0
  return {
    next() {
      if (index < arg.length) {
        return {
          value: arg[index++],
          done: false,
        }
      } else {
        return {
          done: true,
        }
      }
    },
  }
}

const numIterator = createIterator(num)
console.log(numIterator.next()) //{value: 1, done: false}
console.log(numIterator.next()) //{value: 56, done: false}
console.log(numIterator.next()) //{value: 11, done: false}
console.log(numIterator.next()) //{ value: 90, done: false }
console.log(numIterator.next()) //done: true}

/* ----------------------------------------------------------- */

/* 生成器 */
function* createGenerator(arg) {
  for (let i = 0; i <= arg.length; i++) {
    yield arg[i]
  }
}

const generator = createGenerator(num)
console.log(generator.next()) //{value: 1, done: false}
console.log(generator.next()) //{value: 56, done: false}
console.log(generator.next()) //{value: 11, done: false}
console.log(generator.next()) //{ value: 90, done: false }
console.log(generator.next()) //{value: undefined, done: false}
```

yield 语法糖
**yield\* [[expression]]** expression:返回一个可迭代对象的表达式。

```js
function* createGenerator(arg) {
  yield* arg
}

const generator = createGenerator(num)
console.log(generator.next()) //{value: 1, done: false}
console.log(generator.next()) //{value: 56, done: false}
console.log(generator.next()) //{value: 11, done: false}
console.log(generator.next()) //{ value: 90, done: false }
console.log(generator.next()) //{value: undefined, done: false}
```

简化之前可迭代对象

```js
class Student {
  constructor(subject) {
    this.subject = subject
  }

  *[Symbol.iterator]() {
    yield* this.subject
  }
}

const s1 = new Student(['语文', '数学', '科学'])

for (const sub of s1) {
  //语文
  //数学
  //科学
  console.log(sub)
}
```

生成器实现异步函数调用

```js
function requestFn(url) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(url)
    }, 2000)
  })
}

//最原始写法 产生回调地狱
requestFn('my').then((res) => {
  console.log('res1:', res)
  requestFn('code').then((res) => {
    console.log('res2:', res)
    requestFn('foo').then((res) => {
      console.log('res3:', res)
    })
  })
})

//使用生成器实现
function* generatorFn() {
  yield requestFn('hello')
  yield requestFn('co')
  yield requestFn('co')
}

//生成器
/*    const generator = generatorFn()

       generator.next().value.then(res => {
         console.log(res)

         generator.next().value.then(res => {
           console.log(res)

           generator.next().value.then(res => {
             console.log(res)
           })
         })
       }) */

//优化写法
function executionFn(fn) {
  //获取函数生成器
  const generator = generatorFn()
  //递归调用
  function execution() {
    const res = generator.next()
    if (!res.done) {
      res.value.then((data) => {
        console.log(data)
        execution()
      })
    }
  }

  execution()
}

executionFn(generatorFn)
```

### async 和 await

**`async function`** 声明创建一个新异步函数。函数体内允许使用 `await` 关键字，这使得我们可以更简洁地编写基于 promise 的异步代码。` async``await `实际上是基于 Promises 的语法糖，提供了一种更直观和更易读的方式来处理异步操作。

```js
function requestFn(url) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(url)
    }, 2000)
  })
}

async function execFn() {
  const res = await requestFn('code...')
  console.log(res) //2000ms后输出 code...
}

execFn()
```

与普通函数的区别

1. **返回值**:普通函数返回值默认为 undefined 或返回 return 的数据,而 async 异步函数默认返回的则是一个 Promise。

```js
/* 
      默认返回一个promise
      1如果返回一个普通数据相当于 resolve(普通数据)
      2如果返回一个promise,这个primise决定异步函数.then的状态   
      3也可以返回一个thentable
      上述3点和之前描述promise返回值一致
    */
async function execFn() {
  //等同于return new Promise((resolve)=>{resolve()})
}

execFn().then((res) => {
  console.log('execFn异步函数返回值:', res) //execFn异步函数返回值: undefined
})

async function foo() {
  //等同于return new Promise((resolve)=>{resolve(123)})
  return 123
}

foo().then((res) => {
  console.log('foo异步函数返回值:', 123) //foo异步函数返回值: 123
})
```

2. **异常处理**:普通函数遇到报错将不会执行后续代码,而 async 异步函数则会捕获异常在 catch 中进行处理(前提是异步函数有调用 catch)。

```js
function foo() {
  console.log(a) // a is not defined
}

// foo()
//上面异常导致后续代码将不会执行

async function bar() {
  console.log(a) // a is not defined
}

bar()
  .then((res) => {
    console.log(res)
  })
  .catch((err) => {
    console.log('err:', err)
    //错误处理....
  })

console.log('后续代码....') //后续代码....
```

3. await 关键字:普通函数不能使用 await 关键字,而 async 异步函数可以。

### 微任务和宏任务

微任务（Microtasks）和宏任务（Macrotasks）是现代 JavaScript 引擎用来处理异步任务的两种机制，它们在事件循环（Event Loop）中有不同的调度时机。

主要的宏任务包括：

- `setTimeout`
- `setInterval`
- `setImmediate` (Node.js 环境)
- `I/O` (如文件读写、网络通讯等操作，Node.js 环境)
- `UI渲染` (浏览器环境)

主要的微任务包括：

- `Promise.then/catch/finally`
- `MutationObserver` (浏览器特定功能，用于监控 DOM 变化)
- `process.nextTick` (Node.js 环境)
- `queueMicrotask` (直接将任务加入微任务队列的 API)

{/* todo */}
[常见面试题:了解 js 任务队列吗？](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p)
